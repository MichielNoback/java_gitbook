[["index.html", "The Java Track Chapter 1 General introduction", " The Java Track Michiel Noback Chapter 1 General introduction This gitbook accompanies several Java-based courses of the bioinformatics curriculum of the Hanze University of Applied Science. These courses include “Introduction Java”, “Web-based information systems”, “Application Design” and the minor “Application Design”. It covers the basics of Java (Part I - III), some OO fundamentals (Part IV), Java for the web (Part V), JUnit testing (Part VI), Advanced design principles including Design Patterns (Part VII), and some tutorials on the Spring framework (Part VIII). Copyright © Michiel Noback (2019-2021) "],["keyboard-shortcuts.html", "Chapter 2 Keyboard shortcuts", " Chapter 2 Keyboard shortcuts These are the most important keyboard shortcuts - the ones you should memorize (for Linux version): alt + enter - context menu: solve problems &amp; errors, create tests etc. psvm + Tab - create main() sout + Tab - create print statement soutv + Tab - create print statement with variable fori + Tab - create for loop` ^ + shift + R - run main() shift + F6 - rename variable, method or class ctrl + N - generate code (getters and setters, constructors etc.) ctrl + O - override methods ctrl + R - repeat last run ctrl + Q or F1 - show Javadoc of selected method "],["a-first-intellij-project.html", "Chapter 3 A first IntelliJ project 3.1 Dependency management 3.2 A first project 3.3 Distribute an executable 3.4 Wrap-up", " Chapter 3 A first IntelliJ project This course uses the IntelliJ Idea Integrated Development Environment (IDE) to develop Java programs. This chapter deals with using IntelliJ Idea to create Java applications. 3.1 Dependency management As you probably already know by now, code you write is always dependent on other code. This can be code native to the platform (such as the integer “class” in R, or the str class in Python) but it can also be code that is not distributed with the standard platform (such as ggplot2 in R, or numpy in Python). These “non-core” dependencies need to be managed. Many tools exist for dependency management; in Python this can be pip or conda, in R you use install.packages() and in Java there are also several technologies for this. In this course we’ll use Gradle. It does much more than dependency management but for now this is the only relevant aspect. Let’s dive in and see the different players in a Java coding project work together. 3.2 A first project Start IntelliJ and select “+ Create New Project” from the start screen (or New → Project from the File menu). Start screen In the New Project wizard, select Gradle on the left menu and then a project SDK (Standard Development Kit) - this example shows Java 10. Only check Java in the Additional Libraries section. Create project Click “Next”. In the next window, give your project a Name and Location. Expand the Artifact Coordinates section which is hidden by default and give your project a GroupId, an ArtifactId and a Version. Define project The group ID should be a unique identifier; in Java this is usually the web domain of you or your employer, reversed and with a project name appended. It is a way to guarantee a unique name space. Note the underscores; in Java you specify package names with underscores and lowercase letters. The artifact ID is the name of your project, also in lowercase but usually with hyphens between words. Give it version 0.0.1. Click “Finish”. A brand new Gradle-managed Java project will be created with a layout as shown below. A new project Several folders and files have been created. The src folder is where the magic is going to happen of course: that’s where your code is going to live. The other folders are for project management (./.gradle, ./gradle, ./.idea) and deployment (./build which is not present yet). At the root of the project there is a file called build.gradle. It contains the configuration of your project. One dependency has been added: JUnit 4, which is a unit testing framework. Since JUnit 4 is an older version, we’ll immediately change this into JUnit 5. You should modify the build.gradle file so it looks exactly like this (except for the group declaration): //I am using Gradle to manage a Java project plugins { id &#39;java&#39; } //The group ID group &#39;nl.bioinf.nomi.my_first_project&#39; //my version version &#39;0.0.1&#39; //working with Java 11 as target sourceCompatibility = JavaVersion.VERSION_11 //This is where dependencies should be found repositories { mavenCentral() } //the actual dependencies of my project, besides the Java SDK: // only the JUnit 5 test framework in this course dependencies { testImplementation(&quot;org.junit.jupiter:junit-jupiter-api:5.6.2&quot;) testRuntimeOnly(&quot;org.junit.jupiter:junit-jupiter-engine:5.6.2&quot;) } //this says: use Gradle for test management, not IntelliJ test { useJUnitPlatform() } As you can see this is programming code (Groovy) that configures a programming project (Java). Whenever you make changes to build.gradle you should refresh your project via the small pop-up that appears in the editor pane, or via the Gradle Tool Window on the right (Re-import All Gradle Projects). Finally, let’s create some Java code. Right-click on the src/main/java folder in the Project panel (left side) and select “New” → “Package” and give it the same name as your group ID (it is also in build.gradle). New package Select the new package, right-click it and select “New” -&gt; “Java Class”. Name it HelloWorld (do not give any file extension!). New Java class Click “OK”. New Java class The class file will open in an editor. Within the class, put the caret below the line public class HelloWorld. Next, type “psvm” and press tab. Create main Create main A brand new main() method is created using this keyboard shortcut. Here is another extremely useful shortcut, assuming the caret is within main(). Type “sout” followed by the tab. Generate console output The statement System.out.println(); appears. Within this print call, type “Hello, World”. Your class should look like this, except that your package will be named differently: package nl.bioinf.nomi.my_first_project; public class HelloWorld { public static void main(String[] args) { System.out.println(&quot;Hello, World&quot;); } } Click the green triangle within the editor border and select \"run ‘HelloWorld.main()’ Note there is also a shortcut for running main(): ^ + shift + R. Run the app In the console output on the lower pane, you will see this output, including the “Hello, World” message: 20:38:51: Executing task 'HelloWorld.main()'... > Task :compileJava > Task :processResources NO-SOURCE > Task :classes > Task :HelloWorld.main() Hello, World BUILD SUCCESSFUL in 0s 2 actionable tasks: 2 executed 20:38:52: Task execution finished 'HelloWorld.main()'. The “Tasks” are gradle stuff. It says, amongst others, that the source is compiled (Java is a compiled language!) and main() is run. You may notice that a new folder has appeared at the root of your project: build. Have a look at what’s inside. If you get any errors (e.g. Error: LinkageError occurred while loading main class nl.bioinf.nomi.my_first_project.HelloWorld), you need to make sure your specified Java version in build.gradle corresponds to the one configured for your project in IntelliJ (sometimes they get mixed up). Go to File → Project Structure and check under Project Settings/Project and Platform Settings/SDKs. The project SDK should have a version at least as high as the language level specified in build.gradle (in this case, Java 11): Specify SDK Specify SDK 3.3 Distribute an executable The final step is getting the app to your users. In Java you use a jar (Java ARchive) for that. Gradle can do the whole build-to-executable process. You first need to specify where your “main class” is located: the class which contains the main() method that you want to use as “entry point” of your application. Since we use Gradle for the build process, the place to do this is the build.gradle file; open it again and add this section at the bottom: jar { manifest { attributes( &#39;Main-Class&#39;: &#39;nl.bioinf.nomi.my_first_project.HelloWorld&#39; ) } } The Main-Class line specifies for the JVM -when your application is going to be executed- to go look in class HelloWorld for a main() method to run when the application starts up. You can in fact have many main() methods in your application, but only one can serve as entry point in an executable. (Yes, you can make different executables with a single code base by simply specifying different entry points!) Refresh your project as before. Next, Go to the right Gradle Tool Window on the right (make it visible if required: View → Tool Windows → Gradle) and expand the panel. Select Tasks → build → double click “jar”. Your jar will be build under build/libs; go there with a terminal application (IntelliJ also has one) and type java -jar my-first-project-0.0.1.jar. You should see as output ~/IdeaProjects/my-first-project$ ~/IdeaProjects/my-first-project$ cd build ~/IdeaProjects/my-first-project/build$ cd libs ~/IdeaProjects/my-first-project/build/libs$ java -jar my-first-project-0.0.1.jar Hello, World 3.4 Wrap-up That’s it. This is how you create, run and build a Gradle-managed Java project. These are the keyboard shortcuts you should remember: psvm - create main() sout - create print statement ^ + shift + R - run main() Next up: some basic about-Java stuff to get a feel for the language. "],["the-essence-of-java.html", "Chapter 4 The essence of Java 4.1 Cross-platform 4.2 Multithreaded 4.3 Object-Oriented 4.4 Strongly typed and scoped 4.5 Compiled", " Chapter 4 The essence of Java This part deals with some key characteristics of the Java programming language. Java is a very popular platform for several reasons: it is “compile once, run everywhere”, it is the basis of Android, it is embedded in many domestic appliances, and it has a nice clear object-oriented design. 4.1 Cross-platform Java is cross-platform in the sense that once it is compiled it can be run on any operating system that has a Java Runtime installed. This OS-specific Java installation instantiates a Java Virtual Machine (JVM) and passes your compiled code to it, including instructions on which main() method to start on. It is quite an extended story, very well explained here but outside the scope of this course. The key thing to remember is: your Java source files (.java) are compiled into class files (.class) and packaged into a zip-like archive (.jar - java archive) which can be distributed as executable, compatible with any OS. 4.2 Multithreaded Creating multithreaded applications and algorithm is extremely easy because multicore support is build into the language from version 1, and greatly enhanced with the introduction of the Streams API in Java 8. 4.3 Object-Oriented In Java you don’t write and run a script. Instead, you write a program where all logic you create resides in methods within classes. Classes reside in their own source file. Java projects usually have many source files! One of these classes must contain a main() method for the library to be executable. You let the JVM know which class has the main method you want executed through a file called manifest.mf. Besides the raw -primitive- data types such as integer (int) and double, all types are represented by classes, which define the blueprint to construct objects. So objects are the representations (instances) of a single class - more formally called a type. Java provides many types, and you will routinely define your own types when programming. A Class is a Type blueprint that is used to instantiate Objects These objects, the number of which can range from one to many millions within a running application, are the fabric of the program. They hold data (called instance variables) and methods that define their behavior and functionality. 4.4 Strongly typed and scoped This aspect can at first be a bit daunting when coming from languages such as Python or R. Every variable you use must have a declared type. Moreover, every class/object variable or method (member) has keywords defining its scope, also called visibility. Below is an example class that shows these aspects. Read the Javadoc comments (between /** and */) to see what everything means. You do not have to remember or understand all these keywords yet, only get an idea of their role within the code. /** * The package defines the namespace of this class. * There can be many classes of the same name, but the package scope makes them * uniquely identifiable. */ package snippets; /** * Class Snp models a Single Nucleotide Polymorphism. * The class is public, so any class within the project has access to it. */ public class Snp { /** * These are the INSTANCE VARIABLES that model the SNPs data. * They are PRIVATE, so they can not be accessed or modified directly from * outside this class. * The types are long (long integer) and character (single letter). */ private long position; private char referenceNucleotide; private char alternativeNucleotide; /** * This is the CONSTRUCTOR method that forces client code to provide the three * essential properties of a Snp that every INSTANCE should have defined * before being INSTANTIATED. * It is declared public, so accessible to all other code. Properties are * passed as arguments to the constructor and stored as INSTANCE VARIABLES. * @param position a long integer * @param reference a single character: A, C, G or T * @param alternative a single character: A, C, G or T * @throws IllegalArgumentException if the given position is negative */ public Snp(long position, char reference, char alternative) { /* A check is performed on the first parameter. * An exception (error) is generated when the value is wrong.*/ if (position &lt; 1) { throw new IllegalArgumentException(&quot;position must be positive&quot;); } this.position = position; this.referenceNucleotide = reference; this.alternativeNucleotide = alternative; } /** * a GETTER for the position. Since the position field is private, this makes * it a READ_ONLY property. * @return position as long integer */ public long getPosition() { return position; } public char getReferenceNucleotide() { return referenceNucleotide; } public char getAlternativeNucleotide() { return alternativeNucleotide; } /** * this method tells a client whether ths SNP is a transition or a transversion. * The return type is boolean (true or false). * @return isTransition */ public boolean isTransition() { return ((referenceNucleotide == &#39;A&#39; &amp;&amp; alternativeNucleotide == &#39;G&#39;) || (referenceNucleotide == &#39;C&#39; &amp;&amp; alternativeNucleotide == &#39;T&#39;)); } } 4.5 Compiled Java is a compiled language, which means you have to compile the source into byte code before it can be run. Fortunately, you have to compile it only once, for the JVM and not multiple times, for every OS you want to support. Whenever you run an application within IntelliJ, it is first compiled: all source files (.java files) are compiled into byte code files that have a .class extension. You can find these in the build folder. To create a distributable application, you need to build it into a “Jar” - with .jar extension. You run these on the command line using the command java -jar &lt;my-app.jar&gt;. The Gradle toolbox has all kinds of Tasks to automate this for you. Related to this: Run-time syntax errors do not occur - they are stopped by the compiler. The compiler will not compile erroneous code. "],["first-look-at-objects.html", "Chapter 5 Objects: ninjas and growing cells 5.1 Ninjas 5.2 Growing cells 5.3 Object construction (first iteration) 5.4 Inheritance (first discussion)", " Chapter 5 Objects: ninjas and growing cells This chapter presents two independent discussions of what classes and objects are. The first “Ninjas” focuses on what an object is and does. The second, “Cells” also discusses object relationships and testing. 5.1 Ninjas Suppose you are building a game with ninjas, trolls and all sorts of nasty creatures. In an Object-Oriented programming environment such as Java you will start by defining the entities that play a role in the app you are developing. In this case, Ninja will be one of the entities, or Types populating the application. Other Types in this game may be Troll, Game, Player, Weapon, ScoreBoard, and so on. Each of these Types will have properties and behavior: things they have and things they can do. A Type is represented by a blueprint, its class. Such a class resides in a single source file. In the Java core packages many types are predefined. There are very basic types, for instance Integer (representing whole numbers) and String (representing character data) but there are also more complex Types, such as LocalDate. When programming you will create novel Types all the time. A Ninja type for instance. We’ll have a look at the Ninja type and create a blueprint for it. In our game, Ninjas can do what you expect of them: they have a name and an energy level (0 means they’re dead, 100 is freshly spawned), they have a position in the game and they can move, and attack their opponents. There’s more of course but let’s keep things simple for now. Given the above description, this is a first draft of a Ninja class that I came up with. //package defines namespace package nl.bioinf.nomi.ninjas; //the actual class class Ninja { //Here are the properties every Ninja will HAVE //We call these INSTANCE VARIABLES String name; int energyLevel = 100; double topCoordinate; double leftCoordinate; //Here are the methods - what every Ninja can DO void move(double top, double left) { this.topCoordinate += top; this.leftCoordinate += left; } void attack(int power, GameCharacter opponent) { //energy is drawn from its own reserve for an attack this.energyLevel -= power; //but has double effect on its opponent opponent.drainEnergy(power * 2); } //end of the class } I kept this class really clean - no access modifiers (public, private, static, etc) that will distract from the key points being made here. At the top of the file there is a package declaration. This defines the namespace this class lives in. Since nobody in their right mind would use my web domain, I’m pretty sure the fully qualified name nl.bioinf.nomi.ninjas.Ninja will uniquely point to this class. Think about it: how many User classes will have been designed over the world? Next, there is the line class Ninja { which delimits the actual class body. No code except for the package declaration and import statements can live outside the class body - it will not compile. Below the class name declaration you find its instance variables. These define the properties that all instances (created objects) of this class will have. You can see only one of the instance variables has an assigned value: energyLevel. This means that every Ninja will have an energy level of 100 once it is constructed. Do the other variables have no value? Yes they do; if a value is not declared for instance variables they will get the default value of the type. For object types this is null, for boolean it is false and for numeric types it is 0. So this: String name; int energyLevel = 100; double topCoordinate; double leftCoordinate; is exactly te same as this: String name = null; int energyLevel = 100; double topCoordinate = 0; double leftCoordinate = 0; Within the class body, no free-living statements are allowed other than declaration and assignment of its instance variables. So these are allowed: double leftCoordinate; and int energyLevel = 100;, but a for-loop is not. Finally, there are two methods defined: move() and attack(). Method move() is pretty straightforward; it changes the location of the Ninja object on which the method is called (we call this the current object) by the given lateral and vertical offsets. The use of this. indicates we are accessing the current objects’ instance variables. Use of this. is not required but strongly encouraged. The method does not return anything, as declared by the void return statement. The next method, attack() is a little more complex. Its signature void attack(int power, GameCharacter opponent){ } says it should receive a power value for its attack as well as an instance of the GameCharacter class (below) which will be the subject of the attack. Not only does it operate on its own instance variables, but also it also calls a method on the object it is attacking: opponent.drainEnergy(power * 2);. This method does not return anything either. Here is the GameCharacter class: package nl.bioinf.nomi.ninjas; public class GameCharacter { public int energyLevel = 100; public void drainEnergy(int amount) { this.energyLevel -= amount; } } Here is some usage within a class called Game. The main() method has been discussed in the previous chapter. This is the first place we see the new keyword. Whenever you see the new keyword, it means a new object is instantiated of the type specified after new. So new Ninja(); means a new Ninja instance (object) has been created, inwhich the instance variables have been created and given their specified values, or the default values discussed above. See the section later in this chapter for more details on object construction. package nl.bioinf.nomi.ninjas; public class Game { public static void main(String[] args) { //spawn (instantiate) a Ninja Ninja ninja = new Ninja(); //change its name ninja.name = &quot;Rogue Bastard&quot;; //print some values of the ninja System.out.println(&quot;Ninja name = &quot; + ninja.name); System.out.println(&quot;Ninja energy = &quot; + ninja.energyLevel); System.out.println(&quot;Ninja position = [&quot; + ninja.topCoordinate + &quot;:&quot; + ninja.leftCoordinate + &quot;]&quot;); //spawn an opponent GameCharacter opponent = new GameCharacter(); opponent.name = &quot;Delirious Troll&quot;; //change position twice ninja.move(2, 9); ninja.move(-6.4, 3.5); System.out.println(&quot;Ninja position = [&quot; + ninja.topCoordinate + &quot;:&quot; + ninja.leftCoordinate + &quot;]&quot;); //attack opponent ninja.attack(5, opponent); //energy of both has changed System.out.println(&quot;Ninja energy = &quot; + ninja.energyLevel); System.out.println(&quot;Opponent name = &quot; + opponent.name); System.out.println(&quot;Opponent energy = &quot; + opponent.energyLevel); } } The terminal output, when main(0) is run, will be: Ninja name = Rogue Bastard Ninja energy = 100 Ninja position = [0.0:0.0] Ninja position = [-4.4:12.5] Ninja energy = 95 Opponent name = Delirious Troll Opponent energy = 90 That’s a first acquaintance with classes and objects. We have used the core Java class String, and defined three of our own: Ninja, GameCharacter and Game. Besides this, we have used the primitive types int and double. Next up: Cells and TestTubes in a second round of getting to know objects. As extra layer, JUnit testing will be introduced. 5.2 Growing cells Suppose you want to build a cell growth simulation application. After careful analysis of the domain you decided that this involves three entities: A simulator that controls the simulation process, a test tube that will hold the cells that are growing, and the cells themselves. The next step in a modeling process is to determine the relationships between the different entities. In this case this is as follows. The simulator will receive configuration arguments (e.g. how many cells to grow) from the command-line, start the simulation process and instantiate a test tube. The test tube will be responsible for instantiating the initial cell population. Finally, there will be cells growing within the test tube. Three separate source files are created (within a single package), each holding one class: CellGrowthSimulator.java TestTube.java Cell.java Cell.java We’ll start with the simplest one: Cell. It has an instance variable called “size” which has a default value of 5 when Cell objects are instantiated. Every call of the grow() method makes it increase its size by one. package snippets.testtube; class Cell { /** * Instance variable &quot;size&quot;; 5 micrometer is the default diameter when Cell objects are instantiated */ int diameter = 5; /** * Lets this cell grow in a single 1-micrometer increment */ void grow() { //grow by 1 micrometer this.diameter += 1; System.out.println(&quot;I am a Cell. My size is &quot; + this.diameter); } } To test the logic and correctness of this class we will have to wait until other components are developed, such as TestTube and CellGrowthSimulator. Unless you use (J)Unit testing. JUnit testing JUnit is a unit testing framework for Java. Its main purpose is to have a suite of test methods guaranteeing the correctness of your production code. To create JUnit a test method, you need to have the JUnit libraries defined as dependencies on your class path. See the post “A first IntelliJ project” for instructions how to that for JUnit5. This piece should be in your build.gradle file: dependencies { testImplementation(&quot;org.junit.jupiter:junit-jupiter-api:5.6.2&quot;) testRuntimeOnly(&quot;org.junit.jupiter:junit-jupiter-engine:5.6.2&quot;) } Next, you need to create a test class. Place the cursor on the class name (Cell) and press alt+enter. Select “Create Test”. Create JUnit class Select the method(s) you want to create test(s) for and press “OK”. Create JUnit class The test class opens in the editor and looks something like this: package snippets.testtube; import org.junit.jupiter.api.Test; import static org.junit.jupiter.api.Assertions.*; class CellTest { @Test void grow() { } } Let’s put some testing code in it to see whether our program logic works as intended: @Test void grow() { Cell cell = new Cell(); //the initial diameter is supposed to be 5 assertTrue(cell.diameter == 5); cell.grow(); //the diameter should have increased by one assertTrue(cell.diameter == 6); } When you click on the little green triangle in the editor margin, the test will be executed and you get output like this: Create JUnit method The green checks indicate the test assertions passed. Knowing the Cell class is OK, let’s proceed to class TestTube. TestTube.java TestTube is slightly more complex. It defines a constructor that makes it mandatory to provide an initial number of cells. It will throw an IllegalArgumentException when a wrong value is passed for the initialCellCount parameter. You again see the use of the keyword new to instantiate Cell objects. package snippets.testtube; class TestTube { Cell[] cells; /** * Constructs with an initial cell count. * An exception is thrown when the initial cell count is below 1 or above 10e4. * * @param initialCellCount the initial cell count * @throws IllegalArgumentException ex */ TestTube(int initialCellCount) { if (initialCellCount == 0 || initialCellCount &gt; 10e4) { throw new IllegalArgumentException(&quot;initial cell count should be above 1 and below 10e4: &quot; + initialCellCount); } //initialize the array with new Cells cells = new Cell[initialCellCount]; for (int i = 0; i &lt; initialCellCount; i++) { cells[i] = new Cell(); } } /** * Grows the cells, in one single iteration. */ void growCells() { for (Cell cell : cells) { cell.grow(); } } } Note the for-loop in the constructor of this class: for (int i = 0; i &lt; initialCellCount; i++) { cells[i] = new Cell(); } It has three elements between the parentheses: for (&lt;LOOP INITIALIZATION&gt;; &lt;EXIT CONDITION&gt;; &lt;ITERATION INCREMENT&gt;) The for-loop itself will be dealt with in the post “Flow control structures”. Here is a JUnit test to verify the construction of the TestTube: class TestTubeTest { @Test void growCells() { TestTube testTube = new TestTube(10); assertTrue(testTube.cells.length == 10); } } CellGrowthSimulator.java The last class of the system is CellGrowthSimulator. Here is a first version: package snippets.testtube; /** * &quot;Controller&quot; class */ class CellGrowthSimulator { /** * @param args command-line args should be length one, * containing an initial cell number. */ static void main(String[] args) { if (args.length != 1) { System.err.println(&quot;You must provide an initial cell count. Aborting.&quot;); } //args[] is a String array, so the item at index [0] //should be converted into and `int` first. int initialCellNumber = Integer.parseInt(args[0]); startSimulation(initialCellNumber); } static void startSimulation(int initialCellNumber) { TestTube testTube = new TestTube(initialCellNumber); //do one iteration of growing testTube.growCells(); } } The String[] args argument to main() is the argument array passed from the terminal when you start the application. (Be aware that this type of use of command-line arguments is discouraged; you should implement and support a standards-adhering command-line syntax, e.g. java -jar GrowthSimulator --initial_count 5). The final model now has this chain of relationships: CellGrowthSimulator HAS-A TestTube and TestTube HAS one or more Cells. 5.3 Object construction (first iteration) You have seen the new keyword used several times now. But what does happen, exactly, when you type Cell cell = new Cell(); The new keyword combined with the class name followed by parentheses calls the constructor method of that class. The constructor instantiates an instance of the class and returns the reference to the object. The parentheses () enclose the argument list for the constructor method, which is empty in this case. In class TestTube we did see a constructor argument however - one specifying the number of cells to grow. The three steps of object construction are declaration, creation and assignment: The code Cell cell declares a variable of type Cell. The code new Cell() instantiates an object of type Cell, stores this in memory and returns a reference to this stored object. The equals sign = assigns (couples) the returned reference to the declared variable. So…where is this constructor method in class Cell and what does it do? If you look at the class you don’t see a constructor, as we have seen in class TestTube. It is created by the Java compiler if you don’t specify it yourself. The compiler-processed code will have something like this inserted: public Cell() {} More on constructors in later chapters. 5.4 Inheritance (first discussion) Inheritance is one of the key features of object-oriented programming. This is a very powerful mechanism to introduce new or adjusted behavior in a software system because subclasses inherit all properties and methods of their superclass. For example, the CancerCell class below extends Cell and thus declares itself to be a subclass of Cell. It not only extends itself with new functionality (move()), but also modifies the behavior of the grow() method by changing the growthIncrement property of its supertype part. //Cell.java class Cell { int diameter = 5; int growthIncrement = 1; /** * Lets this cell grow in a single increment */ void grow() { //grow by 1 micrometer this.diameter += growthIncrement; System.out.println(&quot;I am a Cell. My size is &quot; + this.diameter); } } //CancerCell.java public class CancerCell extends Cell { CancerCell() { growthIncrement = 3; } void move() { System.out.println(&quot;Moving through the body&quot;); } } //usage within GrowthSimulator Cell cell = new Cell(); cell.grow(); cell.grow(); System.out.println(&quot;..........&quot;); CancerCell cCell = new CancerCell(); cCell.grow(); cCell.grow(); cCell.move(); output: I am a Cell. My size is 6 I am a Cell. My size is 7 .......... I am a Cell. My size is 8 I am a Cell. My size is 11 Moving through the body This is of course not the only place where we’ll see inheritance discussed. "],["basic-program-structure-and-flow.html", "Chapter 6 Basic program structure and flow 6.1 Basic program structure 6.2 Summary", " Chapter 6 Basic program structure and flow Basic program structure and some flow control. Advanced flow control (switch etc) will be described later. 6.1 Basic program structure As stated before, a Java program must have a main() method as starting point. This main() method needs to reside in a class, because all Java code needs to live inside a class. /** * The package declaration; it defines the namespace of this class * */ package snippets; public class MostBasicApp { /** * This is a STATIC method, which means it is a class-level method and needs no object/instance to * be called. * The return type is &quot;void&quot;: it does not return anything. * @param args the command-line arguments are passed here as string array */ public static void main(String[] args) { System.out.println(&quot;Basic App has started&quot;); System.out.println(&quot;...and ended&quot;); } } This is a very uninteresting app of course, since it doesn’t do anything. Let’s extend it with a bit of functionality. We’ll pass the program 2 arguments: one for age and one for user name. If no arguments are provided, we’ll print some usage information. To pass command-line arguments within IntelliJ, you need to create or edit a run configuration. If you have run the main before (by clicking on the green triangle - see post intelliJ), you click on the toolbar run configurations box and select “Edit configurations”- see screenshot. Run configuration The only thing yu need to do now is enter two “Program arguments”. Here, I filled out “Henk” and “49”, with a space between them. Run configuration An array (which is kind of a list) of String elements called args will be passed to main() as String[] args. This array will hold the command line arguments when next running the program, as demonstrated below. public static void main(String[] args) { for (String arg : args) { System.out.println(&quot;arg = &quot; + arg); } } This will output arg = Henk arg = 49 Here you hae seen the first program flow construct in action: the foreach loop. It is equivalent to for-loops in any programming language: it iterates a collection of some sort. Here the collection is an array. Note it does not have a counter; there is a different variant of the for loop for that. Let’s introduce one other flow construct: decisions with if/else. Suppose you want to give your user some uplifting message, depending on their age. First the age argument needs to be converted from String to int: /** * Use indexing to access array elements */ String name = args[0]; /** * Parse String into int */ int age = Integer.parseInt(args[1]); System.out.println(&quot;Hi &quot; + name + &quot;, your age is &quot; + age); Next, the choice of message needs to be made. if(age &lt; 18) { System.out.println(&quot;ahh the energy of youth&quot;); } else if (age &lt; 50) { System.out.println(&quot;nice to meet somebody in the prime of their life!&quot;); } else { System.out.println(&quot;hey, don&#39;t worry - every day brings you closer to retirement&quot;); } The classic elements of the if/else decision block. Finally, let’s bring a dedicated object into play: the message maker. The class looks like this: package snippets; public class MessageMaker { private final String name; private final int age; /** * Constructor makes it mandatory to instantiate with name and age arguments. * @param name * @param age */ public MessageMaker(String name, int age) { this.name = name; this.age = age; } public void printMessage() { System.out.println(&quot;Hi &quot; + name + &quot;, your age is &quot; + age); if(age &lt; 18) { System.out.println(&quot;ahh the energy of youth&quot;); } else if (age &lt; 50) { System.out.println(&quot;nice to meet somebody in the prime of their life!&quot;); } else { System.out.println(&quot;hey, don&#39;t worry - every day brings you closer to retirement&quot;); } } } And this is how you instantiate and use an object of such a class. public class MostBasicApp { public static void main(String[] args) { String name = args[0]; int age = Integer.parseInt(args[1]); /*A first object is instantiated and a method is called on it.*/ MessageMaker messageMaker = new MessageMaker(name, age); messageMaker.printMessage(); } } So, here we have a two-class application. Both source files are in the same package (namespace). The first is the so-called “main class” which is the entry point of the application: MostBasicApp in source file MostBasicApp.java. The main method receives the command-line arguments and parses one of them into an integer. Next, it instantiates a MessageMaker object and calls its printMessage() method. 6.2 Summary You have seen the basic structure of a Java program. It needs at least one source file with one class. There needs to be a main() method of this signature to be executable as program: public static void main(String[] args) { //startup code } Two flow control structures were shown: the for-each loop and if/else decisions: //foreach for(item : collection) {} //if/else if(conditionIsTrue) {} else if(alternativeConditionIsTrue){} else {/*default logic*/} That’s it. Next up: Data Types. "],["naming-and-commenting-stuff.html", "Chapter 7 Naming and commenting stuff 7.1 Naming 7.2 Commenting", " Chapter 7 Naming and commenting stuff Anyone who knows me (as a teacher) knows that (a) I really like Java and (b) I really really hate it when stuff gets named in the wrong way. 7.1 Naming Experienced programmers can read code as if it is a nice book. When doing this, we rely on some conventions, just like in real language. For instance, in regular human text, names start with a capital, and sentences have a certain grammatical structure that makes it possible to read quickly without too much confusion. Whenever texts do not adhere to these rules or conventions, reading becomes very difficult. Programming languages are no different, and naming and layout-conventions help human readers to makes sense of it really quickly. Java has a concise set of naming rules that you should adopt from your first endeavors. Here are the most important ones. For all names -classes, methods, variables- the single most important rule is that they should describe what they model in a precise and concise way. For instance, a valid counter for te number of logins in a system could be c, count, counter or loginCounter, but only the last is really informative to anyone reading te code. The second general rule is that Java identifiers are always in CamelCase, with the exception of certain types of constants. Also, never start names with a number and do not use special characters! These are illegal and will not compile: 1forTheMoney, k#ller. 7.1.0.1 Classes Class names should be a noun, in camel case, with the first letter capitalized. Here are a few good and bad examples for names of a class reading GFF data from a file: class Read {} //bad - no noun and vague class Reader {} //bad, vague class DataReader {} //bad, still vague class dataReader {} // bad - starts with lowercase class Data_Reader {} // bad - underscore is not camelcase class GffRead {} //bad, not a noun class GffReader {} //good: a noun and specific 7.1.0.2 Methods Method names should be a verb, in camel case. Here some examples for a method name calculating the Euclidean distance between two Point objects: double d(Point otherPoint) {} //bad - no verb and vague double distance(Point otherPoint) {} // bad - no verb and still slightly vague double euclidean_distance(Point otherPoint) {} //bad, no camel case double EuclideanDistance(Point otherPoint) {} // bad - starts with uppercase character double euclideanDistance(Point otherPoint) {} // almost good, but no noun double getEuclideanDistance(Point otherPoint) {} //finally OK 7.1.0.3 Variables Variable names should be nouns as well, but starting in lowercase: double r; //plain bad double ratio; //bad - what ratio? double Ratio; //bad - starts with uppercase double screen_ratio; //bad - underscore double screenAspectRatio; //good: noun and descriptive 7.2 Commenting There are three ways for commenting: Javadoc style: /**\\&lt;LINE(S)\\&gt;*/ these are the most important because they end up in your documentation! multiline comment /*\\&lt;LINE(S)\\&gt;*/ single line comment //\\&lt;SINGLE LINE\\&gt; Here are some examples: /** * This is a Javadoc comment for the class: it describes what the class models and should be used for. * Also, version and author information can be put here. * @author Michiel * @version 0.1 * */ public class Duck { /** * This is a Javadoc comment for a method. * It should include tags for method arguments, exceptions and return types. * @param loudness */ public void quack(int loudness) { //single-line logic comment System.out.println(&quot;Quacking at level &quot; + loudness); /*I can write a multiline block of * comment like this*/ } } Here is a screenshot of part of the the corresponding Javadoc html: Javadoc I strongly encourage you to try this out for yourself: create a class, put some javadoc comments in it and run “Tasks -&gt; documentation -&gt; javadoc” from the Gradle tool window. The javadoc folder will be located in the build/docs/ folder. The javadoc tool will issue warnings but proceed for some inconsistencies, but errors and abort for others. The warnings and errors are pretty clear, fortunately. "],["data-types.html", "Chapter 8 Data Types 8.1 Primitives 8.2 Reference types 8.3 What is the difference? 8.4 Summary", " Chapter 8 Data Types Data forms the state of an object. They define the properties that define how it will behave through methods. As stated before, Java is a strongly typed language. That means every variable, method parameter and method return type needs to have a declared type. These types can be primitives or reference types. This post deals with both, and with the “behavioral” differences between them. 8.1 Primitives In essence, every programming language knows about the same data types: integers, floats, booleans, Strings. Java is no different. However, there are a few major distinctions. First, you need to declare the type of every variable. Also, conversion between them usually needs to be done explicitly. Finally, for memory efficiency reasons, there are “subtypes” of integers and floats. Floating-point numbers for instance (numbers with a decimal part), can be represented by the float type (“floating point number) or the double (”double-precision floating point number\") which takes twice as much of memory. You have to realise Java was first launched in the 1990s, when memory was a scarce and valuable asset in a computer… Here are all the primitive types: Primitive types The three steps of primitive type creation are these. Create primitive First, a variable of a certain type is declared. A memory slot of the appropriate size is reserved. Then the bit-pattern representing the declared value is created and put into the memory slot. Finally the variable is “coupled” to the memory slot. Here is some demo code where some of these types are used. class JavaTypesDemo { public static void main(String[] args) { /* INTEGER counts the number of kills */ int killCount = 42; /*BOOLEAN for yes/no variables; indicates alive status*/ boolean alive = false; /*DOUBLE for floating point values; indicates the average number of kills per life cycle*/ double killAverage = 10.55; /*CHARACTER for single letter values; stores mode of the game &#39;N&#39;=No mercy &#39;S&#39;= Sissy*/ char playmode = &#39;N&#39;; /*STRING for text values; the name of the player*/ String player = &quot;ZZZZZombie&quot;; System.out.println(&quot;player = &quot; + player); System.out.println(&quot;alive = &quot; + alive); System.out.println(&quot;play mode = &quot; + playmode); System.out.println(&quot;kill count = &quot; + killCount); System.out.println(&quot;kill average = &quot; + killAverage); } } This will output player = ZZZZZombie alive = false play mode = N kill count = 42 kill average = 10.55 In the above example, all variables were declared and initialized in one statement, but it is allowed to split this up. The only thing that is illegal (not compilable) is to leave a declared variable uninitialized and access it: //LEGAL int killCount; killCount = 0; //ILLEGAL; not initialized int livesLived; //no compile error here System.out.println(&quot;livesLived = &quot; + livesLived); //but here! When combining primitives in mathematical operations, they usually behave as expected. However, when you start combining them in a “mixed” environment, it becomes a bit tricky. The general rule is it is always safe to “up” the precision or keep it equal, but dangerous to “lower” the precision. For that reason, lowering the precision needs to be done explicitly, through a (type) cast. Here are a few examples using primitives. int x = 10; int y = 20; int squareSurface = x * y; //200 No problem here. Two ints combine to a new int. Precision stays the same. In the next example, the Math class is used in two ways. Math.PI is a constant and Math.pow() is a function. Both are used to calculate the surface area of a circle: double circleSurface = Math.PI * Math.pow((0.5 * x), 2); //78.53981633974483 Note that an int, x is used in a double context (0.5 * x) without any problem. The int is “upped” in precision to a double. Whenever an int is used in conjunction with a double, it is automatically cast into the higher-precision type (more on casting later). But in the next snippet, double division = x / y; System.out.println(&quot;division = &quot; + division); the output is, slightly unexpected division = 0.0 Can you explain? Two ints were divided (x / y or 10 / 20), resulting in an int. Since ints do not have a decimal part, this is 0. Casting a zero to a double subsequently resulted in 0.0. How to circumvent this problem? You need to convert one of them in an early stage into a double. Although both would work, it is more logical to cast the numerator (x) to a double. double division = (double)x / y; System.out.println(&quot;division = &quot; + division); //outputs division = 0.5 Because x was cast to a double, y found itself in an operation involving a double. It was therefore automatically cast into a double as well, resulting in a double division. Here is an example where you are forced by the compiler to cast from double to int. double ratio = 1.234; int intRatio = ratio; //DOES NOT COMPILE! int intRatio = (int)ratio; //LEGAL Since conversion from double to int has the risk of loss of information (precision), you are forced by the compiler to be explicit about it. Here are some more esoteric behaviors of primitives, ad cases that are (unexpectedly) illegal: char nucleotide = &#39;A&#39;; //allowed, because a char is an 16-bit int under water System.out.println(nucleotide * 10); //650 System.out.println((char)(nucleotide + 5)); //F boolean isAlive = true; //not allowed; although in some languages this works just fine //System.out.println(&quot;isAlive * 10 = &quot; + isAlive * 10); String name = &quot;Hank&quot;; //surprisingly, this is allowed; the int is automatically converted (not cast!) into a String System.out.println(name + 10); //Hank10 //not allowed; the * operator does not support these two types as operands //System.out.println(&quot;name * 10 = &quot; + name * 10); 8.2 Reference types In Java, reference types are everywhere; they point to the object instances. Strings, arrays, and every Java class -also the ones you create- represent reference types. With primitive-typed variables, the value of the variable is simply the value, in bits, but with reference variables, the value of the variable is bits representing a way to get to a specific object (like a remote control) A remote control Creating a reference type variable A reference-type variable Type String Type String needs some special attention. It is actually NOT a primitive type, although always dealt with alongside them. You could have guessed from the name, which starts with a capital. It is a full-fledged Java class that can be instantiated and that has many nice methods. It is however immutable as in most languages, and has a shortcuts that most other classes do not have: you can create them from a literal. Here is some example usage of class String. String dnaOne = &quot;AGAGGTCTAGCTGA&quot;; String dnaTwo = &quot;GGTCTAGC&quot;; String dnaThree = &quot;GGtctAGc&quot;; String dnaFour = dnaThree.toUpperCase(); System.out.println(&quot;dnaOne - character at position 6: &quot; + dnaOne.charAt(5)); //T System.out.println(&quot;dnaOne contains dnaTwo: &quot; + dnaOne.contains(dnaTwo)); //true System.out.println(&quot;dnaTwo equals dnaThree ignoring case: &quot; + dnaTwo.equalsIgnoreCase(dnaThree)); //true System.out.println(&quot;dnaOne starts with \\&quot;AGAGGT\\&quot;: &quot; + dnaOne.startsWith(&quot;AGAGGT&quot;)); //true System.out.println(&quot;dnaFour.toCharArray(): &quot; + dnaFour.toCharArray()); //[C@6f3b5d16 but this changes: this is the reference value (the remote control endpoint) Testing equality (of Strings) A very common mistake with beginning (and advanced) Java programmers is the way String comparison is carried out. To test sameness, use ==. This returns true if the variables are the same primitives or point to the same object on the heap. To test logical equality, use the .equals() method. Strings may be the same in content, but return false when tested for sameness: two distinct string objects on the heap can have the same content. String dnaOne = &quot;AGAGGTCTAGCTGA&quot;; String dnaFive = new String(&quot;AGAGGTCTAGCTGA&quot;); System.out.println(&quot;dnaOne equals dnaFive: &quot; + dnaOne.equals(dnaFive)); System.out.println(&quot;dnaOne == dnaFive: &quot; + (dnaOne == dnaFive)); outputs: dnaOne equals dnaFive: true dnaOne == dnaFive: false and to make it more confusing: String dnaOne = &quot;AGAGGTCTAGCTGA&quot;; String dnaSix = &quot;AGAGGTCTAGCTGA&quot;; System.out.println(&quot;dnaOne == dnaSix: &quot; + (dnaOne == dnaSix)); outputs: dnaOne == dnaSix: true And this has to do with String literal caching by the JVM. A special case: null There s a special value for reference type variables: the null value. It can be assigned to all Java reference type variables. This value is used when you want to declare a variable, but don’t know a useful default or starting value for it. However, there is great danger lurking when using null values. They are not backed by an object, so when you try to access values on them, or call methods, you get a big fat NullPointerException thrown in your face. static void nullValueDemo() { String nullString = null; //prints just fine! System.out.println(&quot;nullString = &quot; + nullString); //NullPointerException! nullString.charAt(0); } outputs nullString = null java.lang.NullPointerException at snippets.JavaTypesDemo.nullValueDemo(JavaTypesDemo.java:145) at snippets.JavaTypesDemoTest.nullValueDemoTest(JavaTypesDemoTest.java:36) (stack trace continues) 8.3 What is the difference? To be passed around as primitive Java is pass-by-copy, so to pass a primitive means to pass a copy of it. Whatever happens with the copy has no impact on the original: static void primitivePassingDemo() { int x = 42; System.out.println(&quot;x = &quot; + x); changePrimitiveVariable(x); System.out.println(&quot;x = &quot; + x); } static void changePrimitiveVariable(int number) { System.out.println(&quot;number = &quot; + number); number = 55; System.out.println(&quot;number = &quot; + number); } outputs this: x = 42 number = 42 number = 55 x = 42 To be passed around as reference type Java is pass-by-copy, so to pass a reference type means to pass a copy of the reference. Now you have two references pointing to the same object on the heap. static void referencePassingDemo() { Cell cell = new Cell(); System.out.println(&quot;cell.diameter = &quot; + cell.diameter); changeReferenceVariable(cell); System.out.println(&quot;cell.diameter = &quot; + cell.diameter); } static void changeReferenceVariable(Cell theCell) { System.out.println(&quot;theCell.diameter = &quot; + theCell.diameter); theCell.diameter = 12; System.out.println(&quot;theCell.diameter = &quot; + theCell.diameter); } outputs this: cell.diameter = 5 theCell.diameter = 5 theCell.diameter = 12 cell.diameter = 12 So, switching back to String, which is a reference type. Can you explain this behavior? static void stringPassingDemo() { String hello = &quot;Hello World&quot;; System.out.println(&quot;hello = &quot; + hello); changeStringVariable(hello); System.out.println(&quot;hello = &quot; + hello); } static void changeStringVariable(String message) { System.out.println(&quot;message = &quot; + message); message = &quot;Bye now!&quot;; System.out.println(&quot;message = &quot; + message); } hello = Hello World message = Hello World message = Bye now! hello = Hello World It looks as if String behaves as a primitive! That is NOT true! Strings are immutable. This means the you cannot change a String object; you can only make a changed copy of it. In the above example, a new String object was created within method changeStringVariable(). The existing one was not changed but discarded. 8.4 Summary You have seen an overview of the Java primitives, and what you can do with them. The concept of casting has been introduced. This casting can be implicit (from low to high information content), but when you try to go from high to low information content, with a possible loss of information, you must always cast or your code won’t compile. This post has also outlined what reference types are, and what the difference between these and primitives are. Next: arrays, the simplest form of collections. "],["arrays.html", "Chapter 9 Arrays 9.1 Creating arrays 9.2 Printing 9.3 Accessing 9.4 Multidimensional arrays", " Chapter 9 Arrays Just like any programming language, Java knows about arrays. Arrays are ordered collections of variables of the same type. These elements can by any valid Java type: primitives, object references, or even null values. These variables are not individually named and managed, but collectively. In real life, you don’t use arrays too much because other types (ArrayList) are often more convenient because arrays can’t be extended or shortened and don’t have all those nice helper methods that ArrayList has (see the collections post). However, arrays certainly have their use when (memory) efficiency is an issue, or when you want to go multidimensional. Of course, the String array String[] args is the entry point of outside arguments into any Java program: public static void main(String[] args) { for(int i = 0; i &lt; args.length; i++) { System.out.println(&quot;argument &quot; + i + &quot; is &quot; + args[i]); } } 9.1 Creating arrays To create an array, you have to specify what type it will hold, and how many elements it will hold. This can be done via: passing the size as a “constructor” argument declaring a literal Here are both ways for primitives and reference type elements. //create by specifying size - will contain zeros int[] numbers = new int[5]; //create by specifying contents double[] scores = {2.1, 3.0, 4.5, 5.6}; //create by specifying size - will contain nulls Cell[] cells1 = new Cell[6]; //create by specifying contents Cell[] cells2 = {new Cell(), new Cell(), new Cell()}; Note that when only the size is specified, the array will be filled with the type’s default value, which is: false for boolean u0000 for char 0 or 0.0 for numeric types (byte, short, int, long) null for reference types An array of primitives will actually contain the primitive values. An array of primitives An array of objects will hold the references to the objects, not the objects themselves an array of objects 9.2 Printing If you want to print an entire array, use the method Arrays.toString(): System.out.println(&quot;bytes = &quot; + Arrays.toString(bytes)); 9.3 Accessing To get to an element of an array, you use an index. Java array indexing starts at zero. Array indexing int[] numbers = new int[7]; numbers[0] = 42; numbers[4] = 22; Array indexing Arrays are often created and accessed using a for loop: Cell[] cells = new Cell[number]; for(int i = 0; i &lt; number; i++) { cells[i] = new Cell(); } Or, if you like, the new post-Java-8 way: int size = 10; Cell[] cells = new Cell[size]; IntStream.range(0, size) .forEach(n -&gt; cells[n] = new Cell()); System.out.println(&quot;cells = &quot; + Arrays.toString(cells)); 9.4 Multidimensional arrays Multidimensional arrays have their use. Usually with numeric settings. You can up the number of dimensions way into the hypothetical realm. Here is an example of a two-dimensional one: final int sideLength = 5; //creates 5*5 array int[][] scoreBoard = new int[sideLength][sideLength]; for (int i = 0; i &lt; sideLength ; i++) { for (int j = 0; j &lt; sideLength; j++) { scoreBoard[i][j] = i*j; } } for (int i = 0; i &lt; sideLength ; i++) { System.out.println(Arrays.toString(scoreBoard[i])); } will output: [0, 0, 0, 0, 0] [0, 1, 2, 3, 4] [0, 2, 4, 6, 8] [0, 3, 6, 9, 12] [0, 4, 8, 12, 16] "],["operators.html", "Chapter 10 Operators 10.1 Overview", " Chapter 10 Operators Operators are the syntax elements that bind, change and combine the data, classes and methods. Although they are extremely important, they are not very interesting in the sense that they are just what they are, almost the same in any programming language. Therefore, this post is quite small. It starts with an overview of all operators and ends with a more detailed description of the less obvious ones. 10.1 Overview Operators can be assigning (=), modifying, as in count++ and they can be comparing, as in count &lt; maximum. Another way to classify them is to look at the number of operands they work on. They can have one (unary - count++;), two (binary - count &lt; maximum) or three (**_ternairy-** - (age &gt; 65 ? old=true : old=false);) operands. Operators can be ordered by their precedence, which is the priority (order) in which they will be evaluated. int x = 41; int count = 1; int y = x + ++count; System.out.println(&quot;count=&quot; + count + &quot;; y=&quot; + y); This snippet will output “count=2; y=43” because the pre-increment operator has precedence over “+”, and the assignment operator. Here is the complete listing. The associativity (Left-to-Right or Right-to-Left) of an operator is a property that determines how operators of the same precedence are grouped in the absence of parentheses. Operator precedence In general, use the rule: “When in doubt about precedence, always use parentheses”. They always have the highest precedence, and improve readability a lot. Compare these with respect to readability: x = y + z * 2 / Math.PI; x = y + ((z * 2) / Math.PI); Assignment operators Not all languages have such an extended set of assignment operators. When you want to change the value of a variable, you can use these shorthand assignment operators x = x + 2; is the same as x += 2; x = x + y; is the same as x += y; x = x * 3; is the same as x *= 3; x = x / 3; is the same as x /= 3; x = x % 3; is the same as x %= 3; The last three are a bit esoteric in my opinion and I do not use them because they lower the readability of the code (especially %=). Modulo: % The modulo operator is also called the remainder operator; it gives the remainder of a division. 10 % 3 -&gt; 1 (one) 8 % 5 -&gt; 3 This operator is often used when even/uneven items need to be identified, or other periodic cases: this will address every hundredth item: if (x % 100 == 0) { /*deal with every hundredth item } Ternary operator The ternary operator is actually a condensed if..else block but can give more comprehensive code. if (age &lt; 18) { minor = true; } else { minor = false; } //same as minor = (age &lt; 18 ? true : false); It is often used for processing String tags, such as this one. String name = &quot;John Doe&quot;; name += (academicTitle == null ? &quot;, &quot; + academicTitle : &quot;&quot;); instanceof The instanceof operator (keyword) is a boolean operator that will yield true of the left operand is the type of the right operand, or a subtype of it. Defining inheritance (subtypes) is done using the extends keyword. Here is an example. Dog dog = new Dog(); Wolf wolf = new Wolf(); Chihuahua chihuahua = new Chihuahua(); System.out.println(&quot;dog instanceof Animal = &quot; + (dog instanceof Animal)); System.out.println(&quot;dog instanceof Object = &quot; + (dog instanceof Object)); System.out.println(&quot;chihuahua instanceof Dog = &quot; + (chihuahua instanceof Dog)); System.out.println(&quot;chihuahua instanceof Animal = &quot; + (chihuahua instanceof Animal)); System.out.println(&quot;chihuahua instanceof Chihuahua = &quot; + (chihuahua instanceof Chihuahua)); outputs dog instanceof Animal = true dog instanceof Object = true chihuahua instanceof Dog = true chihuahua instanceof Animal = true chihuahua instanceof Chihuahua = true bitwise operators Java also has some bitwise operators that are not described within this course. "],["flow-control.html", "Chapter 11 Flow control 11.1 if [else if] [else] 11.2 while 11.3 for 11.4 break and continue 11.5 switch/case", " Chapter 11 Flow control This is a straightforward listing of the Java flow control structures. 11.1 if [else if] [else] If/else is the basic decision-making mechanism in every programming language. In Java, both “else if” and “else” are optional. if (condition) {} [else if (condition) {}]* [else {}]? So, the “if” block is the required basis, “else if” can be used zero to many times - but only directly following the “if”, and the entire statement is closed by an optional “else”. So this is not legal: if (foo) { } else { } else if (bar) { } and neither is this, because the int number = 2; interrupts the if/else block: if (foo) { } int number = 2; else { } 11.2 while While has two variants: while (condition) { } do { } while (condition); The difference is that do{}while() is guaranteed to be executed at least once, whereas while(condition) {} can be skipped entirely if “condition” is false at the first evaluation. 11.3 for Iterates over a collection or a defined series of steps: for (init; condition; change) { } “init” is the loop initialization; declaring a counter usually. “condition” is the test that determines whether the loop should run once more “change” is the iteration change; usually an increment of the init. This is a typical for-loop: String[] nucleotides = {&quot;Adenine&quot;, &quot;Cytosine&quot;, &quot;Guanine&quot;, &quot;Thymine&quot;}; for( int i = 0; i &lt; nucleotides.length; i++) { System.out.println(&quot;nucleotide &quot; + i + &quot; is &quot; + nucleotides[i]); } All three elements are optional. This, for instance, is a legal for-loop: String[] nucleotides = {&quot;Adenine&quot;, &quot;Cytosine&quot;, &quot;Guanine&quot;, &quot;Thymine&quot;}; int i = nucleotides.length - 1; for( ; i &gt;= 0; --i) { System.out.println(&quot;nucleotide &quot; + i + &quot; is &quot; + nucleotides[i]); } Note that the change does not need to be an increment. Even this one is legal: for(;;) { System.out.println(&quot;Hello &quot;); } //same as while(true) { System.out.println(&quot;Hello&quot;); } But it will run into eternity (or until ctrl + c has been typed). Actually, variations of the second form are quite often used to wait for user input in a terminal setting: while(true) { int answer = getUserInput(); if (answer == 42) break; } foreach The for-loop also has a variant. It is called the foreach loop. The difference is that there is no increment or condition; it is simply used to iterate a collection (Arrays or Collection types dealt with later). for (element : collection) { } And this is a working example: String[] nucleotides = {&quot;Guanine&quot;, &quot;Adenine&quot;, &quot;Cytosine&quot;, &quot;Thymine&quot;}; for( String nucleotide : nucleotides) { System.out.println(&quot;nucleotide = &quot; + nucleotide); } 11.4 break and continue All iteration structures (the while while variants and both for variants) have the possibility to leave the current iteration early, or the loop entirely. break - leave the loop (or the switch block) continue - abort current iteration and go to next iteration 11.5 switch/case The switch/case structure is a decision flow control structure that is always replaceable by if/else. However, switch/case is often more efficient, and better suited to deal with choosing between different discrete options. Where if/else works with boolean conditions, switch/case works with discrete cases. The formal description is switch (actual case) { [case case n: {case specific statement(s)}]* [default: {default statement(s)}]? } So there are one to many possible case-specific actions and zero or one default actions. Here is an example method using a switch/case: void switchCase(String country) { switch (country) { case &quot;Netherlands&quot;: System.out.println(&quot;Some weather, huh?&quot;); break; case &quot;Belgium&quot;: System.out.println(&quot;It is Belgian fries!&quot;); break; default: System.out.println(&quot;Have a beer?&quot;); } } and when this is run like this FlowControlDemo demo = new FlowControlDemo(); demo.switchCase(&quot;Netherlands&quot;); we get this output Some weather, huh? and when called with an unknown country the default will be printed. Note the break keyword in each case. The break is a very important aspect of the switch block. A switch block is fall-through unless a break is encountered. So if the breaks are removed from the switch void switchCase(String country) { switch (country) { case &quot;Netherlands&quot;: System.out.println(&quot;Some weather, huh?&quot;); //break; case &quot;Belgium&quot;: System.out.println(&quot;It is Belgian fries!&quot;); //break; default: System.out.println(&quot;Have a beer?&quot;); } } we get this output Some weather, huh? It is Belgian fries! Have a beer? Although this seems rather illogical, there are uses for this behavior. For example, consider this error handler for a web application: String errorMessage(int errorCode) { String message; switch (errorCode) { case 401: case 402: case 403: case 405: message = &quot;You are trying to do something that is not allowed&quot;; break; case 404: case 503: message = &quot;Resource not found&quot;; break; default: message = &quot;Some exotic error occurred. Try again later&quot;; } return message; } When called like this void errorMessageTest() { FlowControlDemo demo = new FlowControlDemo(); String errorMessage = demo.errorMessage(402); System.out.println(errorMessage); errorMessage = demo.errorMessage(502); System.out.println(errorMessage); } We get these messages: You are trying to do something that is not allowed Some exotic error occurred. Try again later "],["methods-1.html", "Chapter 12 Methods 12.1 Method signature 12.2 Interacting with state 12.3 Method overloading", " Chapter 12 Methods This post constitutes the link between basic syntax and design. Variables, operators and flow control form the basis of your algorithms. These algorithms have to be organized and combined into bigger systems, and building systems is done using classes and their methods. Methods are pieces of code that are used as a “black box”: you don’t need to know how they work, as long as you know (and trust) what goes in and what comes out. In Java, there exists quite a variety of method-like structures: instance methods class methods constructors class initializers object initializers This post only deals with the first two: class and instance methods. Methods define the behavior of an object or a class, modified by its state. Methods can unseen serve the inner workings of an object, or be available to the outside world: this is something you decide upon, and which is an extremely important design aspect! 12.1 Method signature Every method has a signature. In Java, this is a binding contract. The signature defines what can go in, what comes out, and what the method scope or visibility is. So, the signature is the description of the method contract to the outside world: everything but its implementation (the method body). Here, the method signature is shown in red and the method body in blue. public int addInts(int x, int y) { int result = x + y; return result; } Zooming in on the signature, these are the signature elements: access_modifier scope return_type methodName(parameter(s)) { } access modifier: public or private? The access modifier defines the visibility of your method. There are four levels of visibility, but we’ll start out with only two: public - accessible anywhere in the class path: all other code can “see” and access the method. private - accessible only within the same class We’ll come back to access modifiers later (see access modfiers), when discussing class design. This is because access modifiers can be applied not only to methods, but to classes and instance variables as well. The general rule is this: Make a method public when it is part of your class API and make it private when it only serves the inner workings of your class Scope: static vs instance methods Some methods live outside object scope and are only available as class methods: these can be recognized by the static keyword. Static methods can be called on a class and on an instance. Instance methods can only be called on an instance, usually because they are dependent on instance variable(s). You have of course seen a static method several times: public static void main(String[] args){} Here are two methods that do the same, but are be used in different contexts. Consider this class: public class StaticVsInstance { /** * static / class method */ static int addIntsStatic(int x, int y) { return x + y; } /** * instance method */ int addIntsInstance(int x, int y) { return x + y; } } The only difference lies in the static keyword. These are the different ways these methods can (not) be called: //only static can be called on the class StaticVsInstance.addIntsStatic(2, 5); //WILL NOT COMPILE: can not be called on a class //StaticVsInstance.addIntsInstance(3, 4); StaticVsInstance statInst = new StaticVsInstance(); //BOTH can be called on an instance statInst.addIntsStatic(5, 6); statInst.addIntsInstance(3, 7); Return type The return type defines what a method can (and must) return. This can be any Java type; primitive or reference type. There is a special case when the method does not return anything: this is the void return type: public void printWelcome (String name) { System.out.println(&quot;Hello, &quot; + name + &quot;, we hope you enjoy our app.&quot;); } Returning multiple values? Forget it! There is NO way you can return multiple values from a method. Unless…you put these values in a composite form. The following shows a legal but not very nice solution. Note the use of the varargs method parameter that enables you to let a method be called with a variable number of arguments of the same type. /** * Calculates the sum and average of a series of numbers and * returns this as an array with the sum at index 0 and the average at index 1 * @param numbers * @return statistics */ static double[] doStatistics(int... numbers){ //VARARGS! int sum = 0; for (int n : numbers) sum += n; double average = (double)sum/numbers.length; double[] result = {(double)sum, average}; return result; } //usage System.out.println(&quot;doStatistics(1, 2, 3) = &quot; + Arrays.toString(doStatistics(1, 2, 3))); System.out.println(&quot;doStatistics(1, 2, 3, 4) = &quot; + Arrays.toString(doStatistics(1, 2, 3, 4))); //outputs //doStatistics(1, 2, 3) = [6.0, 2.0] //doStatistics(1, 2, 3, 4) = [10.0, 2.5] Why is this not nice? You coerce an int into a double where this is not appropriate. Besides this, you need extensive comments (documentation) to explain what is going on. THINK OBJECTS! //a simple data class static class Statistics{ int sum; double average; //makes printing objects a breeze! @Override public String toString() { return &quot;Statistics{sum=&quot; + sum + &quot;, average=&quot; + average + &#39;}&#39;; } } /** * the refactored method * Calculates the sum and average of a series of numbers and * returns this as an stats object * @param numbers * @return statistics */ static Statistics doStatistics(int... numbers){ int sum = 0; for (int n : numbers) sum += n; double average = (double)sum/numbers.length; Statistics statistics = new Statistics(); statistics.sum = sum; statistics.average = average; return statistics; } //usage System.out.println(&quot;doStatistics(1,2,5,6) = &quot; + doStatisticsTheGoodWay(1, 2, 5, 6)); //outputs //doStatistics(1,2,5,6) = Statistics{sum=14, average=3.5} The toString() method is similar to the Python __str__() method. It will be discussed in detail later. Method name The name can be any compilable Java identifier, but as stated earlier it is good practice to have method names be a noun, in camelcase starting with a lowercase letter be as descriptive as possible Parameters (versus arguments) The method parameters are the number and type of variables that go in. Again, these can be of any valid Java type. Java is pass-by-value. This means: pass-by-copy. Passing a reference means: pass a copy of the reference. This reference copy will point to the same object as the original reference. This is sometimes confusing for beginners: class MyDataClass { int x = 42; } void workWithClass(MyDataClass myDataClass) { myDataClass.x++; } //usage MyDataClass myDataClass = new MyDataClass(); System.out.println(&quot;myDataClass.x = &quot; + myDataClass.x); workWithClass(myDataClass); System.out.println(&quot;myDataClass.x = &quot; + myDataClass.x); //outputs //myDataClass.x = 42 //myDataClass.x = 43 On the difference between parameters and arguments A parameter is the variable which is part of the method’s signature (method declaration) An argument is an expression used when calling the method. Cheating the contract This is not possible: the compiler won’t let you get away with it. Here are some examples showing what is legal and what isn’t. public class MyMathTools{ /*test the math function*/ public static void main(String[] args){ MyMathTools mt = new MyMathTools(); //WON&#39;T COMPILE: argument too little mt.addInts(3); //WON&#39;T COMPILE: argument too many mt.addInts(1, 2, 3); //WON&#39;T COMPILE: argument of wrong type mt.addInts(2, &quot;foo&quot;); //WON&#39;T COMPILE: double to int is loss-of-precision (unsafe) mt.addInts(1.66, 2.33); //WILL COMPILE; explicit cast (will return 1 + 2) mt.addInts((int)1.66, (int)2.33); //WILL COMPILE; int can be implicitly converted to double addDoubles(2, 4) } public int addInts(int x, int y) { return (x + y); } public double addDoubles(double x, double y) { return (x + y); } public int addIntsWrong(int x, int y){ x + y; //WON&#39;T COMPILE: should return an int return; } } 12.2 Interacting with state The essence of Object-oriented programming is that methods often interact with an object’s state: they display behavior that is dependent on the value of the objects’ instance variables. Here is a simple class that uses its state to modify method behavior. class PowerUpper { int power = 2; int powerUp(int x) { return (int)Math.pow(x, power); } } //calling code PowerUpper powerUpper = new PowerUpper(); System.out.println(&quot;4 ^ 2 = &quot; + powerUpper.powerUp(4)); powerUpper.power = 3; System.out.println(&quot;4 ^ 3 = &quot; + powerUpper.powerUp(4)); outputs: 4 ^ 2 = 16 4 ^ 3 = 64 12.3 Method overloading Java does not know about default parameter values. Fortunately, it can be implemented using a more flexible mechanism called method overloading. Method overloading is the implementation of multiple methods with the same name and return type, but with different (numbers of) arguments. It is a bit of a hassle, but more versatile at the same time, since this not only supports default values but also extra pieces of algorithm code on top of default behavior. Here is an adjusted version of the PowerUpper class, implementing different overloading techniques. static class PowerUpper { /** * returns x ^ 2 */ int powerUp(int x) { System.out.println(&quot;method A&quot;); return powerUp(x, 2); } /** * returns x ^ power */ int powerUp(int x, int power) { System.out.println(&quot;method B&quot;); //THIS WILL CAUSE A STACK OVERFLOW //return powerUp(x, power); //OK return powerUp((double)x, (double)power); } /** * returns x ^ power from two doubles, but converts the result to int */ int powerUp(double x, double power) { System.out.println(&quot;method C&quot;); return (int)Math.pow(x, power); } //this is not an overload! a different return type double powerUp(int x, double power) { System.out.println(&quot;method D&quot;); return Math.pow(x, power); } //WON&#39;T COMPILE! is not an overload, but a redefenition of &quot;int powerUp(double x, double power)&quot; //double powerUp(double x, double power) { // return Math.pow(x, power); //} } //usage PowerUpper powerUpper = new PowerUpper(); System.out.println(&quot;4 ^ 2 = &quot; + powerUpper.powerUp(4)); System.out.println(&quot;4 ^ 3 = &quot; + powerUpper.powerUp(4, 3)); System.out.println(&quot;4.0 ^ 3.0 = &quot; + powerUpper.powerUp(4.0, 3.0)); System.out.println(&quot;4.7 ^ 3.9 = &quot; + powerUpper.powerUp(4.7, 3.9)); Outputs: method A method B method C 4 ^ 2 = 16 method B method C 4 ^ 3 = 64 method C 4.0 ^ 3.0 = 64 method C 4.7 ^ 3.9 = 418 "],["packages-and-imports.html", "Chapter 13 Packages and Imports 13.1 Class path 13.2 Namespaces 13.3 Packages", " Chapter 13 Packages and Imports So far, you may have stored all your class files inside a single source directory. For larger projects this will rapidly become a big unordered mess. Besides this, you will run into namespace problems: how many Sequence classes do you think are out there? How will the JVM be able to discern between them? 13.1 Class path The Classpath is a parameter in the Java Virtual Machine, and the Java compiler, that specifies the location of user-defined classes and packages. When you use a type (e.g., User, Duck, Nucleotide), the compiler and later the JVM look for classes that match the type name. The places where the search is performed are collectively known as the classpath. 13.2 Namespaces A namespace is a context in which a class name has meaning For example, many Java applications have a class called User. How can the JVM know which of these classes to use if there are more to be found on the classpath? In Java this is solved using packages. 13.3 Packages All serious Java projects have their code organized into packages. Packages are “containers” that keep related classes together and avoid name conflicts with classes with identical names. To keep packages (and thus namespaces) unique, they are usually formed by reversing the programmer/company web address: nl.bioinf is a package name prefix I often use Since there are more programmers working behind nl.bioinf, I also add my teacher abbreviation: nl.bioinf.nomi. The next level is the current project you work on, e.g. “biojava light”, resulting in nl.bioinf.nomi.bjl. Finally, all sequence-related classes I put in package sequences. This gives a full package name nl.bioinf.nomi.bjl.sequences. This is a long name, but quite essential. Fortunately, you will hardly ever type them. Most of the core Java classes that you have worked with so far are in package java.lang. The fully qualified name for class String is actually java.lang.String. For classes in java.lang and the current package, you do not have to use the long package prefix. Have a look at https://docs.oracle.com/javase/10/docs/api/java.base-summary.html, find package java.lang and you will see all the familiar classes Double, String, Math, Character etc. Packages are represented in the directory structure of your source folder (src/main/java in Gradle managed projects). When you have a package nl.bioinf.sequences and this package contains a source file Sequence.java containg top-level class Sequence, you will have to place the class file of Sequence at: .../nl/bioinf/sequences/Sequence.class. The IDE will takes care of these matters for you. When you use types that are not from java.lang or the same package (=directory) your current class is in, you will have to refer to them using a fully qualified name, or import them. Let’s look at an example package nl.bioinf.nomi.sequences; public class Sequence{ //class code } Class Sequence is declared to be included in package nl.bioinf.nomi.sequences. Package declarations are placed on the first line of the source file, outside the class body. The actual folder/file structure inside your source folder will be like this: Package structure If you don’t use import statements, you will have to refer to classes using their fully qualified name, like this: package nl.bioinf.nomi.sequences; public class Sequence{ void somemethod(){ nl.bioinf.nomi.io.SequenceReader sr = new nl.bioinf.nomi.io.SequenceReader(); } //more class code } With import statements, this becomes much more readable: package nl.bioinf.nomi.sequences; import nl.bioinf.nomi.io.SequenceReader; public class Sequence{ void somemethod(){ SequenceReader sr = new SequenceReader(); } //more class code } Import statements are placed under the package declaration, also outside the class body. Because of the import statement, the short class name SequenceReader can now be used inside this class "],["the-power-of-naming.html", "Chapter 14 The power of naming", " Chapter 14 The power of naming As a lecturer I am often confronted with code that does the job it was written and intended for, but still makes me want crawl in a corner and weep. This often has to do with either one of these two aspects: Coding style Naming The first, coding style, has to do with how you organize/layout your code, preferably in accordance with the conventions of your programming language. The second aspect is how you name your variables, methods, classes and packages (and projects). These two actually overlap to quite some extend, since coding style also has some things to say about naming. Let’s have a look at some sample code that could have come straight from my classroom: package my_tool; public class main { public static void main(final String[] a) { int Arg = Integer.parseInt(a[1]); double opt=Double.parseDouble(a[2]); parse p = new parse_impl(); Data d= p.reading(args[0]); Calculate c = new Calculate(); c.Making(d,Arg, opt); } } Take a minute and figure out what this code might do (I assure you it compiles and executes correctly). Take another minute to figure out how many things are wrong with this code. Hint: It is a lot. This code is almost as cryptic as those nice little minified Javascript libraries. You know, when you refactor code to have no comments, no whitespace except where absolutely necessary, and have variables of 1 or 2 characters long. Below is the same Java code minified: package my_tool;public final class M{public static void m(final String[]a) {int r=Integer.parseInt(a[1]);double o=Double.parseDouble(a[2];P p=new pi();D d=p.r(args[0]);C c=new C();c.m(d,r,o);}} Although this is really unintelligible, the first code fragment does not do a much better job at informing you. And that is exactly what good naming practice brings you: information. It informs you about What the classes are about (what they model) What contract interfaces define What the methods will likely be doing, and what the role of their arguments will have What the purpose is of variables What kind of entities everything refers to (classes, methods, variables) Whenever you write code that should have meaning to others, or to yourself a few months from now, use the above list as a mental review on your code. So, what actually is wrong with the first code snippet? The coding style violations are a pain to my eyes, so let’s get these out of the way first. Classes should start with an uppercase letter, be in camel case and be nouns, while methods should start with a lowercase letter, be verbs and also be in camel case. When you are into a programming language as much as I am into Java, you get really, really REALLY confused whenever a class name starts with a lowercase letter! I’ll clean that up a little bit (and insert some much needed whitespace as well): package my_tool; public final class Main { public static void main(final String[] args) { int arg = Integer.parseInt(args[1]); double opt = Double.parseDouble(args[2]); Parser p = new ParserImpl(); Data d = p.read(args[0]); Calculator c = new Calculator(); c.make(d, arg, opt); } } None of the names give any clue about what the entities they refer to might be doing, except on the most generic level. Yes, “arg” is an argument and yes, ParseImpl is an implementation of the interface Parser, but this tool may equally likely deal with interstellar dust readings as with intracranial ultrasound measurements. Especially with the style abuse and the absence of comments, there is no way you can tell. So let’s continue with making this code a bit more revealing of its purpose. package nl.michielnoback.sequence_analysis; public final class ConservationAnalyserApp { public static void main(final String[] args) { int maximumIntraGroupDistance = Integer.parseInt(args[1]); double sequenceRejectThreshold = Double.parseDouble(args[2]); SequenceFileParser sequenceParser = new FastaSequenceFileParser(); SequenceCollection sequenceCollection = sequenceParser.readSequenceFile(args[0]); DnaConservationAnalyzer sequenceConservationAnalyzer = new DnaConservationAnalyzer(); sequenceConservationAnalyzer.makeConservationPattern( sequenceCollection, maximumIntraGroupDistance, sequenceRejectThreshold); } } Now I know what you do! You analyze sequences (in this case, apparently DNA sequences) and determine conservation in some way! Apparently, there are also some parameters that will be applied to sequence groups and on sequences individually. You might be skeptical about the long class and -especially- variable names, but who in their right mind does not use an advanced IDE with code completion nowadays? I rarely type more than three or four letters before using autocomplete. Also note the correct use of package name and structure here. By the way, since DNA is an acronym, should it be DnaConservationAnalyzer or DNAconservationAnalyzer? There is no general rule for this but I suggest you stick with DnaConservationAnalyzer. Are we finished? No! There is no comment at all. Your public API should be commented very well, and code that is not entirely self-explanatory (in this case: none). package nl.michielnoback.sequence_analysis; /** * Conservation analyzer app will determine the level of conservation between a provided set of sequences. * This is the main class of the application. * @author Michiel Noback [*********@gmail.com] * @version 0.0.1 */ public final class ConservationAnalyserApp { /** * Primary entry point of the application. * It expects these command-line arguments to be provided: * args[0] the sequence file, Fasta formatted * args[1] the maximum intra group distance (an integer between 0 and 100) * args[2] the sequence reject threshold (a double between 0 and 1) * @param args the command line arguments */ public static void main(final String[] args) { String sequenceFile = args[0]; int maximumIntraGroupDistance = Integer.parseInt(args[1]); double sequenceRejectThreshold = Double.parseDouble(args[2]); SequenceFileParser sequenceParser = new FastaSequenceFileParser(); SequenceCollection sequenceCollection = sequenceParser.readSequenceFile(sequenceFile); DnaConservationAnalyzer sequenceConservationAnalyzer = new DnaConservationAnalyzer(); sequenceConservationAnalyzer.makeConservationPattern( sequenceCollection, maximumIntraGroupDistance, sequenceRejectThreshold); } } You must agree, take a look at this code any time in the future and you immediately know what is going on and who is doing what. "],["interfaces.html", "Chapter 15 Interfaces 15.1 A contract without implementation: interface 15.2 Summary", " Chapter 15 Interfaces So far, you have seen two basic types: primitives and classes. Classes have instance variables and methods acting on these. Here is an example. public class Sequence { String sequence; String name; /** * returns the molecular weight, in Daltons * @return weightInDaltons */ double getMolecularWeight() { double weight = 0; //implementation to calculate weight return weight; } /** * Mutates a single position and returns a modified copy. * This object itself is NOT mutated! * @param position * @param newCharacter * @return mutatedSequence */ Sequence mutate(int position, char newCharacter) { StringBuilder stringBuilder = new StringBuilder(this.sequence); stringBuilder.setCharAt(position, newCharacter); Sequence mutatedSequence = new Sequence(); mutatedSequence.sequence = stringBuilder.toString(); return mutatedSequence; } } So the contract (or API, if you like) of class Sequence is that it can deliver its molecular weight and can generate a mutated copy of itself. Both are concrete methods that are implemented with a method body. Sometimes, however, you want to separate the contract from its implementation. 15.1 A contract without implementation: interface Maybe you remember from Python the print() method. It has this signature print(*objects, sep=' ', end='\\n', file=sys.stdout, flush=False). By default it writes to the console, sys.stdout, but you can change this behavior as long as you pass an object with a write() method: print(\"foo\", file=object_with_a_write_method). Translating this to Java, which is strongly typed, the print() method would expect an object of a certain type, or contract, exposing a write() method. But since there are so many different ways to write() data (to console, to database, to socket), it would be impossible to create a single implementation that supports all possible ways to write data, now and in the future. The solution is to define a contract without implementation, separating the contract from the implementation. Classes interested in fulfilling the contract can sign up and define their own implementation, as long as the contract is followed to the letter. In Java, these contracts are called interfaces. Staying with the Python print() function, we would have to define a contract (interface) defining a “write” method that states “give me your object and I will write it (to a destination of my choice)”: Why is this useful? Let’s move away from simple printing a bit. Suppose we have a SequenceCollection class that exposes a flush() method, that is supposed to write the held collection to an external location for storage and clear memory to be ready for filling: A typical case of batch processing. But the SequenceCollection class does not know which storage technology is preferred by its clients (API programmers), so it only asks API programmers to provide it with an object implementing the SequenceWriter contract. First, here is the SequenceWriter interface. package snippets.apis; public interface SequenceWriter { /** * This is the sole method defined in this interface. It accepts an * object and will store a representation of it to an external destination. * @param sequence the sequence to store */ void store(Sequence sequence); //NO METHOD BODY; ONLY A SIGNATURE! } The store() method does not have a method body - it only serves as a contract. Here is the SequenceCollection class the “talks to” only the contract - it has no clue what kind of implementation it receives. package snippets.apis; import java.util.ArrayList; import java.util.List; public class SequenceCollection{ private List&lt;Sequence&gt; sequences = new ArrayList&lt;&gt;(); public void addSequence(Sequence sequence) { this.sequences.add(sequence); } public void removeSequence(Sequence sequence) { this.sequences.remove(sequence); } /** * This will write the current SequenceCollection to an external destination * and empty the collection to be filled with a next batch. * @param writer the writer that processes each individual sequence object */ public void flush(SequenceWriter writer) { for (Sequence seq : this.sequences) { //NO CLUE OF THE ACTUAL STORAGE IMPLEMENTATION //ONLY KNOWS THERE IS AN OBJECT LIVING UP TO TO THE CONTRACT writer.store(seq); } this.sequences.clear(); } /** * Looks for pathogenic sequences in the current batch * @return pathogenicSequences */ public List&lt;Sequence&gt; findPathogenicSequences() { ArrayList&lt;Sequence&gt; pathogenics = new ArrayList&lt;&gt;(); //complex logic return pathogenics; } //MORE LOGIC INVOLVING THIS SEQUENCE COLLECTION } So now, if we want to use this SequenceCollection class, we need to provide it with an implementer of the contract. Here are two. When you create a class in IntelliJ, and type implements SequenceWriter, you get a compile error, saying “Class X must either …. or implement method Y”: Implement interface context menu Place the cursor on the line with the class name, press alt + Enter and select “Implement methods”. Select store() and press Enter. Boilerplate code has been generated. This implementation simply lets the sequence get garbage collected. package snippets.apis; public class NoStorageSequenceWriter implements SequenceWriter { @Override public void store(Sequence sequence) { System.out.println(&quot;not interested in sequence &quot; + sequence.name + &quot; anymore&quot;); } } This implementation stores the sequence as Fasta to file (we’ll deal with file IO later so don’t be scared by that bit). package snippets.apis; import java.io.BufferedWriter; import java.io.IOException; import java.nio.charset.Charset; import java.nio.file.Files; import java.nio.file.Path; import java.nio.file.Paths; public class FileStorageSequenceWriter implements SequenceWriter { @Override public void store(Sequence sequence) { Path file = Paths.get(&quot;/Users/michiel/Desktop/finished_sequences.fa&quot;); try { if (! Files.exists(file)) { Files.createFile(file); } String fasta = &quot;&gt;&quot; + sequence.name + System.lineSeparator() + sequence.sequence + System.lineSeparator(); Files.write( file, fasta.getBytes(), StandardOpenOption.APPEND); } catch (IOException e) { e.printStackTrace(); } } } And here is the Sequencer class showing the usage of two SequenceWriter implementations: package snippets.apis; public class Sequencer { public static void main(String[] args) { Sequencer sequencer = new Sequencer(); sequencer.start(); } private void start() { SequenceCollection sequenceCollection = new SequenceCollection(); Sequence seq; seq = new Sequence(); seq.name = &quot;harmless&quot;; seq.sequence = &quot;GATAACAGCATAGCAAG&quot;; sequenceCollection.addSequence(seq); seq = new Sequence(); seq.name = &quot;probably harmless&quot;; seq.sequence = &quot;GATCAGCAACTCAGCACTACGGCT&quot;; sequenceCollection.addSequence(seq); seq = new Sequence(); seq.name = &quot;really deadly&quot;; seq.sequence = &quot;GACACGCGCGCTACAGCACT&quot;; sequenceCollection.addSequence(seq); sequenceCollection.findPathogenicSequences(); sequenceCollection.flush(new NoStorageSequenceWriter()); // sequenceCollection.flush(new FileStorageSequenceWriter()); } } outputs not interested in sequence harmless anymore not interested in sequence probably harmless anymore not interested in sequence really deadly anymore while this // sequenceCollection.flush(new NoStorageSequenceWriter()); sequenceCollection.flush(new FileStorageSequenceWriter()); creates a file on my Desktop with this contents: File cretaed 15.2 Summary Interfaces make it possible to define a contract or API in a way that makes it possible to deal with an object as being of the contract type, without knowing its implementation, and without using inheritance. "],["the-java-collections-api.html", "Chapter 16 The Java Collections API 16.1 Lists: ArrayList and LinkedList 16.2 Code against interfaces, not implementations 16.3 The collection interfaces: Map, List, Set 16.4 Collections utility methods", " Chapter 16 The Java Collections API Storing variables collectively is nice; doing so in Arrays is usually not so nice - simply because they are static and cannot be extended or shortened or inserted within. The Java Collections API offers a wealth of other ways to store data, in the form of Lists, Queues, Sets, Maps, in variations and hybrids of these. Finally (not a collection but essential to show you), we will see a nice way to deal with changeable String data: class StringBuilder. The old way In a previous lecture, you have seen the most basic collection type: array. Arrays store a fixed number of variables. But suppose you want to do something like this: Sequence[] readSequences(String fileName) { //open file //read sequences //return the sequences as an array of Sequence objects } There is a problem here: You usually don’t know how many sequences there are in a file! So, the simple solution is to create a very large array that is as large as the biggest sequence file you know: String[] readSequences(String fileName) { String[] sequences = new String[10_000_000]; //open file //read sequences //return the sequences as an arrays of Strings } When you read only 1 or 2 sequences you will have wasted all this memory space! Moreover, all these null values are NullPointerExceptions in the waiting. Unused space When somebody invents a new sequencing machine that generates 100 million sequences in one run, you have a bigger problem! You will get ArrayIndexOutOfRangeExceptions or other errors. Actually, these machines already exist! There is a nice class that will really make your day: java.util.ArrayList. 16.1 Lists: ArrayList and LinkedList ArrayList is the workhorse for most collections where you want to store a number of variables in an ordered way. It is, as the name suggests, an Array-like List. The big -no huge- difference is that is will grow and shrink according to your needs. So, the previous method could be refactored as follows: import java.util.ArrayList; ArrayList&lt;String&gt; readSequences(String fileName) { //no initial size needed (although you can give one, //if you are really into efficiency) ArrayList&lt;String&gt; sequences = new ArrayList&lt;&gt;(); //open file //read sequences //return the sequences as an arrays of Strings } At the top is a line import java.util.ArrayList; which is an import declaration, You need to import classes that are not part of the Java core API (i.e. reside in package java.lang). Since most of the collection classes are in package java.util they need to be imported. More on imports and namespaces later. There is another element here that you haven’t seen before: it is the generic type declaration: ArrayList&lt;String&gt; sequences = new ArrayList&lt;&gt;(); 16.1.1 Generics The &lt;String&gt; and &lt;&gt; have everything to do with Java being strongly typed. Since everything is typed, a collection that is being instantiated must also know what type it will contain. You specify the type of its elements using the diamond operators. This mechanism is called generics in Java, because it makes collection classes generic usable. Before Java 8, you had to do it twice (ArrayList&lt;String&gt; sequences = new ArrayList&lt;String&gt;();) but in newer versions of Java you can leave the second set of diamond operators empty. Leaving the type declaration out does not yield a compiler error, but makes your life so much harder: //typed collection ArrayList&lt;String&gt; words = new ArrayList&lt;&gt;(); words.add(&quot;Game&quot;); words.add(&quot;of&quot;); words.add(&quot;Thrones&quot;); //type is inferred from collection for (int i = 0; i &lt; words.size(); i++){ String word = words.get(i); System.out.println(&quot;word = &quot; + i + &quot;: &quot; + word); } //&quot;raw&quot; type collection: everything is Object ArrayList wordsNonGeneric = new ArrayList(); wordsNonGeneric.add(&quot;House&quot;); wordsNonGeneric.add(&quot;of&quot;); wordsNonGeneric.add(&quot;Cards&quot;); //danger! wordsNonGeneric.add(new Duck()); //iterate over Object type for (int i = 0; i &lt; wordsNonGeneric.size(); i++){ //need to cast to actual type //this will give a ClassCastException exception on the Duck, which is of course not a String! String word = (String)wordsNonGeneric.get(i); System.out.println(&quot;word = &quot; + i + &quot;: &quot; + word); } So, without the type declaration, you need to cast to the actual type. That makes your code less obvious. But more problematic is that any object can be inserted into the collection, without warning. So, when you attempt to cast a Duck to a String, you get a ClassCastException. You can circumvent this problem by checking the type (using the instanceof operator): for (int i = 0; i &lt; wordsNonGeneric.size(); i++){ Object element = wordsNonGeneric.get(i); if (element instanceof String) { String word = (String) element; System.out.println(&quot;word = &quot; + i + &quot;: &quot; + word); } else { System.out.println(&quot;skipped non-String element of type &quot; + element.getClass().getSimpleName()); } } but why would you make your life harder than it already is? 16.1.2 ArrayList operations Lists in general, and ArrayList is no exception, are used to store in an ordered way. Operations on ArrayLists are of course related to the property. Here are some example usages. //create ArrayList&lt;String&gt; words = new ArrayList&lt;&gt;(); //add elements words.add(&quot;Game&quot;); words.add(&quot;of&quot;); words.add(&quot;Thrones&quot;); //won&#39;t compile! //words.add(new Duck()); //foreach iteration for (String word : words) { System.out.println(&quot;word = &quot; + word); } //iteration with counter; note the use of &quot;.size()&quot; for (int i = 0; i &lt; words.size(); i++) { //fetch by index - zero based! String word = words.get(i); System.out.println(&quot;word = &quot; + i + &quot;: &quot; + word); } words.contains(&quot;Thrones&quot;); //true words.size(); //3 words.isEmpty(); //false //same as boolean empty = words.size() == 0; words.remove(&quot;of&quot;); //deletes word words.remove(1); //second element words.clear(); //empty list One operation needs special attention: converting an array to a List. This is done with Arrays.asList() but be aware that this generates an immutable view of your array: String[] wordsArr = {&quot;Lord&quot;, &quot;of&quot;, &quot;the&quot;, &quot;Rings&quot;}; //create immutable List from Array List&lt;String&gt; immutableStrings = Arrays.asList(wordsArr); //immutable: UnsupportedOperationException! immutableStrings.add(&quot;!&quot;); //make mutable copy List&lt;String&gt; mutableString = new ArrayList&lt;&gt;(); //no problem mutableString.add(&quot;!&quot;); 16.2 Code against interfaces, not implementations Be aware that the contains() method performs at O(n) (see your Algorithms &amp; Data structures course!), so if you plan to check for element presence often, List types are not a good choice. Also, if you are going to do a lot of insert and/or delete operations, LinkedList is a much better choice. Fortunately, you only need to change one line of code in your application to achieve this, and if you design your code well, you only need to change a single word: //This is OK but not efficient with insert/delete //Also, the type declaration is an implementation (ArrayList) and not an //interface (List) ArrayList&lt;String&gt; words = new ArrayList&lt;&gt;(); //Better, declare the interface (abstraction) type and //use this type in the rest of your code List&lt;String&gt; words = new ArrayList&lt;&gt;(); //Best: LinkedList is very good at insertions and deletions List&lt;String&gt; words = new LinkedList&lt;&gt;(); This is an example of the rule code against interfaces (abstractions), not implementations. When you code against interfaces, i.e. declare variables of an interface type, it is really easy to change the implementation class that you use. In the example above, it took only one changes word to use a LinkedList instead of an ArrayList. 16.3 The collection interfaces: Map, List, Set There four base collection types, each with several dedicated implementations. You have already seen the List type, with two implementations: ArrayList and LinkedList. Here is a -very incomplete- listing of some collection type implementations, followed by a demonstration of only the HashMap and HashSet types - you have already seen the List type. List interface ArrayList simplest and general purpose list type LinkedList coupled elements Stack last in first out (LIFO) Map interface HashMap the Python dict equivalent TreeMap a sorted hashmap Set interface HashSet the basic Set implementation TreeSet a sorted Set Queue interface PriorityQueue priority queue when first in first out (FIFO) is not enough ArrayDeque double-ended queue 16.3.1 Map: HashMap HashMap is the main Map implementation in Java. It is a dictionary type mapping keys to values. Like all collection types, it uses generics to declare the type of the keys and values. Here is an example of an ID to User mapping: Map&lt;Integer, User&gt; users = new HashMap&lt;&gt;(); Note the use of Integer instead of int. Primitives as objects Each primitive type in the Java language has an object counterpart. The reason for this is that collection types, amongst others, can not hold primitives but only objects. These are the primitives and their wrapper classes: boolean, byte, short, char, int, long, float, double. Boolean, Byte, Short, Character, Integer, Long, Float, Double. So only Character and Integer have a different name (longer) the others are simply the primitive name capitalized. Autoboxing The wrapper classes can be converted to and from pretty easy: int count = 33; //deprecated though legal Integer counter1 = new Integer(count); //Explicit; uses caching Integer counter2 = Integer.valueOf(count); //explicit unwrapping counter2.intValue(); //autoboxing! Integer counter3 = count; //auto-unboxing int counter4 = counter3; The last two examples show the mechanism of autoboxing primitives. This means the compiler deals with wrapping and unwrapping for you. This is how you typically use primitives in collections. See use cases below. Map operations See listing below. Map&lt;Integer, User&gt; users = new HashMap&lt;&gt;(); User u1 = new User(15, &quot;Henk&quot;); //add to Map; note autoboxing of int value (id) users.put(u1.id, u1); User u2 = new User(21, &quot;Dirk&quot;); users.put(u2.id, u2); User u3 = new User(9, &quot;Mike&quot;); users.put(u3.id, u3); //read size System.out.println(users.size()); //check for presence of key System.out.println(&quot;users.containsKey(15) = &quot; + users.containsKey(15)); //check for presence of value System.out.println(&quot;users.containsValue() = &quot; + users.containsValue(u1)); //is not in map System.out.println(&quot;users.containsValue() = &quot; + users.containsValue(new User(6, &quot;Nick&quot;))); //iterate values for (User user : users.values()) { } //iterate keys for (int id : users.keySet()) { } //iterate entries for (Map.Entry&lt;Integer, User&gt; entry : users.entrySet()) { System.out.println(entry.getKey() + &quot;: &quot; + entry.getValue()); } //empties map users.clear(); 16.3.2 Set: HashSet Typical set operations are intersection, union and relative complement. Set theory operations This is how its done in Java. First a small utility method, which generically creates a Set of any type from a varargs input: private static &lt;T&gt; Set&lt;T&gt; setOf(T... values) { return new HashSet&lt;T&gt;(Arrays.asList(values)); } Here are three of the fundamental set operations. Set&lt;Integer&gt; setA = setOf(1, 2, 3, 4); Set&lt;Integer&gt; setB = setOf(2, 4, 6, 8, 9); //Intersection Set&lt;Integer&gt; intersectSet = new HashSet&lt;&gt;(setA); intersectSet.retainAll(setB); System.out.println(&quot;intersectSet = &quot; + intersectSet); //Union Set&lt;Integer&gt; unionSet = new HashSet&lt;&gt;(setA); unionSet.addAll(setB); System.out.println(&quot;unionSet = &quot; + unionSet); //Relative complement Set&lt;Integer&gt; differenceSet = new HashSet&lt;&gt;(setA); differenceSet.removeAll(setB); System.out.println(&quot;differenceSet = &quot; + differenceSet); with output intersectSet = [2, 4] unionSet = [1, 2, 3, 4, 6, 8, 9] differenceSet = [1, 3] 16.4 Collections utility methods The Collections class has many useful utility functions. Their name are pretty self-explanatory: singletonList() unmodifiableList() min(), max() shuffle() frequency() sort() - see next post "],["methods-of-class-object.html", "Chapter 17 Methods of class Object 17.1 toString(), equals(), hashCode(), getClass()", " Chapter 17 Methods of class Object 17.1 toString(), equals(), hashCode(), getClass() Previously you have seen some collection types: List, Map, Set. One of the methods that is universal to all collection types is contains(). How does the JVM determine that two objects are equal? This is through the equals() method. When you use the statement myCollection.contains(myObject), you get true returned if one of the elements in myCollection returns true for element.equals(myObject). The method equals() is there, even though you did not implement it. This is because they are declared and implemented in class Object, and every class in Java extends from Object implicitly. Whenever you create a class, such as this: class User { } you get this implicitly: class User extends Object { } Since User extends Object, it inherits all Object properties and methods. If you create an object (of any type), type the variable name followed by a dot, IntelliJ will show you the methods of class Object: Methods of class object The notify..() and wait..() methods have to do with multithreading and are not dealt with here. The ones of interest are toString() returns a String representation of the current object. Implemented in class Object as the objects’ memory hash. equals() returns a boolean indicating whether the argument is logically the same as the current object. Implemented in class Object as: true if both refer to the same object. hashCode() returns the hashCode (an int) of the current object. Implemented in class Object to return an integer representing the objects memory address. getClass() returns the class of the current object toString(): a string representation of the object If you want to see a nice textual representation of an object during software development, you use toString(). In IntelliJ, type ctrl + O if you want to override a super class method. Override methods If you choose toString(), you will get something like this: @Override public String toString() { return super.toString(); } Note the @Override annotation. Annotations are syntactic sugar in Java, and this one says to the compiler: please check whether this override is correct, else fail compilation. Correct with respect to toString() means: take no arguments and return a String. The statement return super.toString(); simply states: call the super class toString (of Object in this case) and return its result. Which means you get the uninformative: snippets.apis.User@78b1cc93 To make toString useful, you’ll need te redefine its logic, for instance: @Override public String toString() { return &quot;A user with name &quot; + name; } which outputs A user with name Henk Although this is logically correct, and will compile just fine, there are some conventions used in Java to be informative. To get a toString() which follows this rule, use another IntelliJ shortcut: ctrl + N (for generate code), and select toString(). Generate toString() Then, select the instance variables you want included in the string representation, click OK and you have something like this @Override public String toString() { return &quot;User{&quot; + &quot;id=&quot; + id + &quot;, name=&#39;&quot; + name + &#39;\\&#39;&#39; + &#39;}&#39;; } outputting User{id=15, name='Henk'}, which is a good textual representation of the underlying object. equals() determining logical similarity between objects Consider these three User objects, where the first constructor argument is the user ID and the second the username. User user1 = new User(15, &quot;Henk&quot;); //same, equal? User user2 = user1; User user3 = new User(21, &quot;Dirk&quot;); //same, or equal User as user3? User user4 = new User(21, &quot;Dirk&quot;); Is user1 equal to user2? Is user1 equal to itself, user1? Is user3 equal to user4? There is an important distinction to be made: equality versus sameness. Two references are considered the same if they both point to a single object on the heap. On the other hand, equality is a more fuzzy concept. In general, we consider two references equal if they point either to one single object, or to two distinct objects that are logically similar. So, in the above code snippet, user1 is definitely the same as user two since they refer to the same object. But since they are the same, they must therefore also be equal. On the other hand, user3 and user4 are two distinct objects (the constructor has run twice!), but logically similar because they have exactly the same internal data. In Java, == tests for sameness and equals() for logical similarity. Therefore, we would like our User class to behave like this. System.out.println(&quot;user1 == user1 -- &quot; + (user1 == user1)); //should be true System.out.println(&quot;user1.equals(user1) -- &quot; + user1.equals(user1)); //should be true System.out.println(&quot;user1 == user2 -- &quot; + (user1 == user2)); //should be true System.out.println(&quot;user1.equals(user2) -- &quot; + user1.equals(user2)); //should be true System.out.println(&quot;user1.equals(user3) -- &quot; + user1.equals(user3)); //should be false System.out.println(&quot;user3.equals(user4) -- &quot; + user3.equals(user4)); //should be true! but in actuality this is what we get user1 == user1 -- true user1.equals(user1) -- true user1 == user2 -- true user1.equals(user2) -- true user1.equals(user3) -- false user3.equals(user4) -- false Up to the last test, everything works out fine. Why does the last test return false? Because Java doesn’t not know about logical similarity between User objects! We have to tell it. Therefore, by default this is what the Object.equals() method does: @Override public boolean equals(Object other) { return (this == other); } Let’s change the equals() method to reflect (my opinion of) similarity: @Override public boolean equals(Object other) { User otherUser = (User) other; return (this.id == otherUser.id &amp;&amp; this.name == otherUser.name); } There is a lot to say about this implementation. Can you spot the flaws? There are several, so maybe it is better to let IntelliJ handle this for us, via ctrl + N (generate) -&gt; equals() and hashCode() -&gt; choose template (Java 7+), choose name and ID –&gt; next, next next, Finish: @Override public boolean equals(Object o) { if (this == o) return true; if (o == null || getClass() != o.getClass()) return false; User user = (User) o; return id == user.id &amp;&amp; Objects.equals(name, user.name); } Study this carefully! Why is each statement inserted? The equals() method must exhibit the following properties: - Symmetry: For two references, a and b, a.equals(b) if and only if b.equals(a) as well - Reflexivity: For all non-null references, a.equals(a) - Transitivity: If a.equals(b) and b.equals(c), then a.equals(c) - Consistency with hashCode(): Two equal objects must have the same hashCode() value hashCode(): required when equals() is implemented The hashCode() method is kind of the mysterious sister of equals(). You implement them together, but only equals() is easily understood. The hashCode() method is used for bucketing in Hash implementations like HashMap, HashTable, HashSet, etc. The value received from hashCode() is used as the bucket number for storing elements of the set/map. This bucket number is the address of the element inside the set/map. When you do contains() it will take the hash code of the element, then look for the bucket where hash code points to. If more than 1 element is found in the same bucket (multiple objects can have the same hash code), then it uses the equals() method to evaluate if the objects are equal, and then decide if contains() is true or false, or decide if element could be added in the set or not. (This paragraph is copied from a post on Stackoverflow) The general contract of hashCode() states: Whenever it is invoked on the same object more than once, hashCode() must consistently return the same value, provided no information used in equals comparisons on the object is modified. This value needs not remain consistent from one execution of an application to another execution of the same application If two objects are equal according to the equals(Object) method, then calling the hashCode() method on each of the two objects must produce the same value It is not required that if two objects are unequal according to the equals(java.lang.Object) method, then calling the hashCode method on each of the two objects must produce distinct integer results. However, developers should be aware that producing distinct integer results for unequal objects improves the performance of hash tables Of course, we let IntelliJ do the hard work (ctrl + N): @Override public int hashCode() { //uses a utility method from class Objects return Objects.hash(id, name); } getClass() gives meta-information the objects class Example code is best here: System.out.println(&quot;user1.getClass().getSimpleName() = &quot; + user1.getClass().getSimpleName()); System.out.println(&quot;user1.getClass().getName() = &quot; + user1.getClass().getName()); System.out.println(&quot;user1.getClass().getPackageName() = &quot; + user1.getClass().getPackageName()); outputs user1.getClass().getSimpleName() = User user1.getClass().getName() = snippets.apis.User user1.getClass().getPackageName() = snippets.apis There are a lot more methods in class java.lang.Class, but they serve difficult stuff, like introspection. "],["sorting.html", "Chapter 18 Sorting 18.1 “Natural” sorting with the Comparable interface 18.2 Sorting using a custom Comparator 18.3 Multilevel sorting", " Chapter 18 Sorting Sorting is one of the fundamental operations on data. You want the best student, the closest cafe, all players with a top 10% ranking…this all involves sorting. Sorting in “classic” Java (not using the Streams API) is done using the the Collections.sort() methods and, since Java 8, some methods in class List. These methods require either (a) that the objects you want to sort implement the Comparable interface or (b) that you provide a sorter object implementing the Comparator interface. 18.1 “Natural” sorting with the Comparable interface This is the first and main sorting strategy. Whenever the type in your collection implements the Comparable interface, it is said to have “natural ordering”. This interface is described in detail later. Java classes such as String, Integer, and Double all implement the Comparable interface. In IntelliJ you can see this when you select a String variable declaration and press F1 (or ^Q): Javadoc of class String You can see Comparable&lt;String&gt; in the implements declaration. For Strings, natural order means alphabetic order and for numbers numeric order (from low to high). Using natural ordering can be achieved in two places (since Java 8): In the Collections class and in the List interface. We’ll start with the “classic” method of Collections. Its signature is rather complex, but fortunately using it is not. public static &lt;T extends Comparable&lt;? super T&gt;&gt; void sort(List&lt;T&gt; list) This signature tells us a lot: it is static, so it can be used directly on the Collections class it has void as return type, so it sorts a list in place instead of returning a sorted copy. it takes as argument a List the elements of the list are of type T (a generic placeholder), where the constraint on type T is that it should implement the Comparable interface - more specifically: a Comparable comparing T or its supertypes. Key here is the Comparable interface (package java.util): package java.util; public interface Comparable&lt;T&gt; { int compareTo(T other); } The contract is really simple. To be comparable to other objects (of the same class), a class needs to implement the method compareTo(T other) where T is the class implementing the interface. The method signature of compareTo() states that it should receive an instance of T and return an integer indicating the sort order of the current object with respect to the other object. The convention for this return value is a negative value if this &lt; other zero if this equals that a positive value if this &gt; other Since String and other Java classes already implement this interface, you can sort them without any further work: List&lt;String&gt; names = new ArrayList&lt;&gt;(); names.addAll(List.of(&quot;Jordan&quot;, &quot;Wanda&quot;, &quot;James&quot;, &quot;rose&quot;, &quot;Aaron&quot;)); System.out.println(&quot;names before sort: &quot; + names); Collections.sort(names); System.out.println(&quot;names after natural sort: &quot; + names); This will output names before sort: [Jordan, Wanda, James, rose, Aaron] names after natural sort: [Aaron, James, Jordan, Wanda, rose] As you can see, capitals come before lower case letters. The exact same thing could have been achieved using the sort() method of class List, added in Java 8: names.sort(Comparator.naturalOrder()); System.out.println(&quot;names after sort on List &quot; + names); The signature of this sort method is: public void sort(@Nullable java.util.Comparator&lt;? super E&gt; c) It takes a Comparator instance; this interface is described in the next section. Some common default Comparators have already been implemented, for natural (Comparator.naturalOrder()) and reverse (Comparator.reverseOrder()) order for use with classes that implement Comparable. Note that the @Nullable in the above signature means that if null is passed, it defaults to Comparator.naturalOrder() An overloaded method would have been better design in my opinion, because this names.sort(null); is really ugly. Here is the reverse ordering: names.sort(Comparator.reverseOrder()); System.out.println(&quot;names after reverse sort &quot; + names); outputs names after reverse sort [rose, Wanda, Jordan, James, Aaron] Another interesting Comparator is the CASE_INSENSITIVE_ORDER comparator defined in the String class: names.sort(String.CASE_INSENSITIVE_ORDER); System.out.println(&quot;names case insensitive sort &quot; + names); outputs names case insensitive sort [Aaron, James, Jordan, rose, Wanda] Custom comparable implementations Let’s create our own implementation of the Comparable interface in a custom class and demonstrate its use. Here is a simple Bird class. package snippets.apis; public class Bird { String englishName; double wingSpan; int maximumAge; public Bird(String englishName, double wingSpan, int maximumAge) { this.englishName = englishName; this.wingSpan = wingSpan; this.maximumAge = maximumAge; } @Override public String toString() { return &quot;Bird{&quot; + &quot;englishName=&#39;&quot; + englishName + &#39;\\&#39;&#39; + &quot;, wingSpan=&quot; + wingSpan + &quot;, maximumAge=&quot; + maximumAge + &#39;}&#39;; } } The first thing you need to figure out when implementing sorting is what is the natural sort order of this class? This depends entirely on you application: which aspect of your class will be used primarily for sorting. In this case, I choose the wingSpan property. Next, these steps should be taken: Declare your class as implementer of the Comparable contract Create the method stub. Implement the logic Step 2 is done by IntelliJ once you’ve done 1 and selected te context menu (alt + enter): Implement interface methods Select the single method and press enter. This is the result. @Override public int compareTo(Bird other) { return 0; } This compiles just fine, but logic is missing. The next snipped solves that. @Override public int compareTo(Bird other) { //declare named variables for readability final int BEFORE = -1; final int EQUAL = 0; final int AFTER = 1; //compare if(this.wingSpan &lt;= other.wingSpan) return BEFORE; else if (this.wingSpan &gt;= other.wingSpan) return AFTER; else return EQUAL; } Time for a test drive. The toString method was adjusted for readability and compactness. Also, a Java8+ feature (Streams API) was used for printing (not part of this courses’ material). List&lt;Bird&gt; birds = new ArrayList&lt;&gt;(); birds.add(new Bird(&quot;Buzzard&quot;, 1.3, 29)); birds.add(new Bird(&quot;Griffon vulture&quot;, 2.6, 25)); birds.add(new Bird(&quot;Kestrel&quot;, 0.35, 15)); birds.add(new Bird(&quot;Red kite&quot;, 1.8, 23)); birds.add(new Bird(&quot;Steppe eagle&quot;, 2.1, 41)); System.out.println(&quot;Before:&quot;); //prints addition order using Java8 streams birds.stream().forEach(bird -&gt; System.out.println(&quot;\\t&quot; + bird)); Collections.sort(birds); System.out.println(&quot;After sort on wingspan:&quot;); //prints sort order on wingspan, ascending birds.stream().forEach(bird -&gt; System.out.println(&quot;\\t&quot; + bird)); outputs Before: Buzzard', ws=1.3, max.age=29 Griffon vulture', ws=2.5, max.age=25 Kestrel', ws=0.35, max.age=15 White-tailed eagle', ws=2.5, max.age=25 Red kite', ws=1.8, max.age=23 Steppe eagle', ws=2.1, max.age=41 After sort on wingspan: Kestrel', ws=0.35, max.age=15 Buzzard', ws=1.3, max.age=29 Red kite', ws=1.8, max.age=23 Steppe eagle', ws=2.1, max.age=41 Griffon vulture', ws=2.5, max.age=25 White-tailed eagle', ws=2.5, max.age=25 Note the ascending order of wingspan. What if the natural order is descending in your opinion? Simply reverse the sort logic: @Override public int compareTo(Bird other) { final int BEFORE = -1; final int EQUAL = 0; final int AFTER = 1; if(this.wingSpan &lt;= other.wingSpan) return AFTER; else if (this.wingSpan &gt;= other.wingSpan) return BEFORE; else return EQUAL; } outputs After: Griffon vulture', ws=2.6, max.age=25 Steppe eagle', ws=2.1, max.age=41 Red kite', ws=1.8, max.age=23 Buzzard', ws=1.3, max.age=29 Kestrel', ws=0.35, max.age=15 Although this sort logic is just fine, it is often better to use classes that are dedicated to dealing with the datatype and delegate to their implemented and tested methods: @Override public int compareTo(Bird other) { //delegate to class double return Double.compare(this.wingSpan, other.wingSpan); } 18.2 Sorting using a custom Comparator What if you want to sort in other ways as well, or if you do not want to settle on a natural sort order? Then there is the second form of the Collections.sort() method, also supported by the List.sort() method since Java 8: public static &lt;T&gt; void sort(List&lt;T&gt; list, Comparator&lt;? super T&gt; c) or public void sort(@Nullable Comparator&lt;? super E&gt; comparator) The Comparator interface has a single abstract method: package java.util public interface Comparator&lt;T&gt; { int compare(T one, T two); } Let’s start with the most straightforward implementation. package snippets.apis; import java.util.Comparator; public class BirdNameComparator implements Comparator&lt;Bird&gt; { @Override public int compare(Bird first, Bird second) { return first.englishName.compareTo(second.englishName); } } This one sorts on name, and again delegates to the type of the instance variable - class String. This is its usage. Collections.sort(birds, new BirdNameComparator()); //or, the Java8+ way birds.sort(new BirdNameComparator()) Implementations of the Comparator interface are often created on-the-fly. For instance, look at this anonymous inner class. Collections.sort(birds, new Comparator&lt;Bird&gt;(){ @Override public int compare(Bird first, Bird second) { return Integer.compare(first.maximumAge, second.maximumAge); } }); Actually, since Java8, sorting has become much versatile, but you need to climb the learning curve of lambdas first: //Java8+ alternative: OK Collections.sort(birds, (birdOne, birdTwo) -&gt; Integer.compare(birdOne.maximumAge, birdTwo.maximumAge)); //Java8+ alternative: best Collections.sort(birds, Comparator.comparingInt(bird -&gt; bird.maximumAge)); Lambdas are out of scope for this course, unfortunately. 18.3 Multilevel sorting The final part of this post does not deal with the API but with the logic to implement it. You have seen how to code simple comparison logic. But what if you want to sort on multiple properties? Suppose, in the case of the birds example, we wanted to sort on wingspan first and then on name. No matter how many properties, the pattern is always the same: check the primary property, return this if they are not equal. If they are equal, check on the secondary property: @Override public int compareTo(Bird other) { int compareWingSpan = Double.compare(this.wingSpan, other.wingSpan); if (compareWingSpan == 0) { return this.englishName.compareTo(other.englishName); } return compareWingSpan; } Note that with alphabetical sorting capitals come before lower case letters. This is because the numeric values of the table of ASCII codes are used: The ASVII code "],["exceptions.html", "Chapter 19 Exceptions 19.1 What are exceptions 19.2 Checked and unchecked exceptions 19.3 All try/catch elements 19.4 Try-with resources", " Chapter 19 Exceptions Before dealing with file IO, exceptions need to be discussed. You need to deal with exceptions whenever you deal with the outside world. Why? The outside world is dangerous and unpredictable: files do not exist, or are not accessible to you, internet connections can be down, a database has a new password or URL… All these scenarios will throw an Exception your way. It is up to you, the application programmer, to catch them and deal with them. Either by following an alternative program path, or to quit the application elegantly. Exceptions are method return values that do not follow regular program flow; they are instantiated when something goes wrong and usually cause the program to behave differently. 19.1 What are exceptions Consider this code. package snippets.apis; public class ExceptionsDemo { public static void main(String[] args) { doFirst(); } private static void doFirst() { doSecond(); } private static void doSecond() { int x = 42 / 0; } } Running main() will generate an error resulting in a stacktrace: Exception in thread \"main\" java.lang.ArithmeticException: / by zero at snippets.apis.ExceptionsDemo.doSecond(ExceptionsDemo.java:13) at snippets.apis.ExceptionsDemo.doFirst(ExceptionsDemo.java:9) at snippets.apis.ExceptionsDemo.main(ExceptionsDemo.java:5) The error - the fact that a number cannot be divided by zero - occurs in method doSecond() and this will cause the JVM to generate an Exception. In this case, an ArithmeticException. The stack trace starts with the method where the error originated, and works its way down to main() from where the application “crashes” because the exception was not caught/resolved by program logic. The Exception object is thrown from this point down the call stack unless it is caught. The name “stacktrace” refers to the call stack or stack of execution. A call stack is a data structure that stores information about the active subroutines of a computer program. The current executing function is always on top. When an exception or error occurs, you will see a traceback through this stack, from the top (where the error occurred) back to the main() function. This gives you information about the origin and nature of the error. 19.2 Checked and unchecked exceptions Although the name Exception was used in this example, there are actually quite a few in the Java API. They are all related to each other through inheritance. The base type of all is class Throwable. It has two children: Error and Exception. See figure below. Exception hierarchy There are exceptions for standard IO operations. These are called checked exceptions because their fate is checked by the compiler: whenever you call a method throwing one of these, you must catch it, or add a throws clause to your method. There is a subbranch extending from RuntimeException that represent the unchecked exceptions. These are not checked by the compiler: you can throw or catch these explicitly, but that is not required. Checked exceptions Whenever a method publishes a throws clause of a checked exception in its method signature, you must take one of these two courses of action: Catch it yourself: place this code in a try/catch structure try { /*do the risky thing*/ } catch (Exception e) { /*solve the problem*/ } Make other code solve the problem: place a throws clause in the method signature: public void doRisky() throws Exception { /*risky method body* } You should use the Exception hierarchy to make a robust error-handling backbone in your application. Have a look at this basic example and read the code comments carefully. package snippets.apis; import java.io.FileNotFoundException; import java.io.IOException; import java.nio.file.FileAlreadyExistsException; import java.sql.SQLException; import java.util.logging.Level; import java.util.logging.Logger; public class MyAppWithExceptions { public static void main(String[] args) { MyAppWithExceptions app = new MyAppWithExceptions(); app.start(); } private void start() { try { loadDatabase(); readFile(&quot;some_file&quot;); processData(); writeResults(&quot;results_file&quot;); } catch (IOException | SQLException e) { Logger.getLogger(&quot;MyApp&quot;).log(Level.SEVERE, &quot;IO error!&quot;, e); System.err.println(&quot;An error occurred. See the log for details.&quot;); //don&#39;t use stacktrace in production! //e.printStackTrace(); } } private void processData() { try { //processing file data } catch (NumberFormatException e) { //note this is an unchecked exception; //the try/catch is optional Logger.getLogger(&quot;MyApp&quot;).log(Level.INFO, &quot;Number format problem&quot;, e); } } private void writeResults(String resultsFile) throws FileAlreadyExistsException { //write to results file } private void loadDatabase() throws SQLException { //loading MySQL DB } private void readFile(String someFile) throws FileNotFoundException { //reading input data } } Unchecked exceptions Unchecked exceptions are quite similar to checked exceptions, but with the difference that you do not - need to declare them - need to try/catch or throw them explicitly. Unchecked exceptions include NumberFormatException, NullPointerException, IllegalArgumentException and UnsupportedOperationException. In modern Java, unchecked exceptions are preferred above checked exceptions. Try to work with these as much as possible. Errors You should never ever try to catch errors. There is no possible use case for that: try { thirdMethod(); } catch (OutOfMemoryError error) { //recover from an out-of-memory error? } 19.3 All try/catch elements Here are all the try/catch flow control elements. Note that the supertype of more specific exceptions need to be caught last, after the specific types. try{ /*The risky thing. This block will run until an exception occurs - also exceptions that are not explicitly caught*/ } catch (FileNotFoundException | EndOfFileException ex) { /*Deal with some specific file problems*/ } catch(IOException ex) { /*IOException is supertype to FileNotFoundException and EndOfFileException. Deal with all other IO problems in this catchall*/ } catch(SQLException ex) { /*Deal with database problems. SQLException is a sibling to IOException*/ } finally { /*Always runs, exception or not! Do things that need to be done, no matter what, like closing a file or database connection*/ } 19.4 Try-with resources Java 7 introduced the try-with resources structure, which automatically closes the resource once the try block has finished: try (&lt;OPEN RESOURCE&gt;) { } catch (&lt;RESOURCE EXCEPTION&gt;) { } This form assures that a resource will be closed() after the try{} block exits, with or without error. See the post on IO for its usage. "],["file-io.html", "Chapter 20 File IO 20.1 Path &amp; Paths 20.2 File and Files 20.3 Parsing file content the easy way 20.4 Note on character sets", " Chapter 20 File IO Almost all applications work on external data – files, databases and internet resources. Here we will only have a look at files. 20.1 Path &amp; Paths These classes represent storage locations, not the files themselves. They are useful for quite a number of things. Here are a few. String fileName = &quot;/Users/michiel/IdeaProjects/JavaIntroProgrammingAssignments/data/proteins.fa&quot;; Path path = Paths.get(fileName); System.out.println(&quot;path = &quot; + path); System.out.println(&quot;path.getParent() = &quot; + path.getParent()); System.out.println(&quot;path.getRoot() = &quot; + path.getRoot()); System.out.println(&quot;path.subpath(0,3) = &quot; + path.subpath(0, 3)); System.out.println(&quot;path.getFileName() = &quot; + path.getFileName()); //convert to File object File file = path.toFile(); will output path = /Users/michiel/IdeaProjects/JavaIntroProgrammingAssignments/data/proteins.fa path.getParent() = /Users/michiel/IdeaProjects/JavaIntroProgrammingAssignments/data path.getRoot() = / path.subpath(0,3) = Users/michiel/IdeaProjects path.getFileName() = proteins.fa 20.2 File and Files Class Files has typical utility methods: String fileName = &quot;/Users/michiel/IdeaProjects/JavaIntroProgrammingAssignments/data/proteins.fa&quot;; Path path = Paths.get(fileName); System.out.println(&quot;Files.isReadable(path) = &quot; + Files.isReadable(path)); System.out.println(&quot;Files.isDirectory(path) = &quot; + Files.isDirectory(path)); try { Path copy = Paths.get(&quot;/Users/michiel/Desktop/test.fa&quot;); //delete if it already exists Files.deleteIfExists(copy); Files.copy(path, copy); } catch (IOException e) { e.printStackTrace(); } outputs this, and copies the file to my Desktop. Files.isReadable(path) = true Files.isDirectory(path) = false Files.copy() = /Users/michiel/Desktop/test.fa Class File represents the actual file on the storage system. Here is a standard workflow with reading and writing. Create Create a file. if(! Files.exists(dataPath)) { try { Files.createFile(dataPath); } catch (IOException e) { e.printStackTrace(); } } Write Write to file. Note the try-with-resources construct that was introduced in Java7. try (BufferedWriter writer = Files.newBufferedWriter(dataPath, StandardOpenOption.APPEND)) { writer.write(&quot;Hi there&quot;); writer.newLine(); writer.write(&quot;Bye now&quot;); writer.newLine(); } catch (IOException e) { e.printStackTrace(); } Note the StandardOpenOption argument. Besides APPEND you have these choices: APPEND If the file is opened for WRITE access then bytes will be written to the end of the file rather than the beginning. CREATE Create a new file if it does not exist. CREATE_NEW Create a new file, failing if the file already exists. READ Open for read access. WRITE Open for write access. Running this code twice will generate this file contents: Write to file For convenience, you can wrap the BufferedWriter into a PrintWriter instance. This gives you easier line writing and the possibility for string formatting: try (PrintWriter writer = new PrintWriter(Files.newBufferedWriter(dataPath, StandardOpenOption.APPEND))) { writer.println(&quot;I&#39;m back!&quot;); writer.format(&quot;%s is mijn voornaam en %s mijn achternaam&quot;, &quot;Michiel&quot;, &quot;Noback&quot;); //Also nice: class MessageFormat writer.println(MessageFormat.format(&quot;{0} is mijn voornaam en {1} mijn achternaam&quot;, &quot;Jan&quot;, &quot;Jansen&quot;)); } catch (IOException e) { e.printStackTrace(); } Read Reading data from file is a similar process: try(BufferedReader reader = Files.newBufferedReader(dataPath)) { String line; while ((line = reader.readLine()) != null) { System.out.println(&quot;line = &quot; + line); } } catch (IOException e) { e.printStackTrace(); } 20.3 Parsing file content the easy way A thing that typically happens when reading data is to split the line into elements on some separator: //splits on spaces String[] elements = line.split(&quot; &quot;) In this example, this is the employee data we are going to process. Name Age Function Salary*1000 JohnDoe 27 Programmer 23.67 JaneSmith 31 Manager 42.00 JoanDonnely 38 CEO 89.87 RoseBanner 18 secretary 11.78 File empl_data.csv is a tab-separated file. Note the first line is a header and not real data. Here is a typical use case for working with structured data. First, class Employee: package snippets.apis; public class Employee { private String name; private int age; private double salary; public Employee(String name, int age, double salary) { this.name = name; this.age = age; this.salary = salary; } @Override public String toString() { return &quot;Employee{&quot; + &quot;name=&#39;&quot; + name + &#39;\\&#39;&#39; + &quot;, age=&quot; + age + &quot;, salary=&quot; + salary + &#39;}&#39;; } } Next, parse Employee instances: private static List&lt;Employee&gt; parseEmployees() { String fileName = &quot;/Users/michiel/IdeaProjects/JavaIntroProgrammingAssignments/data/empl_data.csv&quot;; Path path = Paths.get(fileName); List&lt;Employee&gt; employees = new ArrayList&lt;&gt;(); try (BufferedReader br = Files.newBufferedReader(path)) { String line; int lineNumber = 0; while ((line = br.readLine()) != null) { lineNumber++; //skips first header line if (lineNumber == 1) continue; //split on tabs String[] elements = line.split(&quot;\\t&quot;); String name = elements[0]; //convert to int int age = Integer.parseInt(elements[1]); String function = elements[2]; //convert to double double salary = Double.parseDouble(elements[3]) * 1000; Employee emp = new Employee(name, age, salary); employees.add(emp); System.out.println(emp); } } catch (IOException e) { e.printStackTrace(); } return employees; } As stated before: this is very typical for the start of any data processing pipeline. More advanced splitting is discussed in a next topic: regular expressions. 20.4 Note on character sets All these examples worked with the default characterset of Java, UTF-8. When other sets are required, these can be specified in the Files.newBufferedReader() and Files.newBufferedWriter() factory methods. See docs for details. "],["regular-expressions.html", "Chapter 21 Regular Expressions 21.1 Regex syntax? 21.2 Methods of class String 21.3 Pattern &amp; Matcher", " Chapter 21 Regular Expressions Often, when your data is well-structured, a String.split() with a simple separator is all you need to process your data,maybe with some conversion methods for creating ints and doubles and such from strings. However, there are cases when you need more: finding restriction enzyme sites, parsing zip codes in addresses for instance. This part only introduces the Java regex API It is NOT a tutorial on regex! (PS, I borrowed some examples from http://www.vogella.com) Regular expressions are used to search for patterns in text For instance, if you want to find occurrences of Dutch zip codes, you could use this: [a-zA-Z]{4} ?[0-9]{2} For Java regex, these classes are related to regular expression matching (and replacement): java.lang.String has several useful methods working with regexes java.util.regex.Pattern works together with java.util.regex.Matcher for advanced regex operations 21.1 Regex syntax? A regular expression is used to describe a pattern that is not literal - different distinct character strings could match the pattern. 21.1.1 Backslashes Backslashes have meanings both in String literals and in regex. They denote special characters, but also negate the special meaning Thus, to match a literal backslash, your regex will be \\\\\\\\ !! 21.1.2 Character classes You can specify groups of characters that are all equally valid to match a position using character classes. They can be specified in many ways. Character class Description . Any character [] Set definition, eg [a-z] matches all lowercase characters; [aAbB1234] matches an a, A, b, B or numbers 1, 2 ,3, 4 [^] Negated set definition, eg [^a-z] matches anything BUT lowercase characters X|Z Matches X or Z (either one will suffice) ^regex Anchors regex at beginning of line regex$ Anchors regex at end of line Any digit, [0-9]; any non-digit, [^0-9] Any whitespace character; any non-whitespace character A word character, short for [a-zA-Z_0-9]; same but negated Word boundary 21.1.3 Regex quantifiers Quantifiers let you modify how often a group or character is allowed. Quantifier Description {x} Occurs exactly x times {x, } Occurs at least x times {, x} Occurs at the most x times * Occurs zero or more times; same as {0, } + Occurs one or more times; same as {1, } ? Occurs zero or one time; same as {0, 1} *? Non-greedy: “?” after a quantifier makes it a reluctant quantifier, it tries to find the smallest match 21.1.4 Grouping and backreferencing Using parentheses, you can group parts of your regex. They can be used to - Retrieve or substitute parts of a regex - Apply quantifiers to groups - use back referencing Via the $ you can refer to a group. $1 is the first group, $2 the second, etc (see examples). Similarly, back referencing is used to repeat pattern matches; this will replace all repeating character patterns: &quot;ABCDEEEFGGHIJJJKL&quot;.replaceAll(&quot;(\\\\w)\\\\1+&quot;, &quot;_rep_&quot;) resulting in ABCD_rep_F_rep_HI_rep_KL. 21.2 Methods of class String Many of the common tasks can be performed using the String class only. Method Description s.matches(regex) Tells whether or not this string matches the given regular expression. s.split(regex) Splits this string around matches of the given regular expression s.split(regex, limit) Idem, but the limit parameter controls the number of times the pattern is applied s.replaceAll(regex, replacement) Replaces each substring of this string that matches the given regular expression with the given replacement s.replaceFirst(regex, replacement) Replaces the first substring of this string that matches the given regular expression with the given replacement. Here are some examples. String input = &quot;Dogs rule this doggin&#39; world&quot;; //replace() works with literal string! System.out.println(input.replace(&quot;[Dd]og&quot;, &quot;Cat&quot;)); System.out.println(input.replace(&quot;Dog&quot;, &quot;Cat&quot;)); //replaceAll() works with regex! System.out.println(input.replaceAll(&quot;[Dd]og&quot;, &quot;Cat&quot;)); System.out.println(Arrays.toString(input.split(&quot;[Dd]&quot;))); //matches() looks at whole target string. System.out.println(input.matches(&quot;[Dd]ogs&quot;)); System.out.println(input.matches(&quot;^[Dd]ogs.+&quot;)); outputs Dogs rule this doggin' world Cats rule this doggin' world Cats rule this Catgin' world [, ogs rule this , oggin' worl] false true Some more advanced examples: String INPUT = &quot;This is the &lt;title&gt;example&lt;/title&gt; &quot; + &quot;string which , I&#39;m going to use for pattern matching.&quot;; // Split on whitespace stretches String[] splitString = (INPUT.split(&quot;\\\\s+&quot;)); // Removes whitespace between a word character and . or , String pattern = &quot;(\\\\w)(\\\\s+)([\\\\.,])&quot;; System.out.println(INPUT.replaceAll(pattern, &quot;$1$3&quot;)); // Extract the text between the two title elements of pattern = &quot;(?i)(&lt;title.*?&gt;)(.+?)(&lt;/title&gt;)&quot;; String updated = INPUT.replaceAll(pattern, &quot;$2&quot;); // prints true if the string contains a number less then 300 System.out.println(s.matches(&quot;[^0-9]*[12]?[0-9]{1,2}[^0-9]*&quot;)); Note that adjusting the regex mode with (?i)&lt;regex&gt; makes the regex case insensitive. 21.3 Pattern &amp; Matcher For more complex tasks, use class Pattern to specify it and class Matcher to find, replace or extract it. Here is a typical use case: //with case insensitive matching Pattern hinc2 = Pattern.compile(&quot;(?i)(GT([CT][AG])AC)&quot;); Matcher matcher = hinc2.matcher(&quot;GTCAACtgttgaccc&quot;); while (matcher.find()) { System.out.println(&quot;matcher.group() = &quot; + matcher.group()); //whole pattern - same as group() System.out.println(&quot;matcher.group(0) = &quot; + matcher.group(0)); System.out.println(&quot;matcher.group(2) = &quot; + matcher.group(2)); System.out.println(&quot;matcher.start() = &quot; + matcher.start()); } //with chained method calls - replace with group capture final String replaced = hinc2.matcher(&quot;GTCAACtgttgaccc&quot;).replaceAll(&quot;[[$1]]&quot;); System.out.println(&quot;replaced = &quot; + replaced); outputs matcher.group() = GTCAAC matcher.group(0) = GTCAAC matcher.group(2) = CA matcher.start() = 0 matcher.group() = gttgac matcher.group(0) = gttgac matcher.group(2) = tg matcher.start() = 7 replaced = [[GTCAAC]]t[[gttgac]]cc Note: when a Pattern object is used more than once, a compiled version should be cashed! Usually this is done in an instance or class variable. There is much more to regex of course; GIYF for more detailed use cases. "],["encapsulation.html", "Chapter 22 Encapsulation 22.1 Summary", " Chapter 22 Encapsulation So far, we have not dealt with the concept of data hiding which actually is a pivotal aspect of object-oriented programming. This concept will be illustrated here, starting with the Cell class from Part one (see 5). I modified it a bit for demonstration purposes. All access modifiers were removed and a check was introduced, so that the program crashes when a Cell grows too big. package snippets.testtube2; public class Cell { //diameter in micrometers int diameter = 5; int growthIncrement = 1; /** * Lets this cell grow in a single increment */ void grow() { //grow by 1 micrometer this.diameter += growthIncrement; //we can grow many cycles safely before resources run out if (this.diameter &gt; 1000) throw new Error(&quot;TestTube will explode in 5 seconds&quot;); } } So, the logic of this cell is based on the assumption that it starts growing at size 5 with an increment of 1 at each cycle. Nothing funny going on. Now here is a very simple version of class TestTube. package snippets.testtube2; class TestTube { Cell cell; public static void main(String[] args) { TestTube tube = new TestTube(); tube.cell = new Cell(); //run for 5 generations for (int i = 0; i &lt; 5; i++) { tube.growCells(); } } /** * Grows the cells, in one single iteration. */ void growCells() { //set diameter in nanometers cell.diameter = 6000; cell.growthIncrement = 750; cell.grow(); System.out.println(&quot;cell diameter = &quot; + cell.diameter); } } which outputs Exception in thread \"main\" java.lang.Error: TestTube will explode in 5 seconds at snippets.testtube2.Cell.grow(Cell.java:14) at snippets.testtube2.TestTube.growCells(TestTube.java:22) at snippets.testtube2.TestTube.main(TestTube.java:11) The TestTube developer was working with nanometer units while the Cell developer was working with micrometer units. The result is a crashing application (or Mars orbiter). Besides this big problem, when another class tries to run the growCells() method on a TestTube instance, it will get a NullPointerException. Can you figure out why? So we need a way to protect the inner state of objects Java has a heap of techniques for preventing illegal access or modification to your instance variables (and methods). These techniques start with the use of access modifiers. Let’s improve and secure this Cell and TesTube and keep access open only to that which needs to be publicly accessible. Here is a new and improved Cell class: package snippets.testtube2; public class Cell { private int diameterInMicrometers = 5; private final int growthIncrementInMicrometers; /** * Construct with diameter and growth increment, in micrometers. * * @param diameterInMicrometers diameter between 1 and 40 micrometers * @param growthIncrementInMicrometers growth increment between 1 and 5 micrometers * @throws IllegalArgumentException ex if one of the arguments is out of range */ public Cell(int diameterInMicrometers, int growthIncrementInMicrometers) { if (diameterInMicrometers &lt; 1 || diameterInMicrometers &gt; 41 || growthIncrementInMicrometers &lt; 1 || growthIncrementInMicrometers &gt; 6 ) { throw new IllegalArgumentException(&quot;Cell size must start between 0 and 40 &quot; + &quot;and growth increment between 0 and 5&quot;); } this.diameterInMicrometers = diameterInMicrometers; //growth increment can never be changed after construction this.growthIncrementInMicrometers = growthIncrementInMicrometers; } /** * Serves the read-only property diameter. * @return */ public int getDiameterInMicrometers() { return diameterInMicrometers; } /** * Grows this cell in a single increment, increasing its size with one time * the growth increment. * */ public void grow() { this.diameterInMicrometers += growthIncrementInMicrometers; if (this.diameterInMicrometers &gt; 1000) throw new Error(&quot;TestTube will explode in 5 seconds&quot;); } } Quite a lot has changed: 1. All instance variables have been marked private which means only code inside class Cell can access them. 2. Variables have been renamed to be more reflective of what they represent. 3. A Constructor was added to provide a single point of assignment to both variables, at construction time. 4. The constructor performs a check on its parameters so that illegal arguments are caught early. 5. Javadoc was added to explain the public API. 6. A single getter was introduced for property diameter, making it a read-only property. 7. No getter was created for property growthIncrementInMicrometers because it was decided by the developer (me) that it should only be set once during the life cycle of a Cell object. For that reason, instance variable growthIncrementInMicrometers was marked final. One setback of this whole procedure: class TestTube will not compile anymore because (a) it attempts to access the private members of class Cell and (b) because there is no no-arg constructor anymore: Compile errors Since Javadoc was added to class Cell, we can get additional information in IntelliJ by pressing ctrl + Q (Linux), ctrl + J (Mac), or F1when the cursor is on the Constructor: Show Javadoc Let’s solve the compilation problems, make TestTube safe, add multi-cell support, and move the main() function to the Simulator class. package snippets.testtube2; import java.util.ArrayList; import java.util.List; public class TestTube { private final int numberOfLifeCyclesToRun; private final int initialCellCount; private List&lt;Cell&gt; cells = new ArrayList&lt;&gt;(); private int defaultCellDiameter = 20; private int defaultSizeIncrement = 2; /** * Constructs with the two essential parameters * @param numberOfLifeCyclesToRun a number between 1 and 100 * @param initialCellCount a number between 1 and 1000 * @return testtube a TestTube instance */ public TestTube (int numberOfLifeCyclesToRun, int initialCellCount) { if (numberOfLifeCyclesToRun &lt; 1 || numberOfLifeCyclesToRun &gt; 100 || initialCellCount &lt; 1 || initialCellCount &gt; 1000) { throw new IllegalArgumentException(&quot;Number of life cycles should be between 1 and 100 and initial cell &quot; + &quot;count between 1 and 1000&quot;); } this.numberOfLifeCyclesToRun = numberOfLifeCyclesToRun; this.initialCellCount = initialCellCount; } /** * sets the initial diameter of instantiated cells. * @param defaultCellDiameter */ public void setDefaultCellDiameter(int defaultCellDiameter) { this.defaultCellDiameter = defaultCellDiameter; } /** * Sets the size increment for cell growth * @param defaultSizeIncrement */ public void setDefaultSizeIncrement(int defaultSizeIncrement) { this.defaultSizeIncrement = defaultSizeIncrement; } /** * starts the growth process */ public void start() { initializeCells(); runLifeCycles(); } private void runLifeCycles() { for (int i = 0; i &lt; this.numberOfLifeCyclesToRun; i++) { growCells(); } } private void initializeCells() { for (int i = 0; i &lt; this.initialCellCount; i++) { cells.add(new Cell(this.defaultCellDiameter, this.defaultSizeIncrement)); } } private void growCells() { for (Cell cell : this.cells) { cell.grow(); } //since Java 8, this is also possible: //this.cells.forEach(c -&gt; c.grow()); //or //this.cells.forEach(Cell::grow); } } Yes, the class file became substantially larger - one of the setbacks of safe design. There are several noteworthy changes here: All instance variables are private. Note a pattern here? Two public setters were provided (making defaultCellDiameter and defaultSizeIncrement write-only), a public constructor and one public API method that will start the testtube: start() All functionality is divided into very small methods with a very clear (and testable) responsibility. This is the Single responsibility Principle at work. See post SRP for more details. Finally, here is the controller class CellGrowthSimulator. Its sole purpose is now to start the simulation process. package snippets.testtube2; /** * &quot;Controller&quot; class */ public class CellGrowthSimulator { public static void main(String[] args) { startSimulation(); } private static void startSimulation() { TestTube testTube = new TestTube(10, 5); testTube.setDefaultCellDiameter(10); testTube.start(); } } 22.1 Summary This post has introduced a fundamental concept of Object-Oriented Programming and design: encapsulation; hiding the inner workings of a class, mostly through the use of the private keyword and usage of getters and setters. It has also shown a first view of abstraction in class TestTube: this class has a single simple public API method (start()) and has hidden all the complexities of its simulation algorithm. You have seen two access modifiers; there are two more that are dealt with in the next post. Also, there is another post covering some more sophisticated aspects of encapsulation. "],["access-modifiers-other-keywords.html", "Chapter 23 Access modifiers &amp; Other keywords 23.1 Access Modifiers 23.2 Other keywords", " Chapter 23 Access modifiers &amp; Other keywords Several access modifiers and keywords have already been introduced, explicitly or implicitly. This post gives an overview of the most important ones. 23.1 Access Modifiers Access modifiers are used in the declaration of a method, field, or inner class -collectively called members- to control access to them. Using no modifier is an (implicit) modifier, giving default - but very distinct! - behavior. private Private members can only be accessed by other members of their own class. protected Protected members can only be accessed by members of their own class, that class’s subclasses or classes from the same package. public Public members can be accessed by the members of any class. default access occurs when no explicit access modifier is attached to a member. Members with default access can be accessed by classes within the same package. This is the same info in table form: Keyword Class Package Subclass All public ✓ ✓ ✓ ✓ protected ✓ ✓ ✓ default/no modifier ✓ ✓ private ✓ Careful choice of access levels is fundamental to good Java design. Although there are no strict rules, fields (instance and class variables) should usually be private, where public (or default) getters and/or setters privide read and/or write access. API methods should be public. When classes in the same package work intimately together, default access can be appropriate. The same holds for inheritance relationships and the protected modifier. Design rule: Minimize the accessibility of class members. Changing public API methods is almost impossible since it will create backward incompatibility. 23.2 Other keywords This is a list of keywords in the Java programming language. I omitted the access modifiers (discussed separately), the primitive types, flow control keywords as well as some I do not deem essential in an introduction of Java. You cannot use any of the these as identifiers. Text was copied from Wikipedia and edited. abstract Abstracts are used to implement an abstraction in Java. A method with no definition must be declared as abstract and the class containing it must be declared as abstract. Abstract classes cannot be instantiated. Abstract methods must be implemented in the first concrete subclass. Note that an abstract class isn’t required to have an abstract method at all. assert (added in J2SE 1.4) Assert describes a predicate (a true–false statement) placed in a Java program to indicate that the developer thinks that the predicate is always true at that place. If an assertion evaluates to false at run-time, an assertion failure results, which typically causes execution to abort. class A type that defines the implementation of a particular kind of object. A class definition specifies the interfaces the class implements and the immediate superclass of the class. If the superclass is not explicitly specified, the superclass is implicitly Object. The class keyword can also be used in the form Class.class to get a Class object without needing an instance of that class. For example, String.class can be used instead of doing new String().getClass(). enum (added in J2SE 5.0)[3] A Java keyword used to declare an enumerated type. Enumerations extend the base class Enum. extends Used in a class declaration to specify the superclass; used in an interface declaration to specify one or more superinterfaces. Class X extends class Y to add functionality, either by adding fields or methods to class Y, or by overriding methods of class Y. An interface Z extends one or more interfaces by adding methods. Class X is said to be a subclass of class Y; Interface Z is said to be a subinterface of the interfaces it extends. Also used to specify an upper bound on a type parameter in Generics. final Define an entity once that cannot be changed nor derived from later. More specifically: a final class cannot be subclassed, a final method cannot be overridden, and a final variable can occur at most once as a left-hand expression on an executed command. All methods in a final class are implicitly final. implements Included in a class declaration to specify one or more interfaces that are implemented by the current class. A class inherits the types and abstract methods declared by the interfaces. import Used at the beginning of a source file to specify classes or entire Java packages to be referred to later without including their package names in the reference. Since J2SE 5.0, import statements can import static members of a class. interface Used to declare a special type of class that only contains abstract or default methods, constant (static final) fields and static interfaces. It can later be implemented by classes that declare the interface with the implements keyword. new Used to create an instance of a class or array object. package A Java package is a group of similar classes and interfaces. Packages are declared with the package keyword. Classes have a package declaration at the top of the source file. static Used to declare a field, method, or inner class as a class field. Classes maintain one copy of class fields regardless of how many instances exist of that class. static also is used to define a method as a class method. Class methods are bound to the class instead of a specific instance, and can only operate on class fields. (Classes and interfaces declared as static members of another class or interface are actually top-level classes and are not inner classes.) super Used to access members of a class inherited by the class in which it appears. Allows a subclass to access overridden methods and hidden members of its superclass. The super keyword is also used to forward a call from a constructor to a constructor in the superclass. Also used to specify a lower bound on a type parameter in Generics. this Used to represent an instance of the class in which it appears. this can be used to access class members and as a reference to the current instance. The this keyword is also used to forward a call from one constructor in a class to another constructor in the same class. throw Causes the declared exception instance to be thrown. This causes execution to continue with the first enclosing exception handler declared by the catch keyword to handle an assignment compatible exception type. If no such exception handler is found in the current method, then the method returns and the process is repeated in the calling method. If no exception handler is found in any method call on the stack, then the exception is passed to the thread’s uncaught exception handler. throws Used in method declarations to specify which exceptions are not handled within the method but rather passed to the next higher level of the program. All uncaught exceptions in a method that are not instances of RuntimeException must be declared using the throws keyword. void The void keyword is used to declare that a method does not return any value. "],["inheritance-and-uml.html", "Chapter 24 Inheritance and UML 24.1 The TestTube with cells 24.2 Apply inheritance to model what is common", " Chapter 24 Inheritance and UML In this post, the concept of inheritance will be revisited and expanded. Since this is a good place for it, a visualization standard called UML (Unified Modelling Language) is also introduced. 24.1 The TestTube with cells Here is the TestTube at the end of this post 22. Instead of showing code, a UML diagram is displayed. Test tube UML You can generate such a thing yourself in IntelliJ by selecting the source files you want to visualize → right-click → Diagrams → Show Diagram. The diagram above shows everything: fields, methods, constructors, with any access level. Using the Diagrams menu (and general settings - see the doc) you can filter what you want to show. Here are the same classes with only the public fields shown, and no constructors: Test tube public So, what does this tell us? Class CellGrowthSimulator has a singular field of type TestTube and creates the instance itself. Class TestTube has 1 to many instances of Cell (held in a List&lt;Cell&gt;), and instantiates them itself. These HAS_A relations (class A has an instance of class B) are depicted with the arrow-with-diamond connector. New specs: different types of cells So here comes your boss and tells you “…but how about het difference between bacteria and eukaryotic cells?? They are of way different size and grow at different speeds. I WANT TO GROW MANY TYPES OF CELLS IN MY TEST TUBE!! And didn’t I tell you? They should be able to divide as well.” You start thinking about the new specs. - When to divide? - Who controls division: - TestTube or the cell itself? - How does this relate to growing? - The different cell types is easy! Just give every type its own class As an expert on the subject, you decide that the cells and not the test tube should know when to divide; in fact, they should be solely responsible for their size and increment (not the testtube). Division is depending on the cell size: when a certain size is reached, it is time to divide. Here is the new design. Note that I simplified the names again and removed comments for conciseness’ sake. class Bacterium package snippets.testtube3; public class Bacterium { private int diameter = 10; private static final int growthIncrement = 1; private static final int maximumDiameter = 30; public int getDiameter() { return diameter; } public Bacterium grow() { this.diameter += growthIncrement; if (this.diameter &gt; maximumDiameter) { return new Bacterium(); } else { return null; } } } class Eukaryote package snippets.testtube3; public class Eukaryote { private int diameter = 20; private static final int growthIncrement = 3; private static final int maximumDiameter = 80; public int getDiameter() { return diameter; } public Eukaryote grow() { this.diameter += growthIncrement; if (this.diameter &gt; maximumDiameter) { return new Eukaryote(); } else { return null; } } } See how similar it is to class Bacterium? class TestTube package snippets.testtube3; import java.util.ArrayList; import java.util.List; public class TestTube { private final int numberOfLifeCyclesToRun; private final int initialCellCount; private final String cellType; private List&lt;Bacterium&gt; bacteria = new ArrayList&lt;&gt;(); private List&lt;Eukaryote&gt; eukaryotes = new ArrayList&lt;&gt;(); public TestTube (int numberOfLifeCyclesToRun, int initialCellCount, String cellType) { //check code omitted this.numberOfLifeCyclesToRun = numberOfLifeCyclesToRun; this.initialCellCount = initialCellCount; this.cellType = cellType; } public void start() { initializeCells(); runLifeCycles(); } private void runLifeCycles() { for (int i = 0; i &lt; this.numberOfLifeCyclesToRun; i++) { growCells(); } } private void initializeCells() { for (int i = 0; i &lt; this.initialCellCount; i++) { if (this.cellType.equals(&quot;Bacteria&quot;)) { bacteria.add(new Bacterium()); } else if (this.cellType.equals(&quot;Eukarya&quot;)) { eukaryotes.add(new Eukaryote()); } //room for more cell types } } private void growCells() { if (this.cellType.equals(&quot;Bacteria&quot;)) { for (Bacterium bacterium : this.bacteria) { bacterium.grow(); } } else if (this.cellType.equals(&quot;Eukarya&quot;)) { for (Eukaryote eukaryote : this.eukaryotes) { eukaryote.grow(); } } //room for more cell types } } See how much duplicated code there is in class TestTube, and repeated use of same if/else blocks? Here is the UML of this situation (private fields included). It shows the duplication clearly as well. Test tube UML Repeated code and similar if/else algorithm logic are typical signs of smelly code that can be solved using some Object Oriented design techniques, in this case inheritance. 24.2 Apply inheritance to model what is common Inheritance can be used when there is a IS-A relationship: when it can be said that class A IS-A class B. For example, Apple IS-A Fruit and Pear IS-A Fruit (but not Pear IS-A Apple!). In this case, the IS-A relation ship can be defined as “Bacterium IS-A Cell” and “Eukaryote IS-A Cell”. Once this prerequisite for inheritance is established, the common superclass should be created and all common code from the subclasses moved to it. Class Cell can clearly hold the diameter, the growthIncrement and the maximumDiameter fields, even though they will be different between the subclasses. Class Cell can also publish the growCells() method, even though they will be implemented differently in the subclasses. Key here is that all subclasses will be able to grow. When you know the functionality should be there, but don’t know how, your should make it abstract. As a consequence, your class needs to be abstract as well. Let’s review this with class Cell. package snippets.testtube3; public abstract class Cell { //no decent defaults possible at level of class Cell, //but we know this field is relevant private int diameter; public Cell(int initialDiameter) { this.diameter = initialDiameter; } public int getDiameter() { return diameter; } protected void setDiameter(int newDiameter) { this.diameter = newDiameter; } public abstract Cell grow(); } Note that both the class declaration and the method grow() have been marked abstract. An abstract method has no method body, only a signature - the same as with interfaces. An abstract class cannot be instantiated.. This snippet Cell cell = new Cell(12) will not compile. The next step is declaring your subclasses to extend the superclass (only Bacterium shown here): package snippets.testtube3; public class Bacterium extends Cell{ private static int bacterialInitialDiameter = 10; private static final int growthIncrement = 1; private static final int maximumDiameter = 30; public Bacterium() { super(bacterialInitialDiameter); } @Override public Cell grow() { setDiameter(getDiameter() + growthIncrement); if (getDiameter() &gt; maximumDiameter) { return new Bacterium(); } else { return null; } } } Class Bacterium is required to implement a constructor serving an initial size to the class Cell constructor. It has no diameter property anymore, and no getter for it. It has implemented the grow() method, and because of that is is not abstract and can be instantiated. Note that, although the method signature is public Cell grow(), it returns a Bacterium instance. This is a typical example of polymorphism. You may notice that the static variables growthIncrement and maximumDiameter will be specified in all subclasses and could be specified once (in class Cell). This is true, and several solutions exist for static fields, but focus here lies on different aspects. You may also notice there is not much won with respect to amount of code. That is correct, but in this case the improvement lies in class TestTube: package snippets.testtube3; import java.util.ArrayList; import java.util.List; public class TestTube { private final int numberOfLifeCyclesToRun; private final int initialCellCount; private final String cellType; private List&lt;Cell&gt; cells = new ArrayList&lt;&gt;(); /** * Constructs with the two essential parameters * @param numberOfLifeCyclesToRun a number between 1 and 100 * @param initialCellCount a number between 1 and 1000 * @param cellType the cell type [&quot; * @return testtube a TestTube instance */ public TestTube (int numberOfLifeCyclesToRun, int initialCellCount, String cellType) { //check code omitted this.numberOfLifeCyclesToRun = numberOfLifeCyclesToRun; this.initialCellCount = initialCellCount; this.cellType = cellType; } /** * starts the growth process */ public void start() { initializeCells(); runLifeCycles(); } private void runLifeCycles() { for (int i = 1; i &lt;= this.numberOfLifeCyclesToRun; i++) { growCells(); if (i % 10 == 0) System.out.println(&quot;Grow cycle &quot; + i + &quot; finished; &quot; + cells.size() + &quot; cells present&quot;); } } private void initializeCells() { for (int i = 0; i &lt; this.initialCellCount; i++) { if (this.cellType.equals(&quot;Bacteria&quot;)) { cells.add(new Bacterium()); } else if (this.cellType.equals(&quot;Eukarya&quot;)) { cells.add(new Eukaryote()); } else { throw new IllegalArgumentException(&quot;Unknown cell type: &quot; + cellType); } //room for more cell types - yes this can be improved as well } } private void growCells() { //I have no clue what is growing here and don&#39;t care //enhanced for loop will cause a ConcurrentModificationException for (int i = 0; i &lt; cells.size(); i++) { Cell cell = cells.get(i); Cell child = cell.grow(); if (child != null) cells.add(child); } } } You can see the cell growing logic has been completely decoupled from the actual cells that are being grown. Both grow() methods in the subclasses have specific signatures with respect to the return type (Bacterium, Eukaryote), but still adhere to the superclass contract (otherwise @Override would have instigated a compiler error). For completeness, here is the simulator class, and some output: package snippets.testtube3; public class CellGrowthSimulator { private static TestTube testTube; public static void main(String[] args) { startSimulation(); } private static void startSimulation() { testTube = new TestTube(100,5, &quot;Bacteria&quot;); testTube.start(); } } outputs Grow cycle 10 finished; 5 cells present Grow cycle 20 finished; 5 cells present Grow cycle 30 finished; 55 cells present Grow cycle 40 finished; 105 cells present Grow cycle 50 finished; 430 cells present Grow cycle 60 finished; 1255 cells present Grow cycle 70 finished; 3680 cells present Grow cycle 80 finished; 12105 cells present Grow cycle 90 finished; 35105 cells present Grow cycle 100 finished; 111230 cells present Finally, there is some logic that should be moved for good design. The Cell creation logic should be put in a static factory method inside class Cell to abstract away the cell creation logic and put it in one place for the entire application: public static Cell of(String type) { switch (type) { case &quot;Bacteria&quot;: return new Bacterium(); case &quot;Eukarya&quot;: return new Eukaryote(); default: throw new IllegalArgumentException(&quot;Unknown cell type: &quot; + type); } } and class `TestTube becomes even less aware of whet is being grown: private void initializeCells() { for (int i = 0; i &lt; this.initialCellCount; i++) { cells.add(Cell.of(cellType)); } } Here is the final UML. Test tube final This also shows that actual cell types are hidden behind the abstract Cell class. The subtype constructors could even have been marked protected or &lt;default&gt; to emphasize this. This is the power of polymorphism implemented with inheritance! Polymorphism allows one type to express some sort of contract, and for other types to implement that contract (often through class inheritance) in different ways. Code using that contract should not have to care about which implementation is involved, only that the contract is obeyed. Use a type cast when you need the specific type You have seen it is often best to code against generic types, like in this block: private void growCells() { for (int i = 0; i &lt; cells.size(); i++) { Cell cell = cells.get(i); Cell child = cell.grow(); if (child != null) cells.add(child); } } But what if you have the need for specific functionality? For instance, you have a WhiteBloodCell which can also eatOtherCell(Cell cell): package snippets.testtube3; public class WhiteBloodCell extends Eukaryote { public WhiteBloodCell() { super(); } public void eatOtherCell(Cell cell) { System.out.println(&quot;White blood cell, eating other cell&quot;); //cell eating logic } } Note that this class extends Eukaryote and thereby inherits the grow() method. Now if you want to do something specifically white-blood-cellish, perform a type-test-and-cast: private void growCells() { for (int i = 0; i &lt; cells.size(); i++) { Cell cell = cells.get(i); Cell child = cell.grow(); if (child != null) cells.add(child); //test and cast if (cell instanceof WhiteBloodCell) { WhiteBloodCell wbc = (WhiteBloodCell)cell; wbc.eatOtherCell(child); } } } The lesson here: Objects never ever change type, only the reference to them changes. "],["enums-constants-on-steroids.html", "Chapter 25 Enums: constants on steroids 25.1 Constants are everywhere", " Chapter 25 Enums: constants on steroids 25.1 Constants are everywhere Constants are everywhere: the number pi, the number e, the URL to a web service you use in your app. These are really simple constants that do not need anything special besides being defined as a public static final String PI = 3.1416; public static final String API_URL = &quot;http://www.example.com&quot;; Of course, any alert observer might state that pi is already defined in class Math as PI, and in much more detail: 3.141592653589793. And of course, URLs should not be defined as hard-coded strings, but in a neat little properties file. But this post is not about simple constants. This post is about sets of constants that all refer to a given property with your application. This is where enums come in. I love them and hope that, after reading this post, you will too. I will show you that Java enums are so much more than simple constants. In fact, enums are regular Java classes, but only special in the fact that only the instances defined in the enum class file will ever see the day of light! For instance, the roles of visitors in your web application: GUEST, LOGGED_IN_USER, ADMIN, or pizza sizes in your online ordering form: SMALL, MEDIUM, LARGE, LUNATIC. Or the four letters of the DNA alphabet: G, A, T and C. Let’s look at an example using the nucleotides. public enum Nucleotide { A, C, G, T; } Here, I have defined an enum with four values: G, A, T, and C. As a convention, enum value names must always be all-caps. You can do some nice things with it already. package enums; public final class EnumDemo { public static void main(final String[] args) { EnumDemo enumDemo = new EnumDemo(); enumDemo.start(); } private void start() { Nucleotide nucA = Nucleotide.A; //print it System.out.println(&quot;nucA = &quot; + nucA); //test its nature if (nucA == Nucleotide.A) { System.out.println(&quot;We&#39;ve got an A!&quot;); } //switch on it! switchOnNucleotide(Nucleotide.G); } private void switchOnNucleotide(final Nucleotide nuc) { switch (nuc) { case A: System.out.println(&quot;It is an A&quot;); break; case C: System.out.println(&quot;It is a C&quot;); break; case G: System.out.println(&quot;It is a G&quot;); break; case T: System.out.println(&quot;It is a T&quot;); break; } } } When printed, an enum will simply be displayed as the name of its value: nucA = A We've got an A! It is an G If you want something else printed by default besides the name of the constant, you can provide this value through a constructor: package enums; public enum Nucleotide { A(&quot;Adenine&quot;), C(&quot;Guanine&quot;), G(&quot;Cytosine&quot;), T(&quot;Thymine&quot;); private String name; private Nucleotide(final String fullName) { this.name = fullName; } @Override public String toString() { return name; } } Now, when you print an enum you will get its string value given via the constructor argument. Yes, this A(\"Adenine\") constructs a Nucleotide enum constant of type Nucleotide.A with “name” property “Adenine”. The reverse is also a much-used aspect: you have some string value and want to create an enum from it. This is how it’s done: String letter = &quot;G&quot;; Nucleotide nuc = Nucleotide.valueOf(letter); System.out.println(&quot;nuc = &quot; + nuc); This will output nuc = Guanine This valueOf() call returned the Nucleotide.G constant. Note it will not be created, since only one instance will exist during your app life cycle. When you use a non-existing value you get an IllegalArgumentException: letter = &quot;P&quot;; nuc = Nucleotide.valueOf(letter); This will output Exception in thread \"main\" java.lang.IllegalArgumentException: No enum constant enums.Nucleotide.P at java.lang.Enum.valueOf(Enum.java:238) at enums.Nucleotide.valueOf(Nucleotide.java:11) at enums.EnumDemo.start(EnumDemo.java:41) at enums.EnumDemo.main(EnumDemo.java:19) This is already pretty neat, yes? And we’re only just getting started! Let’s add some functionality. First something simple: provide access to the nucleotides’ molecular weight. I’ll use a HashMap to store these values and define a simple method that serves them. //rest of class omitted private static final HashMap&lt;Nucleotide, Double&gt; MOLECULAR_WEIGHTS; /** * static initializer to populate the map. */ static { MOLECULAR_WEIGHTS = new HashMap&lt;&gt;(); MOLECULAR_WEIGHTS.put(A, 313.2); MOLECULAR_WEIGHTS.put(C, 304.2); MOLECULAR_WEIGHTS.put(G, 329.2); MOLECULAR_WEIGHTS.put(T, 304.2); } /** * returns the molecular weight of this nucleotide in single-stranded DNA, in Daltons. * @return molecularWeight */ public double getMolecularWeight() { return MOLECULAR_WEIGHTS.get(this); } //rest of class omitted See how you can use the reference to this to fetch the molecular weight? Here are two lines using this functionality: System.out.println(&quot;nuc A weight = &quot; + nucA.getMolecularWeight()); System.out.println(&quot;nuc C weight = &quot; + Nucleotide.C.getMolecularWeight()); But how about the complements of these values (you know, the letter on the other strand of DNA in the double helix, the one it pairs with)? “A” has as complement “T”, “G” has “C” etc. I want to be able to get a complement for all nucleotides, given its original value. Exactly the same as the molecular weights, but the value is another nucleotide. Still this is not the whole story. The piece de resistance has yet to come. As you may know, there is another nucleotide that does not occur in DNA but solely in RNA: U (Uracil). DNA has A, C, G and T while RNA has A, C, G, and U. Thus, U replaces T in RNA. I want to add that one to my Nucleotide enum, and also provide a method that will tell me whether a nucleotide only occurs in RNA. I could simply provide a map for that, but this is not as efficient (or cool) as another solution. In fact, ONLY the U is exclusive for RNA. Therefore, I could provide some default functionality and override that behavior for Uracil. //rest of enum omitted A(&quot;Adenine&quot;), C(&quot;Guanine&quot;), G(&quot;Cytosine&quot;), T(&quot;Thymine&quot;), U(&quot;Uracil&quot;) { /*yes! a CONSTANT-SPECIFIC CLASS BODY!*/ @Override public boolean isExclusiveRNA() { //override for single RNA nucleotide return true; } }; //rest of enum omitted /** * returns whether this nucleotide is only found in RNA. * * @return isExclusiveRNA */ public boolean isExclusiveRNA() { //the default value return false; } //rest of enum omitted This is an example of a constant-specific class body, something only certified Java programmers seem to know about. And now you do, too. Its purpose is to provide an override for some generic functionality that applies to most of the other constants of the enum. Below follows the complete code of the enum. Of course, there is at least one major flaw in the model with respect to adherence to molecular biology – there awaits eternal fame for you if you find it. package enums; import java.util.HashMap; public enum Nucleotide { A(&quot;Adenine&quot;), C(&quot;Guanine&quot;), G(&quot;Cytosine&quot;), T(&quot;Thymine&quot;), U(&quot;Uracil&quot;) { /*yes! a CONSTANT-SPECIFIC CLASS BODY!*/ @Override public boolean isExclusiveRNA() { return true; } }; private static final HashMap&lt;Nucleotide, Double&gt; MOLECULAR_WEIGHTS; private static final HashMap&lt;Nucleotide, Nucleotide&gt; REVERSE_COMPLEMENTS; static { //MOL WEIGHTS MOLECULAR_WEIGHTS = new HashMap&lt;&gt;(); MOLECULAR_WEIGHTS.put(A, 331.2); MOLECULAR_WEIGHTS.put(C, 307.2); MOLECULAR_WEIGHTS.put(G, 347.2); MOLECULAR_WEIGHTS.put(T, 322.2); MOLECULAR_WEIGHTS.put(T, 324.2); //REV COMPLS REVERSE_COMPLEMENTS = new HashMap&lt;&gt;(); REVERSE_COMPLEMENTS.put(A, T); REVERSE_COMPLEMENTS.put(C, G); REVERSE_COMPLEMENTS.put(G, C); REVERSE_COMPLEMENTS.put(T, A); REVERSE_COMPLEMENTS.put(U, A); } public double getMolecularWeight() { return MOLECULAR_WEIGHTS.get(this); } public Nucleotide complement() { return REVERSE_COMPLEMENTS.get(this); } public boolean isExclusiveRNA() { return false; } private final String name; private Nucleotide(final String fullName) { this.name = fullName; } @Override public String toString() { return name; } } "],["encapsulation-revisited.html", "Chapter 26 Encapsulation revisited", " Chapter 26 Encapsulation revisited In this post, I want to revisit one of the most basic of Object Oriented Programming (OOP) concepts: encapsulation. It is a principle my students often fail to see the use for. And I must admit some of my colleagues as well – especially those who are really into Python. They are of the opinion that NOTHING should be hidden. Just be careful when programming. Well, my response is: some people also argue that Evolution is just a theory that you can simply disagree with! So what does encapsulation exactly mean? My good friend Wikipedia tells me that “It allows selective hiding of properties and methods in an object by building an impenetrable wall to protect the code from accidental corruption“. Key here is the word corruption of course. Let’s look at an example in code. Note: of course there are Javadoc comments missing, and some other issues with the code can be discussed, but I have taken the liberty to keep things simple for the purpose of demonstrating encapsulation. Here is class SequenceManager, the main class of a GUI application managing biological sequences: package encapsulation; public final class SequenceManager { public static void main(final String[] args) { SequenceManager mainObject = new SequenceManager(); mainObject.start(); } private void start() { SequenceCollection sc = new SequenceCollection(); sc.addSequence(new Sequence(&quot;Gene 1&quot;, &quot;GAATTC&quot;, &quot;gi|12345&quot;)); sc.addSequence(new Sequence(&quot;Gene 2&quot;, &quot;GAATTC&quot;, &quot;gi|98765&quot;)); MyCoolGUIPanel guiPanel = new MyCoolGUIPanel(sc); guiPanel.showSequenceCollection(); //also add to other panels of the GUI } } Nothing funny going on here. A SequenceCollection is created and stocked (of course, in real life this will come from some file or database), and subsequently passed to some GUI panels for displaying and managing. The Sequence class looks quite like any POJO you will ever meet: package encapsulation; public class Sequence { private String name; private String sequence; private final String id; public Sequence(String name, String sequence, String id) { this.name = name; this.sequence = sequence; this.id = id; } public Sequence(String name, String id) { this.name = name; this.id = id; } public String getName() { return name; } public void setName(String name) { this.name = name; } public String getSequence() { return sequence; } public void setSequence(String sequence) { this.sequence = sequence; } public String getId() { return id; } } The only noteworthy thing here is the omission of a setter for the Sequence ID, and the id member being final (often a good choice for identifiers of bean objects). Now, the collection class managing our sequences: package encapsulation; import java.util.HashMap; public class SequenceCollection { private HashMap&lt;String, Sequence&gt; sequences; /** * constructor instantuiates the collection */ public SequenceCollection() { this.sequences = new HashMap&lt;&gt;(); } /** * adds a sequence to the collection * @param seq */ public void addSequence(Sequence seq) { this.sequences.put(seq.getId(), seq); } /** * getter for the sequence hash * @return sequences */ public HashMap&lt;String, Sequence&gt; getSequences() { return this.sequences; } } This class contains the origin of a world of pain. The class seems to be simple enough, providing a method to add a sequence and a getter offering a ways to iterate over the collection. Can you see why this is the origin of a world of pain? No? Let’s have a look at the GUI JPanel displaying some aspect of this collection (yes I know swing is becoming a bit outdated for GUIs). package encapsulation; import javax.swing.JPanel; public class MyCoolGUIPanel extends JPanel{ private SequenceCollection seqColl; public MyCoolGUIPanel(SequenceCollection sc) { this.seqColl = sc; } public void showSequenceCollection() { /* * panel logic here */ } private void removeButtonClicked(String seqID) { //the remove sequence button was clicked so a sequence is removed seqColl.getSequences().remove(seqID); } } So what happens when somebody decides to remove a sequence from the collection? The getter on the SequenceCollection object is called to access the underlying Collection class, and the wretched object is removed. WITHOUT ANYONE ELSE BEING AWARE OF THIS! Other JPanels, the SequenceCollection object itself – nobody knows a Sequence object has met its maker! Having a getter offering access to a Collection like what we have seen in the SequenceCollection class and the HashMap is like dropping your bank card onto the floor of a bar with the pin code written on the back. You can bet somebody is going to take the invitation to trash your account. So what is the solution? Exactly, encapsulate your inner workings. There are several simple ways to do this. Here is the simplest one: public Map&lt;String, Sequence&gt; getSequences() { return Collections.unmodifiableMap(sequences); } The Javadocs have this to say about the Collections.unmodifiableMap method: “Returns an unmodifiable view of the specified collection. This method allows modules to provide users with “read-only” access to internal collections. Query operations on the returned collection “read through” to the specified collection, and attempts to modify the returned collection, whether direct or via its iterator, result in an UnsupportedOperationException.” So this line seqColl.getSequences().remove(seqID); will throw such an Exception. What I like slightly better through is an iterator: public Iterator&lt;Sequence&gt; getSequenceIterator() { return this.sequences.values().iterator(); } Or, when you really want to have the joy of the Java for(each) loop: public List&lt;Sequence&gt; getSequenceList() { return new ArrayList&lt;Sequence&gt;(this.sequences.values()); } All these strategies will keep your data safe, but the last two also hide the inner workings of your SequenceCollection class so these should be preferred. "],["design-rules-summary.html", "Chapter 27 Design rules summary 27.1 equals() and hashCode() 27.2 Classes 27.3 Code against interfaces, not implementations 27.4 Exceptions 27.5 Access modifiers 27.6 SRP 27.7 Various", " Chapter 27 Design rules summary 27.1 equals() and hashCode() Always implement equals() and hashCode(), when objects are going to live in collections (which is quite often!) Always implement both equals and hashCode; never only one! And have your IDE generate it for you… 27.2 Classes When a class defines an instance variable that needs to be initialized in order to have an object that makes sense, and you can not give it a reasonable default value, you should make it a constructor parameter Consider the use of factory methods instead of constructors Make classes abstract that should not be instantiated Chain constructors using this(fieldValue, fieldValue) 27.3 Code against interfaces, not implementations Use interfaces and abstract classes as the declared type of your variables. That way, implementation details may change without serious repercussions. 27.4 Exceptions Never let exceptions pass silently Deal with exceptions at an appropriate location Nowadays, the trend is to prefer unchecked exceptions over checked exceptions (see discussion at http://www.yegor256.com/2015/07/28/checked-vs-unchecked-exceptions.html) Never ever try to catch an Error 27.5 Access modifiers Minimize the accessibility of class members(fields, methods, member classes). Use getters and setters to intercept and control access to fields. Changing public API methods is almost impossible since it will create backward incompatibility. 27.6 SRP A module, class or method should have one, and only one, reason to change. Alternative description: every module, class, or function should have responsibility over a single part of the functionality, and that responsibility should be entirely encapsulated by the class 27.7 Various Prefer enums to define a static set of possible values for a given property above public static final constants Always put Java classes in well-defined packages with a correct name structure "],["a-refresher.html", "Chapter 28 A refresher 28.1 Introduction 28.2 The basics of web", " Chapter 28 A refresher 28.1 Introduction Here starts the contents of the course Web-based Information Systems. In this course, we will investigate the power of dynamic web pages using server-side and client-side technology, and the ways they interact Before embarking on the technological aspects of web app development, some very useful guidelines should be taken in \\(source: PLoS Computational Biology, Volume 7, Issue 5\\). Plan Your Resource Discuss Responsibilities Know Your User Base Use Services Available to You during Development Ensure Portability Create an Open Source Project Provide Ample Documentation and Listen to Feedback Facilitate Reproducibility Plan Ahead: Long-Term Maintenance Switch off an Unused Resource 28.2 The basics of web When you click a simple link in a web page (the client), you request a resource. The web server receives the request, locates the resource and returns something to the user: a response. Request and Response The client The client (usually a web browser) formats a request and sends it to the server. The client receives the response and processes it when the response is html, the response is rendered by the browser into a web page view. The server The server receives the request, locates the correct resource and formats the response before sending it to the client. The server can not: - save anything - generate dynamic content - remember you or your previous requests These tasks have to be delegated Request types Http requests come in 7 flavors. In 99.99999% of the use cases, it will be one of these two: - get a simple resource fetch request - post a request that sends data to the server or requests to change its data There are others, not often used and not always supported because of security issues: - delete - head - options - put - trace We will deal only with the first two. A simple html request form Below you see a very simple html request form. The request will be send to /birdpic on the root of the current application context. &lt;html&gt; &lt;head&gt; &lt;title&gt;a page with a form&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;request bird pictures&lt;/h1&gt; &lt;form action=&quot;birdpic&quot;&gt; Species name: &lt;input type=&quot;text&quot; name=&quot;species&quot;&gt; &lt;br /&gt; Minimum rating: &lt;input type=&quot;text&quot; name=&quot;rating&quot;&gt; &lt;br /&gt; &lt;input type=&quot;submit&quot; value=&quot;find&quot;&gt; &lt;/form&gt; &lt;/body&gt; &lt;/html&gt; The form will be rendered into the page below. Note that with the absence of a method=... attribute to the form tag, it will default to GET. A request form A GET request Filling out the form and clicking find generates this location (URL) in your browsers’ location bar (only with GET requests). Request URL An http GET request will be formed, looking like this: GET ~michiel/WebBased/birdpic?species=Roodborst&amp;rating=4 HTTP/1.1 Host: www.bioinf.nl User-Agent: Mozilla/5.0(...) Accept: text/xml.application/xml,(...) Accept-Language: en-us,en;q=0.5 Accept-Encoding: gzip,deflate Accept-Charset: ISO-8859-1,utf-8,q=0.7,*;q=0.7 Keep-Alife: 300 Connection: keep-alife You can look at this request with for instance you web browsers developer toolbox (discussed later). Note that the parameters of your request have been put at the top of the request. Some other parameters have been added as well, as key: value pairs. A POST request Adding the method=POST attribute to the &lt;form&gt; tag, &lt;form action=&quot;birdpic&quot; method=&quot;POST&quot; &gt; Species name: &lt;input type=&quot;text&quot; name=&quot;species&quot;&gt; Minimum rating: &lt;input type=&quot;text&quot; name=&quot;rating&quot;&gt; &lt;input type=&quot;submit&quot; value=&quot;find&quot;&gt; &lt;/form&gt; will make the url-appended parameters disappear, Request URL And the parameters are now located at the end of the http request: POST ~michiel/WebBased/birdpic HTTP/1.1 Host: www.bioinf.nl User-Agent: Mozilla/5.0(...) Accept: text/xml.application/xml,(...) Accept-Language: en-us,en;q=0.5 Accept-Encoding: gzip,deflate Accept-Charset: ISO-8859-1,utf-8,q=0.7,*;q=0.7 Keep-Alife: 300 Connection: keep-alife species=Roodborst&amp;rating=4 The HTTP response The response coming back from the server will look like this: HTTP/1.1 200 OK Set-Cookie: JSESSIONID=0AAB6CGSTGGC56DS3FF78; Path=/WebBased Content-Type: text/html Content-Length: 397 Date: Sun, 9 Nov 2018 02:50:40 CET Server: Apache-Coyote/1.1 Connection: close &lt;html&gt; &lt;head&gt; ... &lt;/html&gt; At the top, there is the HTTP response header with a status code (200 / OK), a cookie and other important information about the response. Below the header is the HTTP response body, with the HTML that the browser is going to display. GET or POST? Use GET for (simple) requests that do not alter the data on the server side. These are called idempotent because they can be made over and over again without any effect on the server. Use POST for complex requests and requests that alter the data on the server side, and always if you are going to send sensitive data (passwords, usernames). The URL URL stands for Uniform Resource Locator. Every web resource has its own unique address in the URL format: http://www.bioinf.nl:80/WebBased/index.hml http:// protocol www.bioinf.nl server :80 TCP port /WebBased/ path index.hml resource If you don’t specify a port, it will default to the HTTP port which is 80. TCP ports The TCP port is a 16-bit number that identifies a specific software program on the server hardware. A server can have up to 65536 different server apps running TCP port numbers from 0 to 1023 are reserved for well-known services: - 21 FTP (file transfer protocol) - 22 SSH (secure shell) - 25 SMTP (mail) - 80 HTTP (Hypertext Transfer Protocol) - 443 HTTPS Don’t use these ports for your own server programs! Tomcat usually runs on port 8080 Static versus dynamic content Web servers can ONLY serve static content (html pages, pictures, xml documents etc). If you want dynamic content, you have to delegate this to another application. A web server can’t help you with this: &lt;html&gt; &lt;body&gt; The current time is [insertTimeOnServer] &lt;/body&gt; &lt;/html&gt; Non-Java programs that can do this are often called CGI (Common Gateway Interface) scripts. Examples of languages used to write these are Perl, PHP, Python etc This is a PHP script printing current time: &lt;html&gt; &lt;body&gt; The current time is &lt;?php //Prints something like: Wednesday 29th of May 2019 03:12:46 PM echo date(&#39;l jS \\of F Y h:i:s A&#39;); ?&gt; &lt;/body&gt; &lt;/html&gt; Why use Java? Although Java is more of a fuss to get up and running, it is much better in serving heavy-duty analysis tools. If you want a simple interface with forms accessing database data and presenting them, use Python. If you want a real analysis tool running behind a web application, use Java But always… Always separate the responsibilities of the view, the data and the model! Avoid mixing html, styling, scripting, database access and application logic at all costs! This is the essence of the Model View Controller (MVC) design pattern (or paradigm). In this course, we’ll only skim the essence of this principle. Here is a schematic representation of the top-level application components and how they should interact - and be separated. The MVC pattern MVC can be applied on different levels - at the server for whole-application architecture (Servlet control – Thymeleaf view – Java model) - In a single web page DOM element: A Form HTML/css view, its Javascript controller and a Javascript model (vue.js has this principle at its core). “old” versus “modern” web apps In the old days, almost every action or resource requested from the server resulted in a completely new page. Now, single-page web apps are becoming the standard. The key to this is Javascript and Ajax: it lets you load and update only those parts of the page where this is required. Also, Javascript can take a LOT of logic away from the server "],["the-toolbox.html", "Chapter 29 The toolbox", " Chapter 29 The toolbox Intro These are the tools we are going to use to build our dynamic web applications: Java: plain old Java to build the logic Java EE: The enterprise edition - an extension that has web apis, including Servlets. Thymeleaf: A very nice templating technology for Java web pages Tomcat: a container where the Java web apps live Of course, you will also need (knowledge of) Javascript: client-side scripting language to manipulate the view, and in particular jQuery: a Javascript library/platform for performing many tasks that are pretty hard to implement using raw Javascript css (cascading style sheets): to style the view but these will not be dealt with in this course. The tools Java development kit Download and install from Oracle. The Tomcat application server To start working with Java web technology, you have to get a server runtime. We’ll use Tomcat. To install it: - go to apache tomcat and download the latest version - extract it in a suitable location - make the bin/*.sh file executable - To test, start up Tomcat using - ./tomcat.../bin/startup.sh - direct your browser to http://localhost:8080/ and you should see the Tomcat management page. IntelliJ Ultimate This course uses IntelliJ, but for your own endeavors you are of course free to use another IDE. A MySQL server A MySQL server and account. Installing and administering this is not in the scope of this course. Also, MySQL as query language is assumed to be known. Debugging web sites All modern browsers have extensive debugging support. Do not use the JavaScript function alert(\"my debug message\") but intead use console.log(\"my debug message\")! Use the context menu option “Inspect element” in the browser: Inspect elements Use the inspector to investigate, change and track DOM structure, bugs, network traffic, styling information, print info from JavaScript, change JavaScript variables. Codepen Use Codepen for testing snippets: Codepen "],["a-first-project-1.html", "Chapter 30 A first project 30.1 Introduction 30.2 The steps", " Chapter 30 A first project 30.1 Introduction The topic of this presentation is getting started with a Java web application using a Thymeleaf View that serves an internationalized welcome message. Since JSP and not Thymeleaf is the default for basic Java web applications, this involves quite a few steps: configuring IntelliJ with the application server Tomcat creating a Gradle-managed web project creating a Thymeleaf template configuring the use of Thymeleaf creating a servlet running the web application In this post, I’ll show you how to get started with a basic project that supports internationalization. Prerequisites Tomcat. I assume you have a working version of Tomcat server (see http://tomcat.apache.org/). This blog uses Tomcat 9.0.13. Simply extract the downloaded zip at a convenient location. Don’t forget to make the *.sh scripts in the bin folder executable! IntelliJ Idea. This blog uses the 2018.3 Ultimate version. Please refer to Jetbrains for educational licences. 30.2 The steps Configure Tomcat as webserver After installation (extraction) of Tomcat, you’ll have to let IntelliJ know where it is. You do this via Preferences → Build, Execution, Deployment → Application Servers → click ‘+’ (Add) Configure Tomcat Create a Gradle-managed web project Creating a Gradle-managed web project in IntelliJ: Choose File → New → Project Choose Gradle → + Java + Web → Next You see something like this: Create Gradle project 1 Enter GroupId, ArtifactId and Version and Click Next Create Gradle project 2 Check “Use auto-import” and “Use Gradle wrapper” and Click Next and Click Finish You will have something like this: Create Gradle project 3 Configure Gradle In this project, we’ll be using Thymeleaf and JUnit5 (and the Servlet API). Since they are not readily available in Java, you’ll need to configure your projects’ dependencies. Fortunately, Gradle is an excellent tool for dependency management. Here is the contents of a basic build.gradle configuration file: plugins { id &#39;java&#39; id &#39;war&#39; id &#39;idea&#39; } group &#39;nl.bioinf.wis_thymeleaf&#39; version &#39;0.0.1&#39; sourceCompatibility = 1.8 repositories { mavenCentral() } dependencies { //Servlets compile &#39;javax.servlet:javax.servlet-api:3.1.0&#39; //Thymeleaf compile &#39;org.thymeleaf:thymeleaf:3.0.11.RELEASE&#39; //JUnit5 testImplementation &#39;org.junit.jupiter:junit-jupiter-api:5.1.0&#39; testRuntimeOnly &#39;org.junit.jupiter:junit-jupiter-engine:5.1.0&#39; } The WEB-INF folder Under web-app, create a folder called WEB-INF and within that one a folder called templates. Within templates, create the html file called welcome.html. Create WEB-INF Your file welcome.html should have this contents: &lt;!DOCTYPE html SYSTEM &quot;http://www.thymeleaf.org/dtd/xhtml1-strict-thymeleaf-4.dtd&quot;&gt; &lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot; xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt; &lt;head&gt; &lt;title&gt;Thymeleaf Starter&lt;/title&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot; /&gt; &lt;/head&gt; &lt;body&gt; &lt;!-- welcome message read from resource bundle welcome.html--&gt; &lt;p th:text=&quot;#{welcome.msg}&quot;&gt;Welcome Offline&lt;/p&gt; &lt;!-- date forwarded from the servlet--&gt; &lt;p&gt;Date: &lt;span th:text=&quot;${currentDate}&quot;&gt;Sat Oct 24 2015&lt;/span&gt;&lt;/p&gt; &lt;/body&gt; &lt;/html&gt; There are several non-html syntax elements that make this page special: #{...} and ${...} and the Thymeleaf tag attributes th:text. #{...} fetches the value from the resource bundle (files named xxxxx.properties). The expression #{welcome.msg} gets the value of key welcome.msg from the file welcome_xx.properties. The expression ${...} fetches the value set in the WebContext instance. The expression ${currentDate} gets the value for the attribute currentDate set in WebContext. Much more on this later. Other than that, this is a plain old html file. You can open it in any browser and it will show you the non-processed view. This is what makes Thymeleaf so nice; you can develop the view of your app without using servers or template engines! Create a resource bundle A resource bundle is where you store your application texts. Instead of creating web pages for every language you are willing to support, you create text-free web pages and store the texts for the different languages in separate files called resource bundles. This is how you add language support to your web app: Right-click the templates folder, select New → Resource Bundle → Type welcome as base name → Click ‘+’ under ‘Locales to add’ and add ‘en’ → Click OK Create Resource bundle 1 The resource bundle will open in your editor. It has plain text view and “resource bundle” view. Choose the latter. Click ‘+’ to add a new Property key and name it welcome.msg. Create Resource bundle 2 Give some Dutch (or other language of course) and English values for welcome.msg. Create Resource bundle 3 Now you have internationalized your view. Prepare to use Thymeleaf Thymeleaf needs some configuration to get going. Here is some boilerplate code you can simply copy-and-paste. Under main/java, create a base package, e.g. &lt;your_._domain&gt;.&lt;your_name&gt;.&lt;your_project&gt;. Within it, create two additional packages: config and servlets. Under config, create a new Java class file WebConfig.java. Put this code in there: package nl.bioinf.wis_on_thymeleaf.config; import org.thymeleaf.TemplateEngine; import org.thymeleaf.templateresolver.ServletContextTemplateResolver; import javax.servlet.ServletContext; import javax.servlet.http.HttpServletResponse; public class WebConfig { public static TemplateEngine createTemplateEngine(ServletContext servletContext) { ServletContextTemplateResolver templateResolver = new ServletContextTemplateResolver(servletContext); templateResolver.setTemplateMode(&quot;XHTML&quot;); templateResolver.setPrefix(&quot;/WEB-INF/templates/&quot;); templateResolver.setSuffix(&quot;.html&quot;); templateResolver.setCacheTTLMs(3600000L); // Cache is set to true by default. // Set to false if you want templates to be automatically // updated when modified. templateResolver.setCacheable(true); TemplateEngine templateEngine = new TemplateEngine(); templateEngine.setTemplateResolver(templateResolver); return templateEngine; } /** * Configures the response in a standard way. * @param response */ public static void configureResponse(HttpServletResponse response) { response.setContentType(&quot;text/html;charset=UTF-8&quot;); response.setHeader(&quot;Pragma&quot;, &quot;no-cache&quot;); response.setHeader(&quot;Cache-Control&quot;, &quot;no-cache&quot;); response.setDateHeader(&quot;Expires&quot;, 0); } } The main role of this class is to provide a template engine. This is the piece of the application responsible for processing the Thymeleaf templates into html views. To do this, the template engine needs to know -amongst other things- where these templates are. That is the responsibility of the TemplateResolver. Create a Servlet Finally, everything is going to fall into place. Under package ....servlets, create a new Servlet class with this contents: package nl.bioinf.wis_on_thymeleaf.servlets; import nl.bioinf.wis_on_thymeleaf.config.WebConfig; import org.thymeleaf.context.WebContext; import javax.servlet.ServletContext; import javax.servlet.ServletException; import javax.servlet.annotation.WebServlet; import javax.servlet.http.HttpServlet; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import java.io.IOException; import java.util.Date; @WebServlet(name = &quot;WelcomeServlet&quot;, urlPatterns = &quot;/welcome&quot;, loadOnStartup = 1) public class WelcomeServlet extends HttpServlet { @Override public void init() throws ServletException { System.out.println(&quot;Initializing Thymeleaf template engine&quot;); final ServletContext servletContext = this.getServletContext(); WebConfig.createTemplateEngine(servletContext); } private static final long serialVersionUID = 1L; public void doPost(HttpServletRequest request, HttpServletResponse response) throws IOException{ process(request, response); } public void doGet(HttpServletRequest request, HttpServletResponse response) throws IOException{ process(request, response); } public void process(HttpServletRequest request, HttpServletResponse response) throws IOException { //this step is optional; standard settings also suffice WebConfig.configureResponse(response); WebContext ctx = new WebContext( request, response, request.getServletContext(), request.getLocale()); ctx.setVariable(&quot;currentDate&quot;, new Date()); WebConfig.createTemplateEngine(getServletContext()). process(&quot;welcome&quot;, ctx, response.getWriter()); } } Of course, the package declarations will be different, as well as the first import statement. The alert reader may notice that this will create a TemplateEngine for each single servlet. This is probably not the very best strategy, but for simplicity, we’ll stick to it for now. Have a look at the Demo repo for a final solution with the template resolver. Finally: run it Create a new run configuration (it’s in the top bar) and point it to http://localhost:8080/welcome. Run the Application 1 Next, crank up your browser, and I hope you’ll see something like this: Run the Application NL Go to chrome://settings/languages and change your language to English, refresh the view of your welcome page and you’ll see this: Run the Application EN That’s it. It was quite some work, but this is the foundation for a nice basic Java + Thymeleaf driven web application. "],["implementing-mvc.html", "Chapter 31 Implementing MVC 31.1 Introduction 31.2 Java web app architecture", " Chapter 31 Implementing MVC The topic of this post is setting up a clean “MVC“ Java web application. This involves working with separated components for different responsibilities. Besides the Model, the View and the Controller, this post also deals with the Data Layer, a fourth component that is almost always a part of a web app. 31.1 Introduction The Components a.k.a Layers The components -or layers- of an MVS application are generally recognized in most applications, web-based or not: Model: the business-specific logic, model classes, domain-specific algorithms View: what the user gets to see, often the visual representation of the underlying data Controller: receives input or requests (from the user) and determines what action should be taken; what part of the model should be invoked Data layer: all data is abstracted away behind data access objects (DAOs) Create WEB-INF The goal: a random phrase of the day The specs: a web app that will display a phrase, chosen randomly from one of two categories: Bullshit or Management. This post assumes you already have created a new Gradle-managed web app - see post First Project 31.2 Java web app architecture Java web apps are managed by servers, also called containers. We work with Tomcat, but the idea is the same for all. Tomcat receives requests and forwards these to specific entry points in your app. These entry points are not main() methods as in Commandline apps, but the service methods of Servlets: void doGet(HttpServletRequest request, HttpServletResponse response) and doPost(HttpServletRequest request, HttpServletResponse response). Also, unlike commandline apps that receive their arguments via the String[] args argument to main(), the service methods receive HttpServletRequest and HttpServletResponse objects as their communication channels to the outside world: the request object is the way in and the response object is the connection out. Besides these objects, there is the HttpSession object supporting “cross-request memory”, and the ServletContext object that you use for application-wide configuration settings. And throughout the app, Plain Old Java Objects (POJOs) serve as data carriers - the glue of the app. Here is a schema of an entire app. Java web app architecture A View To create a Thymeleaf template, right-click on folder webapp/templates, select New → html. (Hint: you can also make your own Thymeleaf template!) Name it phrase_of_the_day.html and click OK The file will automatically open in an editor window, with some standard template code already present. Here is the contents of phrase_of_the_day.html &lt;!DOCTYPE html SYSTEM &quot;http://www.thymeleaf.org/dtd/xhtml1-strict-thymeleaf-4.dtd&quot;&gt; &lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot; xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt; &lt;head&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot; /&gt; &lt;title th:text=&quot;#{tab.title}&quot;&gt;_offline_&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h3 th:text=&quot;#{page.title}&quot;&gt;Offline title&lt;/h3&gt; &lt;h4 th:text=&quot;#{page.subtitle}&quot;&gt;Offline subtitle&lt;/h4&gt; &lt;form action=&quot;give.phrase&quot; method=&quot;GET&quot;&gt; &lt;select name=&quot;phrase_category&quot;&gt; &lt;option value=&quot;bullshit&quot;&gt;Bullshit&lt;/option&gt; &lt;option value=&quot;management&quot;&gt;Management&lt;/option&gt; &lt;/select&gt; &lt;input type=&quot;submit&quot; th:value=&quot;#{get.phrase.btn}&quot; value=&quot;_offline_&quot;/&gt; &lt;/form&gt; &lt;h4 th:text=&quot;#{&#39;phrase.&#39; + ${phrase_num}}&quot;&gt;_phrase placeholder_&lt;/h4&gt; &lt;/body&gt; &lt;/html&gt; Note the text have been moved to a resource bundle. Within the editor pane, click the icon of the browser you want to view the file in (the browser icons are in the top right corner). Do not select “Run phrase_of_…” from the context menu because you will get a 404! Phrase request form You won’t get any texts into the placeholders because (1) there simply aren’t any and (2) you are viewing a static html page, not a view that is processed by the template engine. Create resource bundle The resource should have as base name phrase_of_the_day and should have a default and ‘en’ locale versions. You also need entries for the used texts, of course Phrase of the day resource bundle A model Create a new package called model. Give it some dummy implementation (we’ll put some real code in there later on). public class PhraseFactory { public static String getPhrase(String phraseType) { //we&#39;ll get to this later! //You thought I’d return some text here, didn’t you? return &quot;1&quot;; } } A controller Create a new Servlet and put the following code in there. package nl.bioinf.wis_on_thymeleaf.servlets; //many imports @WebServlet(name = &quot;PhraseServlet&quot;, urlPatterns = &quot;/give.phrase&quot;) public class PhraseServlet extends HttpServlet { private TemplateEngine templateEngine; @Override public void init() throws ServletException { this.templateEngine = WebConfig.getTemplateEngine(); } protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { String phraseType = request.getParameter(&quot;phrase_category&quot;); Locale locale = request.getLocale(); WebContext ctx = new WebContext( request, response, request.getServletContext(), locale); if (phraseType != null) { final String phrase = PhraseFactory.getPhrase(phraseType); ctx.setVariable(&quot;phrase_type&quot;, phraseType); ctx.setVariable(&quot;phrase_num&quot;, phrase); } else { ctx.setVariable(&quot;phrase_type&quot;, &quot;none&quot;); ctx.setVariable(&quot;phrase_num&quot;, &quot;0&quot;); } templateEngine.process(&quot;phrase_of_the_day&quot;, ctx, response.getWriter()); } } The controller receives request parameters from the submitted form using String requestParameter = request.getParameter(\"&lt;parameter_name&gt;\");. On the output side, it passed data to the Thymeleaf template using ctx.setVariable(\"&lt;variable_name&gt;\", &lt;variable&gt;);. It is not responsible for any application logic; for that it calls on the model class PhraseFactory. The controller does not involve itself with the view either; it simply passes the data it received from the model to the View component, the Thymeleaf template phrase_of_the_day.html. Test! Create a new run configuration called “phrase” and point it to give.phrase. Test the result; try the form submit; change your language; refresh Phrase request form 2 Phrase request form 3 Extend the model Implement some nice behavior in PhraseFactory.java. First the Junit5 test and only then the implementation: this is called Test-Driven Development (TDD). class PhraseFactoryTest { @Test void getPhrase() { for (int i=0; i&lt;50; i++) { int random = Integer.parseInt(PhraseFactory.getPhrase(&quot;bullshit&quot;)); assertTrue(random &gt;= 1 &amp;&amp; random &lt;= PhraseFactory.MAX_PHRASE_COUNT); } for (int i=0; i&lt;50; i++) { int random = Integer.parseInt(PhraseFactory.getPhrase(&quot;management&quot;)); assertTrue(random &gt;= 1 &amp;&amp; random &lt;= PhraseFactory.MAX_PHRASE_COUNT); } } } The implementation. public class PhraseFactory { public static int MAX_PHRASE_COUNT = 4; public static String getPhrase(String phraseType) { //I only have 4 phrases of each category Random rand = new Random(); int phraseIndex = rand.nextInt(MAX_PHRASE_COUNT) + 1; return Integer.toString(phraseIndex); } } Now fetch the phrases a little bit sophisticated. Here is the relevant part of the Thymeleaf template. &lt;h4 th:text=&quot;#{&#39;phrase.&#39; + ${phrase_type} + &#39;.&#39; + ${phrase_num}}&quot;&gt;_phrase placeholder_&lt;/h4&gt; This snippet is building a reference to a randomly chosen phrase from the requested category. In the resource bundle, the phrases are stored in two languages. Phrase of the day resource bundle 2 MVC complete Thats it; you have seen the MVC pattern in action. There is a dedicated model class that knows how to provide a random choice for messages. The Servlet controller invokes the model (PhraseFactory) and dispatches its output to the view. The Thymeleaf template handles the view, processed by the template engine that is also responsible for injecting the text messages from the resource bundle, in the correct language. Thymeleaf has several techniques to deal with dynamic content generated by the model; this is the subject of the next post. MVC pattern (extended) "],["thymeleaf-expressions.html", "Chapter 32 Thymeleaf expressions 32.1 Introduction 32.2 Expression types", " Chapter 32 Thymeleaf expressions 32.1 Introduction This post is one of a series on Thymeleaf. It deals with some of the essential templating techniques that Thymeleaf offers: using texts implicit objects (predefined variables) variables (of the context/model) urls/links attributes available for templating For a complete overview you should refer to the official docs. 32.2 Expression types 32.2.1 Resource expressions: #{} Using the #{message.in.resource.bundle} expression will make the template engine look in your resource bundle(s) for internationalized messages with the given key. In its most basic form it works as follows. This expression: &lt;h3 th:text=&quot;#{page.title}&quot;&gt;_offline_&lt;/h3&gt; combined with this property in a resource bundle page.title=get your phrase-of-the-day will evaluate to &lt;h3&gt;get your phrase-of-the-day&lt;/h3&gt; Unescaped text The Thymeleaf attribute th:text ‘escapes’ the text in the message. If you want this message: favourite=Thymeleaf is my &lt;b&gt;favourite&lt;/b&gt; templating engine! to display correctly, you should use th:utext: &lt;h3 th:utext=&quot;#{page.title}&quot;&gt;_offline_&lt;/h3&gt; So you’ll get this &lt;p&gt;Thymeleaf is my &lt;b&gt;favourite&lt;/b&gt; templating engine!&lt;/p&gt; Instead of this &lt;p&gt;Thymeleaf is my &amp;lt;b&amp;gt;favourite&amp;lt;/b&amp;gt; templating engine!&lt;/p&gt; Messages with variables To insert variables into your messages, give the message identifier an argument, just like calling a function. Then, in the message “body”, catch it with {0}. Given this message animal=The {0} is the scariest animal there is! and this Thymeleaf &lt;p th:text=&quot;#{animal(&#39;black widow&#39;)}&quot;&gt;&lt;/p&gt; &lt;p th:text=&quot;#{animal(&#39;rattlesnake&#39;)}&quot;&gt;&lt;/p&gt; will process into &lt;p&gt;The black widow is the scariest animal there is!&lt;/p&gt; &lt;p&gt;The rattlesnake is the scariest animal there is!&lt;/p&gt; Of course, you should use Use {1}, {2} … for multiple variables. 32.2.2 Variable expressions: ${} Variables expressions is completely different from messages with variables - the previous section! Variable expressions query the WebContext, or other implicit objects to resolve these expressions. Usually, they will refer to objects you have attached to the WebContext object in the servlet request handling process. For example, this servlet code: WebContext ctx = new WebContext( request, response, request.getServletContext(), request.getLocale()); ctx.setVariable(&quot;warning&quot;, &quot;you must be over 18 to drive a car&quot;); templateEngine.process(&quot;thymeleaf_demo&quot;, ctx, response.getWriter()); With this Thymeleaf expression in thymeleaf_demo &lt;p th:text=&quot;${warning}&quot;&gt;_offline_&lt;/p&gt; will evaluate to &lt;p&gt; you must be over 18 to drive a car &lt;/p&gt; Thus, the warning attribute that was set on the WebContext object has been retrieved in the Thymeleaf template using the ${warning} expression. Using Java bean properties in expressions A Java bean is a special kind of class, coded according to a set of rules. That’s why you can use them so conveniently in Thymeleaf, without actually writing Java code. These are the JavaBean design rules: They provide a no-arg constructor ( e.g. public Person(){} ) They provide public standard-named getters and setters for class attributes; e.g. for String property name you must provide the methods public String getName(){return \"Fred\"} and public void setName(String name){}. A very important thing to realize is the class does not necessary have to have the actual property (private String name); only the getters and setters are required! Another thing to note is you are not required to provide a setter, as long as you don’t use it in your Thymeleaf templates. For example, here is a bean publishing the fullName property without actually having such a String variable internally: public class Person { private String firstName; private String lastName; public Person() { } public Person(String firstName, String lastName) { this.firstName = firstName; this.lastName = lastName; } public String getFullName() { return firstName + &quot; &quot; + lastName; } } When set on the context like this: ctx.setVariable(&quot;person&quot;, new Person(&quot;Judy&quot;, &quot;Steinberg&quot;)); and this template fragment &lt;span th:text=&quot;${&#39;The person currently logged in is &#39; + person.fullName}&quot;&gt;_offline_&lt;/span&gt; will give the processed html &lt;span&gt;The person currently logged in is Judy Steinberg&lt;/span&gt; Flexibility of ${} The ${} expression can be used in many ways; here are only a few: - Chaining of calls: ${object.property.property} - List access: ${list[1]} or ${list[${selected_index}]} - Map access: ${map['foo']} or ${map[${selected_item}].property} - Regular method calls: ${person.createCompleteNameWithSeparator('-')} - Combinations of expression types ```html &lt;h4 th:text=&quot;#{&#39;phrase.&#39; + ${phrase_type} + &#39;.&#39; + ${phrase_num}}&quot;&gt;_phrase_&lt;/h4&gt; ``` 32.2.3 Built-in-variable expressions: ${#} Thymeleaf provides quite a few predefined variables that can be accessed using ${#variableName} syntax. Here are some: variable purpose #locale the context locale. #httpServletRequest (only in Web Contexts) the HttpServletRequest object. Access via ${param.key} in Spring #dates utility methods for java.util.Date objects: formatting, component extraction, etc. #numbers utility methods for formatting numeric objects. #strings (or #objects, #bools, #arrays, #lists, #sets: utility methods for these objects Locales The ‘#locale’ helper can do things like this: Get the Language set on the clients’ browser: ${#locale.getLanguage()} will give nl on my browser. Get the Country set on the clients’ browser; it will be empty when not set: ${#locale.getCountry()} will give &lt;nothing&gt; on my browser. Get the display name of your locale set on your browser: ${#locale.getDisplayName()} : Dutch Dates and Calendars The ‘#dates’ and ‘#calendars’ variables help with everything related to dates. Here are some examples, with my_date, a java.util.Date object, set on the web context model: Expression Description Result ${my_date} the date Mon Jun 03 15:52:03 CEST 2019 ${#dates.format(my_date)} simple date formatting using default locale 3 juni 2019 15:52:03 CEST ${#dates.format(my_date, 'yyyy/mm/dd HH:mm')} advanced date formatting using format string 2019/52/03 15:52 ${#dates.formatISO(my_date)} ISO format 2019-06-03T15:52:03.981+02:00 Numbers The ‘#numbers’ implicit object helps with numbers. Given ‘my_date’ set on the web context model: ctx.setVariable(\"my_number\", 31415.9265359);, here is simple usage scenarios. ${my_number} gives “31415.9265359”, the exact representation of the context variable. ${#numbers.formatDecimal(my_number, 0, 'COMMA', 2, 'POINT')} gives “31,415.93”. The argument are as follows: #numbers.formatDecimal(&lt;target&gt;, &lt;mimimum integer digits&gt;, '&lt;thousandspoint type&gt;', &lt;decimal digits&gt;, &lt;decimalpoint type&gt;) Similarly, this expression ${#numbers.formatInteger(my_number, 10, 'POINT')} will produce “0.000.031.416”. The session object The session object is simply available as session. The expression ${session.user.email} will display the ‘email’ property of the User object registered as attribute on the ‘session’ object: session.setAttribute(\"user\", new User(\"Henk\", \"henk@example.com\", Role.USER)); will give “henk@example.com” The details of sessions are the topic of a separate post, however. 32.2.4 Locally scoped variables with *{} You can access the properties of a locally scoped object through the *{} syntax. This obviates the need for retyping the variable name over and over again. Given the User object of the session example, you can list its properties as follows: &lt;ul th:object=&quot;${session.logged_in_user}&quot;&gt; &lt;li&gt;Name: &lt;span th:text=&quot;*{name}&quot;&gt;_name_&lt;/span&gt;&lt;/li&gt; &lt;li&gt;Email: &lt;span th:text=&quot;*{email}&quot;&gt;_email_&lt;/span&gt;&lt;/li&gt; &lt;li&gt;Role: &lt;span th:text=&quot;*{role}&quot;&gt;_role_&lt;/span&gt;&lt;/li&gt; &lt;/ul&gt; Which will produce &lt;ul&gt; &lt;li&gt;Name: &lt;span&gt;Henk&lt;/span&gt;&lt;/li&gt; &lt;li&gt;Email: &lt;span&gt;henk@example.com&lt;/span&gt;&lt;/li&gt; &lt;li&gt;Role: &lt;span&gt;USER&lt;/span&gt;&lt;/li&gt; &lt;/ul&gt; 32.2.5 Creating links: @{} Using the @{} syntax, you can create links with a path that is relative to the deployment context. &lt;a th:href=&quot;@{/give.phrase(phrase_category=bullshit)}&quot; href=&quot;#&quot;&gt;get a bullshit phrase&lt;/a&gt; will give the following link: http://localhost:8080/give.phrase?phrase_category=bullshit. As you can see, you can add a request parameter as key=value pair. For multiple key=value pairs, separate them by comma’s: @{/give.phrase(phrase_category=bullshit,action=nothing)} gives http://localhost:8080/give.phrase?phrase_category=bullshit&amp;action=nothing 32.2.6 html tag attributes you can access You have seen Thymeleaf targeting the “text” attribute a lot now, using th:text. But there are many many more. Have a look at the Thymeleaf docs for a complete listing. Here are the main ones: attribute target th:action the action of a form th:class the style class of an element th:href the url a link will point to th:id the ID of an element th:name the name of an element th:rel url for style sheets th:src the source of an element (e.g. image) th:title the title th:value the value of a (form) element, e.g. th:attr a generic means to define any attribute, e.g. th:attr=“dat=#{subscribe.submit}” An example. This Servlet code ctx.setVariable(&quot;name_of_bird_selector&quot;, &quot;fav_birds&quot;); ctx.setVariable(&quot;bird_groups&quot;, List.of(&quot;raptors&quot;, &quot;songbirds&quot;, &quot;waders&quot;, &quot;wildfowl&quot;)); and this Thymeleaf template fragment &lt;select th:name=&quot;${name_of_bird_selector}&quot;&gt; &lt;option th:each=&quot;bird_cat:${bird_groups}&quot; th:value=&quot;${bird_cat}&quot; th:text=&quot;&#39;The &#39; + ${bird_cat}&quot; th:id=&quot;${bird_cat + &#39;_option&#39;}&quot; value=&quot;_bird_cat_&quot;&gt;_bird_cat_&lt;/option&gt; &lt;/select&gt; produce this html &lt;select name=&quot;fav_birds&quot;&gt; &lt;option id=&quot;raptors_option&quot; value=&quot;raptors&quot;&gt;The raptors&lt;/option&gt; &lt;option id=&quot;songbirds_option&quot; value=&quot;songbirds&quot;&gt;The songbirds&lt;/option&gt; &lt;option id=&quot;waders_option&quot; value=&quot;waders&quot;&gt;The waders&lt;/option&gt; &lt;option id=&quot;wildfowl_option&quot; value=&quot;wildfowl&quot;&gt;The wildfowl&lt;/option&gt; &lt;/select&gt; 32.2.7 Inline expressions Sometimes, it is not desirable to have your variables expressed within tag attributes. Instead, you want raw (html) text. This is especially the case with Javascript, when “injecting” variable values. Here is its main usage scenario: &lt;button id=&quot;say_hello&quot;&gt;Say hello!&lt;/button&gt; &lt;script th:inline=&quot;javascript&quot;&gt; var user = [[${session.logged_in_user.name}]]; document.getElementById(&quot;say_hello&quot;).onclick = function() { alert(&quot;Hi, &quot; + user); } &lt;/script&gt; Although this is a typical use case, you can also use [[${expr}]] whenever you want some value inserted in a textual context, without using &lt;span th:text=\"${...}\"&gt;. "],["thymeleaf-flow-control-and-fragments.html", "Chapter 33 Thymeleaf flow control and fragments 33.1 Introduction 33.2 Working with fragments", " Chapter 33 Thymeleaf flow control and fragments 33.1 Introduction This post is the second on Thymeleaf. It deals with these templating techniques that Thymeleaf offers: conditionals loops using fragments as building blocks For a complete overview you should refer to the official docs. These examples all make use of the Movie class: public class Movie { private String title; private int year; private double rating = -1; private Set&lt;String&gt; mainActors = new HashSet&lt;&gt;(); private static List&lt;Movie&gt; movies; public Movie() { } public Movie(String title, int year) { this.title = title; this.year = year; } public Movie(String title, int year, double rating) { this.title = title; this.year = year; this.rating = rating; } public Movie(String title, int year, double rating, List&lt;String&gt; mainActors) { this.title = title; this.year = year; this.rating = rating; this.mainActors.addAll(mainActors); } public String getTitle() { return title; } public int getYear() { return year; } public double getRating() { return rating; } public List&lt;String&gt; getMainActors() { List&lt;String&gt; actors = new ArrayList&lt;&gt;(); actors.addAll(mainActors); actors.sort(String::compareTo); return actors; } public void setRating(double rating) { this.rating = rating; } public void addActor(String actor) { mainActors.add(actor); } public static List&lt;Movie&gt; getAllMovies() { return Movie.movies; } //create a list from IMDB top 20 static { List&lt;Movie&gt; movies = new ArrayList&lt;&gt;(); Movie movie; movie = new Movie(&quot;The Shawshank Redemption&quot;, 1994, 9.2, List.of(&quot;Tim Robbins&quot;, &quot;Morgan Freeman&quot;)); movies.add(movie); movie = new Movie(&quot;The Dark Knight&quot;, 2008, 9.0, List.of(&quot;Christian Bale,&quot;, &quot;Heath Ledger&quot;)); movies.add(movie); movie = new Movie(&quot;Pulp Fiction&quot;, 1994, 8.9, List.of(&quot;John Travolta&quot;, &quot;Uma Thurman&quot;, &quot;Samuel L. Jackson&quot;)); movies.add(movie); movie = new Movie(&quot;Fight Club &quot;, 1999, 8.8, List.of(&quot;Brad Pitt&quot;, &quot;Edward Norton&quot;)); movies.add(movie); movie = new Movie(&quot;Forrest Gump&quot;, 1994, 8.7, List.of(&quot;Tom Hanks&quot;, &quot;Robin Wright&quot;, &quot;Gary Sinise&quot;)); movies.add(movie); movie = new Movie(&quot;Inception&quot;, 2010, 8.7, List.of(&quot;Leonardo DiCaprio&quot;, &quot;Joseph Gordon-Levitt&quot;)); movies.add(movie); movie = new Movie(&quot;One Flew Over the Cuckoo&#39;s Nest&quot;, 1975, 8.7, List.of(&quot;Jack Nicholson&quot;, &quot;Louise Fletcher&quot;, &quot;Will Sampson&quot;)); movies.add(movie); movie = new Movie(&quot;The Usual Suspects&quot;, 1995, 8.5, List.of(&quot;Kevin Spacey&quot;, &quot;Gabriel Byrne&quot;, &quot;Chazz Palminteri&quot;)); movies.add(movie); Movie.movies = movies; } } The list of movies is attached to the WebContxt object using ctx.setVariable(&quot;movies&quot;, Movie.getAllMovies()); so for all examples the $movies variable is available. 33.1.1 Iteration Iteration with Thymeleaf is as simple as in Java code; simply use th:each. This is an example with the movies list: &lt;table&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;Title&lt;/th&gt; &lt;th&gt;Year of release&lt;/th&gt; &lt;th&gt;IMDB rating&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;tr th:each=&quot;movie:${movies}&quot;&gt; &lt;td th:text=&quot;${movie.title}&quot;&gt;_title_&lt;/td&gt; &lt;td th:text=&quot;${movie.year}&quot;&gt;_year_&lt;/td&gt; &lt;td th:text=&quot;${movie.rating}&quot;&gt;_rating_&lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt; &lt;/table&gt; Alternatively, you can use the local scope syntax: &lt;tr th:each=&quot;movie:${movies}&quot; th:object=&quot;${movie}&quot;&gt; &lt;td th:text=&quot;*{title}&quot;&gt;_title_&lt;/td&gt; &lt;td th:text=&quot;*{year}&quot;&gt;_year_&lt;/td&gt; &lt;td th:text=&quot;*{rating}&quot;&gt;_rating_&lt;/td&gt; &lt;/tr&gt; both of which result in this table: Title Year of release IMDB rating The Shawshank Redemption 1994 9.2 The Dark Knight 2008 9.0 Pulp Fiction 1994 8.9 Fight Club 1999 8.8 Forrest Gump 1994 8.7 Inception 2010 8.7 One Flew Over the Cuckoo’s Nest 1975 8.7 The Usual Suspects 1995 8.5 You can also sort stuff in Thymeleaf. Given an extra model parameter passed from the servlet, and the utility object #lists. Of course, sorting is something you usually leave to your Javascript front-end (Datatables.js). But there are uses for it, and this prevents you from attaching the same list twice to the WebContext object. //java 8+ type Comparator ctx.setVariable(&quot;movies_year_sorter&quot;, (Comparator&lt;Movie&gt;) (o1, o2) -&gt; Integer.compare(o1.getYear(), o2.getYear())); //or, a pre-java 8 Comparator ctx.setVariable(&quot;movies_year_sorter&quot;, new Comparator&lt;Movie&gt;() { @Override public int compare(Movie m1, Movie m2) { return Integer.compare(m1.getYear(), m2.getYear()); } }); then in Thymeleaf, use the Comparator object: &lt;tr th:each=&quot;movie:${#lists.sort(movies, movies_year_sorter)}&quot;&gt; Thymeleaf also provides a mechanism that stores the state of the iteration process. It has several useful properties: index: the current iteration index, starting with 0 (zero) count: the number of elements processed so far size: the total number of elements in the list even/odd: boolean - true if the current iteration index is even or odd first: boolean - true if the current iteration is the first one last: boolean - true if the current iteration is the last one The next piece of code demonstrates the use of this iteration statistics object, as well as another technique: the if/else ternary operator for Thymeleaf. This example shows you can even nest these. &lt;table&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;Pos&lt;/th&gt; &lt;th&gt;Title&lt;/th&gt; &lt;th&gt;Year of release&lt;/th&gt; &lt;th&gt;IMDB rating&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;tr th:each=&quot;movie, it_stat:${movies}&quot; th:class=&quot;${it_stat.first} ? &#39;first&#39; : (${it_stat.even} ? &#39;even&#39; : &#39;odd&#39;)&quot;&gt; &lt;td th:text=&quot;${it_stat.count} + &#39; / &#39; + ${it_stat.size}&quot;&gt;&lt;/td&gt; &lt;td th:text=&quot;${movie.title}&quot;&gt;_title_&lt;/td&gt; &lt;td th:text=&quot;${movie.year}&quot;&gt;_year_&lt;/td&gt; &lt;td th:text=&quot;${movie.rating}&quot;&gt;_rating_&lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt; &lt;/table&gt; when this css is applied: .even { background-color: aliceblue !important; } .odd { background-color: lightcyan !important; } .first { background-color: coral !important; } this is the result: Pos Title Year of release IMDB rating 1 / 8 The Shawshank Redemption 1994 9.2 2 / 8 The Dark Knight 2008 9.0 3 / 8 Pulp Fiction 1994 8.9 4 / 8 Fight Club 1999 8.8 5 / 8 Forrest Gump 1994 8.7 6 / 8 Inception 2010 8.7 7 / 8 One Flew Over the Cuckoo’s Nest 1975 8.7 8 / 8 The Usual Suspects 1995 8.5 There is a lot going on in this statement: &lt;tr th:each=\"movie, it_stat:${movies}\" th:class=\"${it_stat.first} ? 'first' : (${it_stat.even} ? 'even' : 'odd')\"&gt;. Let’s dissect. First there is the iteration initialization where an it_stat object is requested as well: th:each=\"movie, it_stat:${movies}\". In the second part, a nested ternary statement sets the class attribute of the current row. The first level determines the first row: th:class=\"${it_stat.first} ? 'first' : (&lt;nested ternary&gt;)\". The nested ternary determines the class of all rows except the first: ${it_stat.even} ? 'even' : 'odd'. 33.1.2 Conditionals: if (and th:block) Besides the ternary operator structure shown in the previous section, regular “if” tests can be applied. Here is a test for the rating of the movie; only movies with a rating higher than 9 are displayed: &lt;ul&gt; &lt;li th:each=&quot;movie:${movies}&quot; th:text=&quot;${movie.title} + &#39; (&#39; + ${movie.year} + &#39;) - &#39; + ${movie.rating}&quot; th:if=&quot;${movie.rating &gt;= 9}&quot;&gt;_movie_&lt;/li&gt; &lt;/ul&gt; The specified expression evaluates to a boolean following these rules: test evaluates to true if value is not null and value is a boolean and is true a number and is non-zero a character and is non-zero a String and is not “false”, “off” or “no” not a boolean, a number, a character or a String The Thymeleaf th:if attribute has an inverse attribute, th:unless. This makes an if/else-like structure possible. Here, you see it in combination with th:block which is a handy Thymeleaf element which does not generate a html DOM element. Using th:block prevents excessive use of nested div and span elements. &lt;ul&gt; &lt;th:block th:each=&quot;movie : ${movies}&quot;&gt; &lt;li th:if=&quot;${movie.rating &gt;= 9}&quot; th:text=&quot;${movie.title} + &#39; - &#39; + ${movie.rating} + &#39; - WOW!&#39;&quot; &gt;&lt;/li&gt; &lt;li th:unless=&quot;${movie.rating &gt;= 9}&quot; th:text=&quot;${movie.title} + &#39; - &#39; + ${movie.rating} + &#39; - JUST OK&#39;&quot; &gt;&lt;/li&gt; &lt;/th:block&gt; &lt;/ul&gt; 33.1.3 Conditionals: switch Here you see a combination of iteration and switch/case to build an ordered list. &lt;ol&gt; &lt;li th:each=&quot;user:${users}&quot; th:switch=&quot;${user.role.toString()}&quot;&gt; &lt;span th:case=&quot;${&#39;ADMIN&#39;}&quot; th:text=&quot;${user.name} + &#39; (&#39; + ${user.role} + &#39;) manages all accounts&#39;&quot;&gt;_admin_&lt;/span&gt; &lt;span th:case=&quot;${&#39;USER&#39;}&quot; th:text=&quot;${user.name} + &#39; (&#39; + ${user.role} + &#39;) can browse and share all site content&#39;&quot;&gt;_user_&lt;/span&gt; &lt;span th:case=&quot;${&#39;GUEST&#39;}&quot; th:text=&quot;${user.name} + &#39; (&#39; + ${user.role} + &#39;) can only see our front page&#39;&quot;&gt;_guest_&lt;/span&gt; &lt;span th:case=&quot;*&quot; th:text=&quot;${user.name} + &#39;(&#39; + ${user.role} + &#39;) we do not know this role&#39;&quot;&gt;_unknown_&lt;/span&gt; &lt;/li&gt; &lt;/ol&gt; The th:switch expression selects the User role (an enum) in each loop iteration, takes its String representation and compares this to a string literal in each th:case. Only the th:case that matches will be evaluated. When no match is found, the default is evaluated, specified with th:case=\"*\". The result when applied to this list of User instances: List&lt;User&gt; users = new ArrayList&lt;&gt;(); User u; u = new User(&quot;Hank&quot;, &quot;henk@example.com&quot;, Role.ADMIN); users.add(u); u = new User(&quot;Roger&quot;, &quot;roger@example.com&quot;, Role.USER); users.add(u); u = new User(&quot;Diana&quot;, &quot;diana@example.com&quot;, Role.GUEST); users.add(u); is this: &lt;ol&gt; &lt;li&gt; &lt;span&gt;Hank (ADMIN) manages all accounts&lt;/span&gt; &lt;/li&gt; &lt;li&gt; &lt;span&gt;Roger (USER) can browse and share all site content&lt;/span&gt; &lt;/li&gt; &lt;li&gt; &lt;span&gt;Diana (GUEST) can only see our front page&lt;/span&gt; &lt;/li&gt; &lt;/ol&gt; Note that with just one th:case, you can put everything within a single li tag - no need for the span. 33.2 Working with fragments Parts of your pages will be reused over multiple other pages. Specifically, this is the case for banners, footers, menus and headers. Instead of copy-and-paste, Thymeleaf offers a nice mechanism for reusing page fragments - even conditionally! The strategy of choice here is to create a single Thymeleaf html page called “template” or “fragments” and to include elements of this page in others. Consider this html file called template.html: &lt;!DOCTYPE html SYSTEM &quot;http://www.thymeleaf.org/dtd/xhtml1-strict-thymeleaf-4.dtd&quot;&gt; &lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot; xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt; &lt;head th:fragment=&quot;headerFragment&quot;&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;/&gt; &lt;title&gt;_TITLE_&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; th:href=&quot;@{/css/main.css}&quot; href=&quot;../../css/main.css&quot;&gt; &lt;/head&gt; &lt;body&gt; &lt;div th:fragment=&quot;banner&quot;&gt; &lt;img id=&quot;logo&quot; th:src=&quot;@{/graphics/Awesome.png}&quot; src=&quot;../../graphics/Awesome.png&quot; alt=&quot;banner pic&quot;/&gt; &lt;h1 id=&quot;banner_title&quot;&gt;Welcome, ye of lesser quality&lt;/h1&gt; &lt;/div&gt; &lt;!--these can be conditionally selected--&gt; &lt;div th:fragment=&quot;menu&quot; class=&quot;admin&quot;&gt; &lt;a href=&quot;#&quot;&gt;my secret content&lt;/a&gt; &lt;/div&gt; &lt;div th:fragment=&quot;menu&quot; class=&quot;normaluser&quot;&gt; &lt;a href=&quot;#&quot;&gt;my regular content&lt;/a&gt; &lt;/div&gt; &lt;div&gt; &lt;h2&gt;Template layout&lt;/h2&gt; &lt;p&gt; &quot;Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat.&quot; &lt;/p&gt; &lt;/div&gt; &lt;!-- receives an argument called pub --&gt; &lt;div th:fragment=&quot;footer(pub)&quot;&gt; &amp;copy; 2018 Team Awesome. Please don&#39;t contact us; we are too busy!&lt;br/&gt; But if you really need to communicate, you can find us at the local pub: &lt;span th:text=&quot;${pub}&quot;&gt;_PUB_&lt;/span&gt;&lt;br /&gt; &lt;/div&gt; &lt;/body&gt; &lt;/html&gt; The different parts (divs) have been marked with th:fragment=\"&lt;fragment_name&gt;\". These th:fragment tags make them available for inclusion in other pages. This is how you include a fragment from this page into another: &lt;div th:insert=&quot;~{template :: banner}&quot;&gt;&lt;/div&gt; &lt;!-- shorthand --&gt; &lt;div th:insert=&quot;template :: banner&quot;&gt;&lt;/div&gt; The th:insert expression expects a fragment expression (~{...}), which is an expression that results in a fragment. The first part of this expression is the name of the html file (template.html) without the extension and the second part is the fragment to be included. With a non-complex fragment expression, the (~{,}) enclosing is optional, so the shorthand notation suffices. Here is another example, the footer. This fragment takes an argument called pub that is available as variable by that same name. This is how to pass a variable &lt;div th:insert=&quot;~{template :: footer(&#39;The Bear Inn&#39;)}&quot;&gt;&lt;/div&gt; and using it with the fragment is standard variable expression syntax: ${pub}. Finally, different variants of a fragment can be conditionally included - here demonstrated with a ternary statement: &lt;div th:insert=&quot;~{template :: (${users[0].getRole().toString() == &#39;ADMIN&#39;} ? &#39;menu.admin&#39; : &#39;menu.normaluser&#39;)}&quot;&gt;&lt;/div&gt; If the Role is ADMIN, &lt;div th:fragment=\"menu\" class=\"admin\"&gt;... is selected, otherwise &lt;div th:fragment=\"menu\" class=\"normaluser\"&gt;.... The difference between th:insert and th:replace th:insert is the simplest: it will simply insert the specified fragment as the body of its host tag. The th:replace expression actually replaces its host tag with the specified fragment. So, this: &lt;div th:insert=&quot;~{template :: (${users[0].getRole().toString() == &#39;ADMIN&#39;} ? &#39;menu.admin&#39; : &#39;menu.normaluser&#39;)}&quot;&gt;&lt;/div&gt; results in &lt;div&gt; &lt;div class=&quot;admin&quot;&gt; &lt;a href=&quot;#&quot;&gt;my secret content&lt;/a&gt; &lt;/div&gt; &lt;/div&gt; whereas &lt;div th:replace=&quot;~{template :: (${users[0].getRole().toString() == &#39;ADMIN&#39;} ? &#39;menu.admin&#39; : &#39;menu.normaluser&#39;)}&quot;&gt;&lt;/div&gt; results in &lt;div class=&quot;admin&quot;&gt; &lt;a href=&quot;#&quot;&gt;my secret content&lt;/a&gt; &lt;/div&gt; "],["sessions-scopes.html", "Chapter 34 Sessions &amp; Scopes 34.1 Introduction 34.2 Scopes 34.3 Summary of scopes", " Chapter 34 Sessions &amp; Scopes 34.1 Introduction In this post, some seemingly diverse topics are dealt with. After reading, you should be aware that they actually relate. The topics are: - application-scoped variables with web.xml - user authentication - sessions - overview of the different scopes and when to use which DISCLAIMER Everything in this presentation related to authentication is purely for the purpose of showing principles. For real-world applications you will need to do much work on security 34.2 Scopes 34.2.1 Application scope: web.xml You use application-scoped variables for everything that relates to the entire application: admin email, database type and url, servlet configuration, etc. Application-scoped variables are available withing servlets but also within Thymeleaf templates. These variables are defined within an xml file named web.xml and it is called a deployment descriptor. Adding a deployment descriptor These are the steps you can take to have IntelliJ add a web.xml file in the correct location. Go to Project Structure (Cmd + ; on Mac) Facets → Web → Web Gradle (select your project) Under pane Deployment Descriptors, click “+” Select “web.xml” In the path, put this: &lt;your project root&gt;/src/main/webapp/WEB-INF/web.xml You’ll get something like this &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;web-app xmlns=&quot;http://xmlns.jcp.org/xml/ns/javaee&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot; version=&quot;4.0&quot;&gt; &lt;/web-app&gt; Add an application-scoped variable In web.xml, put the following snippet: &lt;context-param&gt; &lt;param-name&gt;admin_email&lt;/param-name&gt; &lt;param-value&gt;admin@example.com&lt;/param-value&gt; &lt;/context-param&gt; Using the application-scoped variable In your servlets, use the web app variable like this: getServletContext().getInitParameter(&quot;admin_email&quot;) In your Thymeleaf template, the application-scoped variable, is available like this th:text=&quot;${#servletContext.getInitParameter(&#39;admin_email&#39;)}&quot; 34.2.2 Session scope: cross-request “memory” A server handling your request will have no memory of your visit after it is processed. To be able to “keep in touch” you will need to have a tracking system: we call this a session. The most well-known session implementation system is by means of cookies. This is a cookie according to Wikipedia: “In computing, a cookie (also tracking cookie, browser cookie, and HTTP cookie) is a small piece of text stored on a user’s computer by a web browser. A cookie consists of one or more name-value pairs containing bits of information such as … the identifier for a server-based session….” Thus, sessions represent cross-request memory. Typical usages of session objects are - keeping an authenticated user “logged in” - keeping track of “shopping baskets” - keeping track of history (“here at the items you have looked at previously”) In java, sessions are usually maintained by means of a JSessionID stored as a cookie. You will probably never create a cookie directly. You simply use this statement: HttpSession session = request.getSession(); 34.2.3 Authentication You do not need to have an authenticated user to create a session, but authentication is never done without using session. There are several reasons why you would like to know who it is that requests a certain page, the main reason being that you want only authorized persons to have access (and with a certain role). Let’s look at some sample code to create a login system using sessions. Login form Here is the first element, a login form. Take notice of the form field names eg name=\"username\". These names are going to be used in the servlet to fetch the login credentials. Also note the action=\"login\" attribute of the &lt;form&gt; tag. It will direct to the server requesting resource login. &lt;!DOCTYPE html SYSTEM &quot;http://www.thymeleaf.org/dtd/xhtml1-strict-thymeleaf-4.dtd&quot;&gt; &lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot; xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt; &lt;head&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;/&gt; &lt;title&gt;Authentication demo&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; th:href=&quot;@{/css/main.css}&quot; href=&quot;../../css/main.css&quot;&gt; &lt;/head&gt; &lt;body&gt; &lt;h4&gt;Log in&lt;/h4&gt; &lt;h4 th:text=&quot;${message}&quot; th:class=&quot;${message_type}&quot;&gt;_message_&lt;/h4&gt; &lt;form action=&quot;login&quot; method=&quot;POST&quot;&gt; &lt;label for=&quot;username_field&quot;&gt; User name: &lt;/label&gt; &lt;input id=&quot;username_field&quot; type=&quot;text&quot; name=&quot;username&quot; required/&gt; &lt;br/&gt; &lt;label for=&quot;password_field&quot;&gt; User password: &lt;/label&gt; &lt;input id=&quot;password_field&quot; type=&quot;password&quot; name=&quot;password&quot; required/&gt;&lt;br/&gt; &lt;label class=&quot;login_field&quot;&gt; &lt;/label&gt; &lt;input type=&quot;submit&quot; value=&quot;OK&quot;/&gt; &lt;/form&gt; &lt;h5&gt;If you have any problems, please contact &lt;span th:text=&quot;${#servletContext.getInitParameter(&#39;admin_email&#39;)}&quot;&gt;&lt;/span&gt;&lt;/h5&gt; &lt;/body&gt; &lt;/html&gt; and it looks like this in the browser: Login form 1 Actually, when you see a http:// protocol instead of an https:// protocol in the location bar of your browser, you do NOT have safety on you connection, even though you cannot see the password in the form! But that issue is not within the scope of this course. Login servlet This is the servlet dealing with the login form. package nl.bioinf.wis_on_thymeleaf.servlets; //many imports @WebServlet(urlPatterns = &quot;/login&quot;) public class LoginServlet extends HttpServlet { private TemplateEngine templateEngine; @Override public void init() throws ServletException { this.templateEngine = WebConfig.getTemplateEngine(); } protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { String username = request.getParameter(&quot;username&quot;); String password = request.getParameter(&quot;password&quot;); WebContext ctx = new WebContext( request, response, request.getServletContext(), request.getLocale()); //fetch the session object //if it is not present, one will be created HttpSession session = request.getSession(); String nextPage; if (session.isNew() || session.getAttribute(&quot;user&quot;) == null) { boolean authenticated = authenticate(username, password); if (authenticated) { session.setAttribute(&quot;user&quot;, new User(&quot;Henk&quot;, &quot;henk@example.com&quot;, Role.USER)); nextPage = &quot;mainSite&quot;; } else { ctx.setVariable(&quot;message&quot;, &quot;Your password and/or username are incorrect; please try again&quot;); ctx.setVariable(&quot;message_type&quot;, &quot;error&quot;); nextPage = &quot;login&quot;; } } else { nextPage = &quot;mainSite&quot;; } templateEngine.process(nextPage, ctx, response.getWriter()); } private boolean authenticate(String username, String password) { return username.equals(&quot;Henk&quot;) &amp;&amp; password.equals(&quot;henk&quot;); } //simple GET requests are immediately forwarded to the login page protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { WebContext ctx = new WebContext( request, response, request.getServletContext(), request.getLocale()); ctx.setVariable(&quot;message&quot;, &quot;Fill out the login form&quot;); ctx.setVariable(&quot;message_type&quot;, &quot;info&quot;); templateEngine.process(&quot;login&quot;, ctx, response.getWriter()); } } Above the class declaration you see the @WebServlet(urlPatterns = \"/login\") annotation which tells the application server to route all requests to the URL /login to this servlet class. The doPost() method -which has several code smells (do you know which)- creates a session object. Next, it checks the session status and proceeds. If it is new (or empty): check user credentials. Else: go directly to the main page - why check credentials if the user already is logged in? The authenticate() method is a dummy of course. We’ll visit that part of authentication in the post on database interaction because -obviously- user data are stored in a database and are never hard-coded. If authentication is successful, the user is forwarded to the sites’ main page: &lt;!DOCTYPE html SYSTEM &quot;http://www.thymeleaf.org/dtd/xhtml1-strict-thymeleaf-4.dtd&quot;&gt; &lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot; xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt; &lt;head&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;/&gt; &lt;title&gt;_TITLE_&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h3&gt;Welcome to our main page, [[${session.user.name}]]! Feel free to browse our content&lt;/h3&gt; &lt;/body&gt; &lt;/html&gt; The [[${session.user.name}]]! expression is an inline text expression - it does not need to be embedded in a html tag. Alternatively, we could have used this: &lt;h3&gt;Welcome to our main page, &lt;span th:text=&quot;${session.user.name}&quot;&gt;__offline__&lt;/span&gt;! Feel free to browse our content&lt;/h3&gt; Test Start the server and run - Log in - Enter username and password - Test false credentials - Test correct credentials What is the result, what do you see? Can you detect weaknesses and/or improve on the design? 34.3 Summary of scopes As in all programming environments, scopes are really important in web applications. We have seen the three main ones: Application scope Specified in web.xml and accessed through ${#servletContext.getInitParameter('admin_email')} in the Thymeleaf files or getServletContext().getInitParameter(\"&lt;attrib_name&gt;\") in the servlet code Session scope Stored in HttpSession object. When available, accessed through ${session.&lt;attrib_name&gt;} in the Thymeleaf files and getSession.getAttribute(\"&lt;attrib_name&gt;\") in the servlet code. Set through getSession.setAttribute(\"&lt;attrib_name&gt;\", &lt;attrib&gt;). “Request” scope Each http request generates its own HttpRequest object. It can be accessed through ${#request.&lt;attrib_name&gt;} in the Thymeleaf files. In servlet context, use request.getParameter(\"&lt;attrib_name&gt;\") to get it or request.setAttribute(\"&lt;attrib_name&gt;\", \"&lt;attrib&gt;\") to set it. The WebContext object is of course used much more in Thymeleaf, and in that context simply accessed as ${attrib_name&gt;} "],["servlet-details-and-lifecycle-hooks.html", "Chapter 35 Servlet details and lifecycle hooks 35.1 Servlet configuration 35.2 Hooks", " Chapter 35 Servlet details and lifecycle hooks In this post, some details of servlet configuration are discussed, as well as techniques that you can use to hook into life cycle events, the main ones being application startup and -shutdown, and first request on a servlet. 35.1 Servlet configuration The @WebServlet annotation offers several possibilities for configuration. Here are the interesting ones: Name Type Required Description urlPatterns or value String[] y Specify one or more URL patterns of the servlet. Either of attribute can be used, but not both asyncSupported String n Specify whether the servlet supports asynchronous operation mode. Default is false. initParams WebInitParam[] n Specify one or more initialization parameters of the servlet. Each parameter is specified by @WebInitParam annotation type. loadOnStartup int n Specify load-on-startup order of the servlet. Default is -1 @Webservlet - urlPatterns The urlPatterns parameter specifies which urls will map on your servlet. This configuration: @WebServlet(name = &quot;WelcomeServlet&quot;, urlPatterns = {&quot;/welcome&quot;, &quot;/index&quot;, &quot;/home&quot;}) public class WelcomeServlet extends HttpServlet { ... } maps all these requests to WelcomeServlet: - http://localhost:8080/index - http://localhost:8080/welcome - http://localhost:8080/home @Webservlet - loadOnStartup The loadOnStartup parameter is an integer which specifies the servlet load order. The container loads servlets with lower values before servlets with higher values. If loadOnStartup is negative (it defaults to -1), the servlet will be loaded when the container decides to - typically on first access. @WebServlet(urlPatterns = {&quot;/welcome&quot;}, loadOnStartup = 1) //guarantees first loading at deployment public class WelcomeServlet extends HttpServlet { ... } @Webservlet – initParams Servlet initialization parameters are defined as instances of @WebInitParam. @WebServlet(urlPatterns = {&quot;/welcome&quot;}, initParams = { @WebInitParam(name = &quot;tempDir&quot;, value = &quot;/tmp&quot;), @WebInitParam(name = &quot;allowedFileTypes&quot;, value = &quot;jpg,png&quot;) }) public class WelcomeServlet extends HttpServlet { @Override public void init() throws ServletException { final String tempDir = getInitParameter(&quot;tempDir&quot;); System.out.println(&quot;tempDir = &quot; + tempDir); System.out.println(&quot;admin_email = &quot; + getServletContext().getInitParameter(&quot;admin_email&quot;)); } //more code } will output to the console tempDir = /tmp admin_email = admin\\@example.com You can specify the same information in web.xml, which seems a bit more logical: &lt;servlet-mapping&gt; &lt;servlet-name&gt;WelcomeServlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/welcome&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;servlet&gt; &lt;servlet-name&gt;WelcomeServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;nl.bioinf.wis_on_thymeleaf.servlets.WelcomeServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;tempDir&lt;/param-name&gt; &lt;param-value&gt;/some/location&lt;/param-value&gt; &lt;/init-param&gt; &lt;/servlet&gt; @Webservlet versus web.xml configuration When configuration is done in both web.xml ánd in @WebServlet annotations, the web.xml configuration takes precedence. A use case for this behaviour would be: development mode versus production mode. With these two “conflicting” configurations, the url will become /extra and tempDir /some/location. The url /welcome will return a 404 not found! @WebServlet(name = &quot;WelcomeServlet&quot;, urlPatterns = {&quot;/welcome&quot;, &quot;/home&quot;}, initParams = {@WebInitParam(name = &quot;tempDir&quot;, value = &quot;/tmp&quot;)} public class WelcomeServlet extends HttpServlet { } &lt;servlet-mapping&gt; &lt;servlet-name&gt;WelcomeServlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/extra&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;servlet&gt; &lt;servlet-name&gt;WelcomeServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;nl.bioinf.wis_on_thymeleaf.servlets.WelcomeServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;tempDir&lt;/param-name&gt; &lt;param-value&gt;/some/location&lt;/param-value&gt; &lt;/init-param&gt; &lt;/servlet&gt; @Webservlet – asyncSupported This allows the servlet to store incoming requests for later response. For practical purposes, with this configuration you can set up a servlet that will (in effect) push data to the client (after the client sends the initial request to the server). This is very interesting, but outside the scope of this course. 35.2 Hooks Hooks are pieces of code that let you write code that will run at application life cycle events. The ones we will look at here are: - Application startup/shutdown hook - Servlet initialization/cleanup hooks 35.2.1 Application startup &amp; shutdown If you want to do something at - startup – e.g. create a single template engine to service all servlets - shutdown – e.g. free DB resources you annotate a class with @WebListener and have it implement the ServletContextListener interface. Here is an implementation. It uses the startup hook to create a single TemplateEngine instance that can be served to all servlets, guaranteeing that this code will have run first and only once. package nl.bioinf.wis_on_thymeleaf.config; //imports removed @WebListener public class WebConfig implements ServletContextListener { private static TemplateEngine templateEngine; @Override public void contextInitialized(ServletContextEvent servletContextEvent) { System.out.println(&quot;[WebConfig] Initializing template engine&quot;); createTemplateEngine(servletContextEvent.getServletContext()); } @Override public void contextDestroyed(ServletContextEvent servletContextEvent) { System.out.println(&quot;Shutting down!&quot;); } private static void createTemplateEngine(ServletContext servletContext) { ServletContextTemplateResolver templateResolver = new ServletContextTemplateResolver(servletContext); templateResolver.setTemplateMode(&quot;XHTML&quot;); templateResolver.setPrefix(&quot;/WEB-INF/templates/&quot;); templateResolver.setSuffix(&quot;.html&quot;); templateResolver.setCacheTTLMs(3600000L); // Cache is set to true by default. // Set to false if you want templates to be automatically // updated when modified. templateResolver.setCacheable(true); TemplateEngine templateEngine = new TemplateEngine(); templateEngine.setTemplateResolver(templateResolver); WebConfig.templateEngine = templateEngine; } /** * serves the template engine that was created at application startup. * @return */ public static TemplateEngine getTemplateEngine() { return templateEngine; } //method omitted } 35.2.2 Servlet initialization and destroy When a first request is received for a servlet after application startup, the servlet container (Tomcat) will call the init() methods, if present. Method init() is guaranteed to be called before the first call to service(). Servlet lifecycle init(ServletConfig config) is called by the servlet container to indicate to a servlet that the servlet is being placed into service. init() is a convenience method which can be overridden so that there’s no need to call super.init(config). destroy() is called by the servlet container to indicate to a servlet that the servlet is being taken out of service There are two overloaded variants defined in class GenericServlet that you can hook into to handle your startup actions: public void init(ServletConfig config) throws ServletException { this.config = config; this.init(); } public void init() throws ServletException { } As you can see the first one calls the second one. Depending on your need for the ServletConfig object -which gives access to application-scoped variables-, you can choose either one of them to override. Here are all three (in class PhraseServlet, for demo purposes): @Override public void init() throws ServletException { //no super.init() required System.out.println(&quot;[PhraseServlet] Running no-arg init()&quot;); this.templateEngine = WebConfig.getTemplateEngine(); } @Override public void init(ServletConfig config) throws ServletException { super.init(config); //required in this implementation System.out.println(&quot;[PhraseServlet] Running init(ServletConfig config)&quot;); config.getServletContext().getInitParameter(&quot;admin_email&quot;); } @Override public void destroy() { super.destroy(); System.out.println(&quot;[PhraseServlet] Shutting down servlet service&quot;); } In general, you use these init() methods to initialize “expensive” resources that you only want to create once. Good examples are importing config files, creating database connections (although there may be better solutions for that) or getting template engines, as in this example. Likewise, the destroy method can be used to elegantly shut down resources. "],["database-interaction.html", "Chapter 36 Database interaction 36.1 JDBC 36.2 The naive implementation 36.3 Improve on naive implementation 36.4 Refactoring to OO principles 36.5 Use in a servlet environment", " Chapter 36 Database interaction In this post, these topics will be discussed: - Database interaction with Java applications: JDBC - Java design issues that ensure flexible, reusable code that will easily deal with changing specs: - a different database provider - a different view - different analysis components - etc etc Just remember: the only constant in programming is change. ⇒ Have a look at the repo to see the full code of these examples. 36.1 JDBC Having Java applications talk with MySQL databases require that you have the required Driver in your project class path. Let’s start with that. Put this line in te dependencies section of your build.gradle file: // https://mvnrepository.com/artifact/mysql/mysql-connector-java compile group: &#39;mysql&#39;, name: &#39;mysql-connector-java&#39;, version: &#39;5.1.6&#39; You may need to refresh your Gradle project in the Gradle Tool window, if you did not check the auto refresh option when creating the project. Refresh project The database Of course, you will need a MySQL server, a database and an account. Deal with that first before proceeding, if you don’t have that! Suppose we have a database called MyDB with this single, simple table Users: Field Type user_id int AUTO-INCREMENT user_name varchar(30) user_password varchar(30) user_email varchar(30) role enum('GUEST', 'USER', 'ADMIN') The model classes These are the model classes that play a role in this chapter on database interaction. Class User, a class that models visitors/users of a website: package nl.bioinf.wis_on_thymeleaf.model; import java.util.ArrayList; import java.util.List; import java.util.Objects; public class User { private String name; private String email; private String password; private Role role; public User() { } public User(String name, String email, Role role) { this.name = name; this.email = email; this.role = role; } public User(String name, String email, String password, Role role) { this.name = name; this.email = email; this.password = password; this.role = role; } public void setPassword(String password) { this.password = password; } public void setRole(Role role) { this.role = role; } public String getName() { return name; } public String getEmail() { return email; } public String getPassword() { return password; } public Role getRole() { return role; } //toString(), equals(), hashCode() and getSome() omitted } The enum Role, modelling the role that website users can have: package nl.bioinf.wis_on_thymeleaf.model; public enum Role { GUEST, USER, ADMIN; } and my custom Exception type that encapsulates all exceptions that can occur during database interaction: package nl.bioinf.wis_on_thymeleaf.dao; public class DatabaseException extends Exception { public DatabaseException() { super(); } public DatabaseException(String message) { super(message); } public DatabaseException(String message, Throwable cause) { super(message, cause); } public DatabaseException(Throwable cause) { super(cause); } protected DatabaseException(String message, Throwable cause, boolean enableSuppression, boolean writableStackTrace) { super(message, cause, enableSuppression, writableStackTrace); } } Database actions within IntelliJ IntelliJ has excellent support for databases: it has an internal MySQL console, and supports autocomplete on in-code SQL statements and sql scripts. To get this Database toolbox support active, you need let IntelliJ know about the database and follow these steps: View → Tool Windows → Database Click “+” → Data Source → MySQL Add datasource 1 Fill in the blanks (note: you may not have a localhost MySQL server. Instead, it may run on some specific URL such as mysql.bin) Add datasource 2 Click “download missing driver files” Click “test connection” Note the URL it creates. Check that the data provided corresponds with your situation (Host, Database, User and Password). Open the MySQL console (double-click the data source in the Databases panel), Enter a command Press Ctrl + enter Add datasource 3 Add data to the DB First, a simple table is defined and created, and some preliminary dummy data is entered. DROP TABLE IF EXISTS Users; CREATE TABLE Users ( user_id INT NOT NULL auto_increment, user_name VARCHAR(100) NOT NULL, user_password VARCHAR(100) NOT NULL, user_email VARCHAR(255) NOT NULL, user_role VARCHAR(100) NOT NULL, primary key(user_id)); INSERT INTO Users (user_name, user_password, user_email, user_role) VALUES (&#39;Henk&#39;, &#39;Henkie&#39;, &#39;Henk@example.com&#39;, &#39;ADMIN&#39;); Of course, storing a user password unencrypted is a very bad idea. We will address this aspect later. Next, have a look at the DB tool window: Add datasource 4 36.2 The naive implementation Here follow some classes demonstrating the general usage of database interaction components. You should not implement your logic like this - it is inefficient, not OO, and very ugly. A better solution follows later in this chapter. Study this class carefully so you understand how everything works at the syntax level. package nl.bioinf.wis_on_thymeleaf.dao; import nl.bioinf.wis_on_thymeleaf.model.Role; import nl.bioinf.wis_on_thymeleaf.model.User; import java.sql.*; public class VerySimpleDbConnector { private final String url; private final String dbUser; private final String dbPassword; private Connection connection; /** * a main for demonstration purposes * @param args */ public static void main(String[] args) { try { //connect VerySimpleDbConnector connector = new VerySimpleDbConnector(&quot;&lt;host&gt;&quot;, &quot;&lt;db-user&gt;&quot;, &quot;db-password&quot;); //insert a user connector.insertUser(&quot;Piet&quot;, &quot;Pietissafe&quot;, &quot;piet@example.com&quot;, Role.ADMIN); //fetch a user connector.getUser(&quot;Piet&quot;, &quot;Pietissafe&quot;); //a catch-all for database interaction exceptions } catch (DatabaseException e) { e.printStackTrace(); } } public VerySimpleDbConnector(String url, String dbUser, String dbPassword) throws DatabaseException { this.url = url; this.dbUser = dbUser; this.dbPassword = dbPassword; //make the connection connect(); } private void connect() throws DatabaseException { try { //load driver class Class.forName(&quot;com.mysql.jdbc.Driver&quot;); //create connection connection = DriverManager.getConnection(url, dbUser, dbPassword); //..which is risky } catch (Exception e) { e.printStackTrace(); throw new DatabaseException(&quot;Something is wrong with the database, see cause Exception&quot;, e.getCause()); } } public User getUser(String userName, String userPass) throws DatabaseException { try { //Prepare the SQL statement. The question marks are placeholders for repeated use with different data //!! Doing this within this method is extremely inefficient !! String fetchQuery = &quot;SELECT * FROM Users WHERE user_name = ? AND user_password = ?&quot;; PreparedStatement ps = connection.prepareStatement(fetchQuery); //set data on the &quot;?&quot; placeholders of the prepared statement ps.setString(1, userName); ps.setString(2, userPass); //execute ResultSet rs = ps.executeQuery(); //if there is data, process it while (rs.next()) { String userMail = rs.getString(&quot;user_email&quot;); String userIdStr = rs.getString(&quot;user_id&quot;); String userRoleStr = rs.getString(&quot;user_role&quot;); Role role = Role.valueOf(userRoleStr); User user = new User(userName, userMail, userPass, role); return user; } //close resources rs.close(); } catch (SQLException e) { e.printStackTrace(); throw new DatabaseException(&quot;Something is wrong with the database, see cause Exception&quot;, e.getCause()); } return null; } public void insertUser(String userName, String userPass, String email, Role role) throws DatabaseException { try{ //Prepare statement //!! Doing this within this method is extremely inefficient !! String insertQuery = &quot;INSERT INTO Users (user_name, user_password, user_email, user_role) &quot; + &quot; VALUES (?, ?, ?, ?)&quot;; PreparedStatement ps = connection.prepareStatement(insertQuery); //set data on the &quot;?&quot; placeholders of the prepared statement ps.setString(1, userName); ps.setString(2, userPass); ps.setString(3, email); ps.setString(4, role.toString()); //do the actual insert ps.executeUpdate(); //close resources ps.close(); } catch (Exception ex) { ex.printStackTrace(); throw new DatabaseException(&quot;Something is wrong with the database, see cause Exception&quot;, ex.getCause()); } } /** * close the connection! * @throws DatabaseException */ public void disconnect() throws DatabaseException { try { connection.close(); } catch (SQLException e) { e.printStackTrace(); } } } JDBC class loading Class.forName(&quot;com.mysql.jdbc.Driver&quot;); This mechanism is called dynamic class loading. It loads the driver classes required for the MySQL interaction: Create a Connection After loading the driver class(es), you need to establish a connection: String dbUrl = &quot;jdbc:mysql://MyHost/MyDbName&quot;; String dbUser = &quot;Fred&quot;; String dbPass = &quot;FredIsSafe&quot;; this.connection = DriverManager.getConnection(dbUrl, dbUser, dbPass); Note that hardcoding your passwords in a repo that you are going to put online is a very bad idea; see the next section ofr a solution. 36.3 Improve on naive implementation Externalize your credentials I have created a small helper app that you can use to prevent storing passwords in your code. It reads your credentials from the .my.cnf file stored in your home folder. You can clone and build the repo or download the jar here and put it in your build path by adding the following line to the build/gradle file: compile files(&#39;path/to/library/folder/DButils-1.0.2.jar&#39;) When you have it on the build path, simply use it as follows: DbUser dbUser = DbCredentials.getMySQLuser(); String user = dbUser.getUserName(); String passWrd = dbUser.getDatabasePassword(); String host = dbUser.getHost(); String dbName = dbUser.getDatabaseName(); assuming you have a .my.cnf file in your home folder and it has the correct entries: [client] user=&lt;db user name&gt; password=&lt;db password&gt; host=localhost database=&lt;default database&gt; Once you establish the connection, you have a live java.sql.Connection object. Talking to a database -an external resource- is “risky” business, so you have to put it in a try/catch block. In a real app, you should do something else with the exception than print it of course, but this post is not about exception handling. Use PreparedStatements Use PreparedStatements for interacting with the database. Using PreparedStatement instances makes it easier and far more efficient to repeat a query. Here is one of the two queries that are required for implementing the interface methods. private static final String GET_USER = &quot;get_user&quot;; /** * prepares prepared statements for reuse * @throws SQLException */ private void prepareStatements() throws SQLException { String fetchQuery = &quot;SELECT * FROM Users WHERE user_name = ? AND user_password = ?&quot;; PreparedStatement ps = connection.prepareStatement(fetchQuery); this.preparedStatements.put(GET_USER, ps); } The prepared statements are stored as entries of a Map, which is an instance variable of the class MyAppDaoMySQL. The?` characters serve as placeholders, to be replaced with actual values before executing the statement. See next section. Traversing results Results can be traversed through the ResultSet object that you get back from ResultSet rs = ps.executeQuery();. ResultSet rs = ps.executeQuery(); while (rs.next()) { //process results } Here, you see the use of while (rs.next()) {} which is not entirely logical if you expect a single result, as in this case (checking for a registered user). Maybe it is better to add some checks, such as: if (rs.getFetchSize() &gt; 1) { throw new DatabaseException(&quot;something wrong&quot;); } Now the low level code details are ready and known, let’s implement this in a better way. 36.3.1 Code against interfaces Code against interfaces, not implementations. Suppose you start working on a website with a MySQL database as backend data layer. You think “encapsulation”, and create a class responsible for all database interaction (MyMySqlDbConnector), and use this class all over our code base. Something like this: MyMySqlDbConnector dbConnector = new MyMySqlDbConnector(url, user, pass); Next year, after our application has grown, we decide a key-value store such as Couchbase is better suited for our growing customer base. We create a new class, MyCouchbaseConnector. Unfortunately, everywhere we used the MySQL connector, we need to change our code to the new implementation. MyCouchbaseConnector dbConnector = new MyCouchbaseConnector(); And if we are unlucky, the MyCouchbaseConnector has differing method signatures as well, making the refactoring process a hellish job. That is such an unnecessary waste of time if we would have adhered to one of the prime directives of OO programming: Code against interfaces not implementations (where interface may mean interface as type, but also abstract class). 36.4 Refactoring to OO principles This principle is outlined in the following series of steps. 1: An interface definition Think long and hard about the contract: which methods do you need, disregarding the technology behind the scenes? This will be your interface definition. Here is the interface specifying my user database interactions: package nl.bioinf.wis_on_thymeleaf.dao; import nl.bioinf.wis_on_thymeleaf.model.Role; import nl.bioinf.wis_on_thymeleaf.model.User; public interface MyAppDao{ /** * connection logic should be put here. * @throws DatabaseException */ void connect() throws DatabaseException; /** * shutdown logic should be put here * @throws DatabaseException */ void disconnect() throws DatabaseException; /** * fetches a user by username and password. * @param userName * @param userPass * @return * @throws DatabaseException */ User getUser(String userName, String userPass) throws DatabaseException; /** * inserts a new User. * @param userName * @param userPass * @param email * @param role * @throws DatabaseException */ void insertUser(String userName, String userPass, String email, Role role) throws DatabaseException; } 2: Create an interface implementer Here is the complete class. It of course implements all interface methods. The Singleton pattern will be explained below. package nl.bioinf.wis_on_thymeleaf.dao; //imports omitted public final class MyAppDaoMySQL implements MyAppDao { private static final String GET_USER = &quot;get_user&quot;; private static final String INSERT_USER = &quot;insert_user&quot;; private final String url; private final String dbUser; private final String dbPassword; private Connection connection; private Map&lt;String, PreparedStatement&gt; preparedStatements = new HashMap&lt;&gt;(); /*singleton pattern*/ private static MyAppDaoMySQL uniqueInstance; /** * singleton pattern */ private MyAppDaoMySQL(String url, String dbUser, String dbPassword) { this.url = url; this.dbUser = dbUser; this.dbPassword = dbPassword; } /** * singleton pattern */ public static MyAppDaoMySQL getInstance(String url, String dbUser, String dbPassword) { //lazy if (uniqueInstance == null) { uniqueInstance = new MyAppDaoMySQL(url, dbUser, dbPassword); } return uniqueInstance; } @Override public void connect() throws DatabaseException { try { Class.forName(&quot;com.mysql.jdbc.Driver&quot;); connection = DriverManager.getConnection(url, dbUser, dbPassword); prepareStatements(); } catch (Exception e) { e.printStackTrace(); throw new DatabaseException(&quot;Something is wrong with the database, see cause Exception&quot;, e.getCause()); } } /** * prepares prepared statements for reuse * @throws SQLException */ private void prepareStatements() throws SQLException { String fetchQuery = &quot;SELECT * FROM Users WHERE user_name = ? AND user_password = ?&quot;; PreparedStatement ps = connection.prepareStatement(fetchQuery); this.preparedStatements.put(GET_USER, ps); String insertQuery = &quot;INSERT INTO Users (user_name, user_password, user_email, user_role) &quot; + &quot; VALUES (?, ?, ?, ?)&quot;; ps = connection.prepareStatement(insertQuery); this.preparedStatements.put(INSERT_USER, ps); } @Override public User getUser(String userName, String userPass) throws DatabaseException { try { PreparedStatement ps = this.preparedStatements.get(GET_USER); ps.setString(1, userName); ps.setString(2, userPass); ResultSet rs = ps.executeQuery(); while (rs.next()) { String userMail = rs.getString(&quot;user_email&quot;); String userIdStr = rs.getString(&quot;user_id&quot;); String userRoleStr = rs.getString(&quot;user_role&quot;); Role role = Role.valueOf(userRoleStr); User user = new User(userName, userMail, userPass, role); return user; } rs.close(); } catch (SQLException e) { e.printStackTrace(); throw new DatabaseException(&quot;Something is wrong with the database, see cause Exception&quot;, e.getCause()); } return null; } @Override public void insertUser(String userName, String userPass, String email, Role role) throws DatabaseException { try{ PreparedStatement ps = this.preparedStatements.get(INSERT_USER); ps.setString(1, userName); ps.setString(2, userPass); ps.setString(3, email); ps.setString(4, role.toString()); ps.executeUpdate(); ps.close(); } catch (Exception ex) { ex.printStackTrace(); throw new DatabaseException(&quot;Something is wrong with the database, see cause Exception&quot;, ex.getCause()); } } @Override public void disconnect() throws DatabaseException { /*After you are done, you must carefully clean up your database resources!*/ /*These objects need to be closed explicitly: * `ResultSet` (here: done in method itself) * `PreparedStatemenent` * `Connection` (always last) */ try{ for( String key : this.preparedStatements.keySet() ){ this.preparedStatements.get(key).close(); } }catch( Exception e ){ e.printStackTrace(); } finally{ try { connection.close(); } catch (SQLException e) { e.printStackTrace(); } } } } 3: Create a factory class Here, class MyAppDaoFactory was created that will instantiate and serve the right type of implementer. This should preferably be done based on some external configuration setting (such as web.xml). Also note that the Database credentials are read from the external .my.cnf file here, using the helper app discussed earlier. package nl.bioinf.wis_on_thymeleaf.dao; //imports deleted public class MyAppDaoFactory { private static MyAppDao daoInstance; /** * Code should be called at application startup */ public static void initializeDataSource(String type) throws DatabaseException { if (daoInstance != null) { throw new IllegalStateException(&quot;DAO can be initialized only once&quot;); } switch(type) { case &quot;dummy&quot;: { createDummyInstance(); break; } case &quot;mysql&quot;: { createMySQLInstance(); break; } default: throw new IllegalArgumentException(&quot;unknown database type requested&quot;); } } /** * serves the dao instance * @return */ public static MyAppDao getDataSource() { if (daoInstance == null) { throw new IllegalStateException(&quot;DAO is not initialized; call initializeDataSource() first&quot;); } return daoInstance; } private static void createDummyInstance() throws DatabaseException { daoInstance = new MyAppDaoInMemory(); daoInstance.connect(); } private static void createMySQLInstance() throws DatabaseException { try { DbUser mySQLuser = DbCredentials.getMySQLuser(); String dbUrl = &quot;jdbc:mysql://&quot; + mySQLuser.getHost() + &quot;/&quot; + mySQLuser.getDatabaseName(); String dbUser = mySQLuser.getUserName(); String dbPass = mySQLuser.getDatabasePassword(); daoInstance = MyAppDaoMySQL.getInstance(dbUrl, dbUser, dbPass); daoInstance.connect(); } catch (IOException | NoSuchFieldException e) { throw new DatabaseException(e); } } } 4: Have the correct type instantiated Have the correct type instantiated at application startup. The web.xml deployment descriptor is an excellent place to specify which implementation of the MyAppDao interface to use: &lt;context-param&gt; &lt;param-name&gt;db-type&lt;/param-name&gt; &lt;param-value&gt;mysql&lt;/param-value&gt; &lt;/context-param&gt; The datasource needs to be initialized at application startup, requested from the class MyAppDaoFactory. You have seen the application startup hook in a previous post (see servlet details and lifecycle hooks); it was implemented in class WebConfig. Here, the DAO initialization is done within that method, contextInitialized(). @WebListener public class WebConfig implements ServletContextListener { @Override public void contextInitialized(ServletContextEvent servletContextEvent) { //other code //fetch the database type String dbType = servletContextEvent.getServletContext().getInitParameter(&quot;db-type&quot;); try { MyAppDaoFactory.initializeDataSource(dbType); } catch (DatabaseException e) { e.printStackTrace(); //this should be logged of course; and dealt with elegantly } } //other code } 5: Use the interface type in your code base It is now easy to get hold of the connector anywhere in our application because we can call the static method getInstance(). MyAppDao dao = MyDbConnector.getInstance(); 36.4.1 Singleton I want class DbCredentials to be instantiated only once - we do not want to create resource-heavy classes twice if we can prevent it. To guarantee this, the singleton pattern is implemented. It has three components: a private static instance a private constructor (only this class can instantiate itself) a public static method serving the single instance private static MyAppDaoMySQL uniqueInstance; private MyAppDaoMySQL(String url, String dbUser, String dbPassword) { this.url = url; this.dbUser = dbUser; this.dbPassword = dbPassword; } public static MyAppDaoMySQL getInstance(String url, String dbUser, String dbPassword) { //lazy instantiation if (uniqueInstance == null) { uniqueInstance = new MyAppDaoMySQL(url, dbUser, dbPassword); } return uniqueInstance; } Key here is the private constructor which guarantees ony code within class MyAppDaoMySQL can instantiate its objects, and it does so only once. This solution is simple, but not thread safe!. In a later course, we’ll revisit this. 36.5 Use in a servlet environment Here is the relevant servlet code: protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { final MyAppDao dataSource = MyAppDaoFactory.getDataSource(); try { final User user = dataSource.getUser(&quot;Henk&quot;, &quot;Henkie&quot;); final TemplateEngine templateEngine = WebConfig.getTemplateEngine(); WebContext ctx = new WebContext(request, response, request.getServletContext(), request.getLocale()); ctx.setVariable(&quot;user&quot;, user); templateEngine.process(&quot;user-details&quot;, ctx, response.getWriter()); } catch (DatabaseException e) { e.printStackTrace(); } and the thymeleaf view: &lt;!DOCTYPE html SYSTEM &quot;http://www.thymeleaf.org/dtd/xhtml1-strict-thymeleaf-4.dtd&quot;&gt; &lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot; xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt; &lt;head&gt; &lt;title&gt;Show user&lt;/title&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot; /&gt; &lt;script src=&quot;js/myPage.js&quot; type=&quot;application/javascript&quot;&gt;&lt;/script&gt; &lt;/head&gt; &lt;body&gt; &lt;!-- welcome message read from resource bundle welcome.html--&gt; &lt;h2 th:text=&quot;&#39;Welcome &#39; + ${user.name}&quot;&gt;&lt;/h2&gt; &lt;h3 th:text=&quot;&#39;Your account email: &#39; + ${user.email}&quot;&gt;&lt;/h3&gt; &lt;h3 th:text=&quot;&#39;Your Role: &#39; + ${user.role.name}&quot;&gt;&lt;/h3&gt; &lt;/body&gt; &lt;/html&gt; Below you see the results with the two different values for the same web.xml context-param entry. The code does not know which implementation is running. db-type=mysql Here, the MySQL database is queried: Datasourse MySQL db-type=dummy And this queries the internal dummy database: Datasource Dummy This constitutes the final layer in the app: the data layer: MVC "],["a-simple-web-service-using-ajax.html", "Chapter 37 A simple web service using Ajax 37.1 Introduction", " Chapter 37 A simple web service using Ajax 37.1 Introduction Modern web applications are often composed of a “main” backend controller serving the view and “helper” backend controllers serving only data for (updating) parts of the view. Many web apps have even taken this further; the backend only serves an initial view and is mainly responsible for serving data packages. The Javascript library Vue.js is a good example of this. In this post, we’ll start simple, building a very basic web service and a simple consumer of the service. Focus is still on the backend. You will see a dedicated servlet using the GSON (Google JSON) library to convert Java objects to JSON (JavaScript Object Notation), and a client that requests and processes this data. 37.1.1 The components of Ajax JSON JSON – JavaScript Object Notation is the best format to exchange data from one web-based system to another It is very much like a complex map literal. Here is an example that holds data on some movies: {&quot;errorMessage&quot;: &quot;NO ERRORS&quot;, &quot;responseObject&quot;: [ {&quot;title&quot;: &quot;The Shawshank Redemption&quot;, &quot;year&quot;: 1994, &quot;rating&quot;: 9.2, &quot;mainActors&quot;: [&quot;Morgan Freeman&quot;, &quot;Tim Robbins&quot;] }, {&quot;title&quot;: &quot;The Dark Knight&quot;, &quot;year&quot;: 2008, &quot;rating&quot;: 9.0, &quot;mainActors&quot;: [&quot;Christian Bale,&quot;, &quot;Heath Ledger&quot;] } ] } Most browsers have a nice default representation of JSON, as long as you specify the correct content-type when formatting the servlet response: response.setContentType(&quot;application/json;charset=UTF-8&quot;); The view This is the view that is going to consume the movies Ajax service: &lt;!DOCTYPE html SYSTEM &quot;http://www.thymeleaf.org/dtd/xhtml1-strict-thymeleaf-4.dtd&quot;&gt; &lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot; xmlns:th=&quot;http://www.thymeleaf.org&quot;&gt; &lt;head&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot;/&gt; &lt;title&gt;Movie addict&lt;/title&gt; &lt;link rel=&quot;stylesheet&quot; th:href=&quot;@{/css/main.css}&quot; href=&quot;../../css/main.css&quot;&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;I am a movie addict&lt;/h1&gt; &lt;p&gt; Hi, welcome to my blog about movies. Just don&#39;t get hooked :-) &lt;/p&gt; &lt;div&gt; &lt;h3&gt;Review: Aquaman Is Good Enough&lt;/h3&gt; &lt;p&gt;Aquaman spans the vast, visually breathtaking underwater world of the seven seas and reveals the origin story of half-human, half-Atlantean Arthur Curry (Jason Momoa), which takes him on the journey of his lifetime—one that will not only force him to face who he really is, but to discover if he ... &lt;a href=&quot;#&quot;&gt;[Read More]&lt;/a&gt;&lt;/p&gt; &lt;/div&gt; &lt;!--more movies--&gt; &lt;div&gt; &lt;h3&gt;&lt;span&gt;A random movie from the IMDB top 500&lt;/span&gt;&lt;/h3&gt; &lt;div id=&quot;random_movie&quot;&gt; &lt;span&gt;Click the button to show info on one of the best movies ever made!&lt;/span&gt; &lt;br/&gt; &lt;/div&gt; &lt;button id=&quot;get_random_movie&quot;&gt;Get me one!&lt;/button&gt; &lt;/div&gt; &lt;div&gt; &lt;h3&gt;Five Greatest Gambling Movies Ever Made&lt;/h3&gt; &lt;p&gt;Everybody needs a role model. Even we gamblers are looking at the silver screen trying to find a hero worth looking up to. And not even the best online casino could help it. We want to see a decisive person able to make their own luck, someone, who takes a ...&lt;a href=&quot;#&quot;&gt;[Read More]&lt;/a&gt;&lt;/p&gt; &lt;/div&gt; &lt;!--more movies--&gt; &lt;script src=&quot;https://code.jquery.com/jquery-3.3.1.min.js&quot; integrity=&quot;sha256-FgpCb/KJQlLNfOu91ta32o/NMZxltwRo8QtmkMRdAu8=&quot; crossorigin=&quot;anonymous&quot;&gt;&lt;/script&gt; &lt;script type=&quot;application/javascript&quot;&gt; function processMovie(result){ console.log(&quot;processing &quot; + JSON.stringify(result)); var movie = result.responseObject; var movieHtml = &quot;&lt;h3&gt;&quot; + movie.title + &quot; (&quot; + movie.year + &quot;)&lt;/h3&gt;&quot;; movieHtml += &quot;IMDB rating: &quot; + movie.rating + &quot;&lt;br /&gt;Main actors &lt;br /&gt;&quot;; $.each(movie.mainActors, function(i, actor){ movieHtml += &quot;&amp;nbsp;&amp;nbsp;&amp;nbsp;&amp;nbsp;&quot; + (i+1) + &quot;. &quot; + actor + &quot;&lt;br /&gt;&quot;; }); movieHtml += &quot;&lt;br /&gt;&quot; console.log(movieHtml) $(&quot;#random_movie&quot;).html(movieHtml); $(&quot;#get_random_movie&quot;).text(&quot;Get another one!&quot;); } function getRandomMovie() { console.log(&quot;fetching movie&quot;); var movie_url = &quot;movie_service?request_type=random&quot;; jQuery.getJSON({ url:movie_url, success: function(result) { processMovie(result); } }); }; $(&quot;#get_random_movie&quot;).click(getRandomMovie); &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; There are several things to note: - The “Read More” links are dummies. - There are two &lt;script&gt; tags: - one loading the jQuery javascript library - one for handling the button-click event: $(\"#get_random_movie\").click(getRandomMovie); - The getRandomMovie() function forms an Ajax request for the resource movie_service with request parameter ?request_type=random. - The processMovie() function is responsible for converting the JSON object it receives from the backend into an html view. This is how the page looks in the browser movie blog JSON served by servlet In order to serve JSON from a servlet, you simply need to skip the view part. Instead, directly write your result to the browser. The Google GSON library is a big help: it can transform your Java object graph into a correct JSON representation. For the above movies example, I created a simple (inner) data class to represent my response: private static class JsonResponse { String errorMessage = &quot;NO ERRORS&quot;; String responseType = &quot;movie&quot;; Object responseObject; } And this is how it is created and converted into JSON using the GSON library: protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { String requestType = request.getParameter(&quot;request_type&quot;); response.setContentType(&quot;application/json;charset=UTF-8&quot;); final PrintWriter writer = response.getWriter(); JsonResponse jsonResponse = new JsonResponse(); if (requestType.equals(&quot;best&quot;)) { //code omitted for brevity } else if (requestType.equals(&quot;random&quot;)) { List&lt;Movie&gt; movies = Movie.getAllMovies(); Movie selected = movies.get((int)(Math.random() * movies.size())); jsonResponse.responseType = &quot;movie&quot;; jsonResponse.responseObject = selected; } else { jsonResponse.errorMessage = &quot;unknown request_type: &quot; + requestType; } //convert to JSON and write to response Gson gson = new Gson(); writer.write(gson.toJson(jsonResponse)); writer.flush(); } That’s it. An Ajax service serving a single page element. No page refresh needed for updating the view. When the button is clicked: movie blog You can also test the service without any view: simply request the resource: michiel@Michiels-MBP:~/onedrive_java/java_gitbook$ curl http://localhost:8080/movie_service?request_type=random {\"errorMessage\":\"NO ERRORS\",\"responseType\":\"movie\",\"responseObject\":{\"title\":\"Forrest Gump\",\"year\":1994,\"rating\":8.7,\"mainActors\":[\"Tom Hanks\",\"Robin Wright\",\"Gary Sinise\"]}} Or in your browser: paste the url in the location bar: movie blog (This is the Firefox rendering) "],["web-filters-and-file-uploads.html", "Chapter 38 Web filters and File uploads 38.1 Web filters 38.2 File uploads", " Chapter 38 Web filters and File uploads This is the last post in this course. It deals with two loose ends: uploading files and intercepting requests. 38.1 Web filters Suppose you want to intercept requests for a (group of) servlets, to log what is requested and where it came from. For instance, to do analyse the web traffic later on in order to pinpoint the most used resources. Or more relevant: intercept requests to asses authentication status of the user. And reject a request if the user is not authorized to see a resource. A basic example Here is our old friend, the PhraseServlet (only relevant code show): package nl.bioinf.wis_on_thymeleaf.servlets; @WebServlet(name = &quot;PhraseServlet&quot;, urlPatterns = &quot;/give.phrase&quot;) public class PhraseServlet extends HttpServlet { private TemplateEngine templateEngine; protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { String phraseType = request.getParameter(&quot;phrase_category&quot;); Locale locale = request.getLocale(); WebContext ctx = new WebContext(request, response, request.getServletContext(), locale); String phrase = PhraseFactory.getPhrase(phraseType); ctx.setVariable(&quot;phrase_type&quot;, phraseType); ctx.setVariable(&quot;phrase_num&quot;, phrase); templateEngine.process(&quot;phrase_of_the_day&quot;, ctx, response.getWriter()); } } This is the way to keep track of requests for /give.phrase; a @WebFilter annotation on a class implementing javax.servlet.Filter does the trick: package nl.bioinf.wis_on_thymeleaf.webfilters; import javax.servlet.*; import javax.servlet.annotation.WebFilter; import javax.servlet.http.HttpServletRequest; import java.io.IOException; @WebFilter(urlPatterns = &quot;/give.phrase&quot;) public class PhraseServletFilter implements Filter{ @Override public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException { if (request instanceof HttpServletRequest) { System.out.println(&quot;Request for &quot; + ((HttpServletRequest)request).getRequestURL().toString()); System.out.println(&quot;Query: &quot; + ((HttpServletRequest)request).getQueryString()); System.out.println(&quot;Remote address: &quot; + request.getRemoteAddr()); } try { //pass on the request after you are done chain.doFilter(request, response); } catch (Exception e) { e.printStackTrace(); } } @Override public void init(FilterConfig filterConfig) throws ServletException { /*not interesting here*/ } @Override public void destroy() { /*not interesting here*/ } } Whe the /give.phrase?phrase_category=bullshit resource is requested, the Tomcat logs show Request for http://localhost:8080/give.phrase Query: phrase_category=bullshit Remote address: 0:0:0:0:0:0:0:1 Check for authentication Suppose you have an application with a few public pages and a few pages for which authentication is required. This is a typical use case for WebFilter. package nl.bioinf.wis_on_thymeleaf.webfilters; import javax.servlet.*; import javax.servlet.annotation.WebFilter; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import javax.servlet.http.HttpSession; import java.io.IOException; @WebFilter(urlPatterns = {&quot;/user.dashboard&quot;, &quot;/list.secrets&quot;}) //use &quot;/*&quot; for catch-all public class AuthenticationFilter implements Filter { @Override public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException, ServletException { if (request instanceof HttpServletRequest) { HttpServletRequest req = ((HttpServletRequest)request); System.out.println(&quot;[AuthenticationFilter] Intercepted URL: &quot; + req.getRequestURL().toString()); final HttpSession session = req.getSession(); if (session.getAttribute(&quot;user&quot;) == null) { System.out.println(&quot;[AuthenticationFilter] no authenticated user: redirecting to /login&quot;); ((HttpServletResponse)response).sendRedirect(&quot;/login&quot;); } else { System.out.println(&quot;[AuthenticationFilter] authenticated status checked; user= &quot; + session.getAttribute(&quot;user&quot;)); try { chain.doFilter(request, response); } catch (Exception e) { e.printStackTrace(); } } } } @Override public void init(FilterConfig filterConfig) throws ServletException { /*not interesting here*/ } @Override public void destroy() { /*not interesting here*/ } } Here is the output after a few requests [AuthenticationFilter] Intercepted URL: http://localhost:8080/list.secrets [AuthenticationFilter] no authenticated user: redirecting to /login &lt;logged in as Henk&gt; [AuthenticationFilter] Intercepted URL: http://localhost:8080/list.secrets [AuthenticationFilter] authenticated status checked; user= User{name='Henk', email='henk@example.com', password='null', role=USER} [AuthenticationFilter] Intercepted URL: http://localhost:8080/user.dashboard [AuthenticationFilter] authenticated status checked; user= User{name='Henk', email='henk@example.com', password='null', role=USER} 38.2 File uploads File Upload is an essential feature! Many websites provide some form of upload functionality: - Photos &amp; Video - Data - Configuration Fortunately, uploading is boilerplate code! The harder thing is: what will you do with the file? - Into database - Store locally - Process directly Upload form Suppose we want to offer a scv data upload. Here is the html for uploading csv data. Key are enctype=\"multipart/form-data\" in the form tag and the &lt;input type=\"file\" name=\"scv_data\" accept=\"text/csv\"&gt; tag. &lt;form th:action=&quot;@{&#39;data_upload&#39;}&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt; &lt;input type=&quot;file&quot; name=&quot;scv_data&quot; accept=&quot;text/csv&quot;&gt; &lt;input type=&quot;submit&quot; value=&quot;Upload&quot; /&gt; &lt;/form&gt; The servlet handling the file upload needs to be annotated as such: @MultipartConfig(location=&quot;/tmp&quot;, fileSizeThreshold = 1024 * 1024, maxFileSize = 1024 * 1024 * 5, maxRequestSize = 1024 * 1024 * 5 * 5) @WebServlet(name = &quot;FileUploadServlet&quot;, urlPatterns = &quot;/data_upload&quot;) public class FileUploadServlet extends HttpServlet { //class body } The @MultipartConfig annotation has several parameters: location: An absolute path to a directory on the file system. This location is used to store files temporarily while the parts are processed or when the size of the file exceeds the specified fileSizeThreshold setting. The default location is \"\". fileSizeThreshold: The file size in bytes after which the file will be temporarily stored on disk. The default size is 0 bytes. maxFileSize: The maximum size allowed for uploaded files, in bytes. If the size is greater, the container will throw an exception (IllegalStateException). The default size is unlimited. maxRequestSize: The maximum size allowed for a multipart/form-data request, in bytes. The web container will throw an exception if the overall size of all uploaded files exceeds this threshold. The default size is unlimited. Instead of hardcoding the constraints, you can also put them in web.xml: &lt;servlet-mapping&gt; &lt;servlet-name&gt;FileUploadServlet&lt;/servlet-name&gt; &lt;url-pattern&gt;/data_upload&lt;/url-pattern&gt; &lt;/servlet-mapping&gt; &lt;servlet&gt; &lt;servlet-name&gt;FileUploadServlet&lt;/servlet-name&gt; &lt;servlet-class&gt;nl.bioinf.wis_on_thymeleaf.servlets.FileUploadServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;upload_dir&lt;/param-name&gt; &lt;param-value&gt;/path/to/file/upload&lt;/param-value&gt; &lt;/init-param&gt; &lt;multipart-config&gt; &lt;location&gt;/path/to/tmp/tmp&lt;/location&gt; &lt;!-- all in bytes --&gt; &lt;max-file-size&gt;20848820&lt;/max-file-size&gt; &lt;max-request-size&gt;418018841&lt;/max-request-size&gt; &lt;file-size-threshold&gt;1048576&lt;/file-size-threshold&gt; &lt;/multipart-config&gt; &lt;/servlet&gt; Here is the servlet dealing with the uploads. The final upload location is specified using an init-param in the web.xml deployment descriptor of course. package nl.bioinf.wis_on_thymeleaf.servlets; import nl.bioinf.wis_on_thymeleaf.config.WebConfig; import org.thymeleaf.TemplateEngine; import org.thymeleaf.context.WebContext; import javax.servlet.ServletException; import javax.servlet.http.Part; import javax.servlet.annotation.WebServlet; import javax.servlet.http.HttpServlet; import javax.servlet.http.HttpServletRequest; import javax.servlet.http.HttpServletResponse; import java.io.File; import java.io.IOException; //moved to web.xml //@MultipartConfig(location=&quot;/tmp&quot;, // fileSizeThreshold = 1024 * 1024, // maxFileSize = 1024 * 1024 * 5, // maxRequestSize = 1024 * 1024 * 5 * 5) @WebServlet(name = &quot;FileUploadServlet&quot;, urlPatterns = &quot;/data_upload&quot;) public class FileUploadServlet extends HttpServlet { private TemplateEngine templateEngine; private String uploadDir; @Override public void init() throws ServletException { this.templateEngine = WebConfig.getTemplateEngine(); this.uploadDir = getInitParameter(&quot;upload_dir&quot;); //or, use relative to this app: // gets absolute path of the web application //String applicationPath = getServletContext().getRealPath(&quot;&quot;); //String uploadFilePath = applicationPath + File.separator + uploadDir; } protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { //simply go back to upload form WebContext ctx = new WebContext(request, response, request.getServletContext(), request.getLocale()); templateEngine.process(&quot;upload_form&quot;, ctx, response.getWriter()); } protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException { File fileSaveDir = new File(this.uploadDir); if (! fileSaveDir.exists()) { throw new IllegalStateException(&quot;Upload dir does not exist: &quot; + this.uploadDir); } //Do this only if you are sure there won&#39;t be any file name conflicts! //An existing one will simply be overwritten // String fileName; // for (Part part : request.getParts()) { // fileName = part.getSubmittedFileName(); // part.write(this.uploadDir + File.separator + fileName); // } //the safe way, with a generated file name becomes something like this //my_app_upload14260971264207930189.csv File generatedFile = File.createTempFile(&quot;my_app_upload&quot;, &quot;.csv&quot;); for (Part part : request.getParts()) { part.write(this.uploadDir + File.separator + generatedFile.getName()); } //go back to the upload form WebContext ctx = new WebContext(request, response, request.getServletContext(), request.getLocale()); ctx.setVariable(&quot;message&quot;, &quot;upload successfull, wanna do another on?&quot;); templateEngine.process(&quot;upload_form&quot;, ctx, response.getWriter()); } } If you want to be sure files won’t get overwritten, you should use random generated file names, as in the above code example. "],["exercises-intro.html", "Chapter 39 Exercises intro 39.1 Implementing MVC 39.2 Thymeleaf 39.3 Sessions 39.4 Authentication 39.5 Servlet details and hooks 39.6 Database interaction 39.7 Ajax 39.8 Filters", " Chapter 39 Exercises intro These exercises accompany the course Web-based Information Systems. After the first exercise, we will work on a single project that we will improve and extend iteratively as new information becomes available. 39.1 Implementing MVC Goal: Create a web application that gives the heart rate zones based on the maximum heart rate. Background The maximum heart rate can be determined by running (preferably on a treadmill but outside will do) as fast as you can for 3 minutes straight, followed by a three-minute gentle run and again 3 minutes full force. Optionally, add another cycle. The maximum reading is the maximum heart rate. The heart rate zones can be calculated by this rule set, giving zone boundaries and descriptions as % of maximum heart rate: - zone 1: 50-60% Low heart rate with hardly any training effect - zone 2: 60-70% Heart rate with positive effect on breathing and stress reduction - zone 3: 70-80% Heart rate with optimal training effect with respect to fat burning, general condition and brain functioning - zone 4: 80-90% Zone for improving (long-distance) running speed - zone 5: 90-100% Above anaerobic threshold; only during interval training to increase speed (also for shorter distances). The exercise All texts in this app should be located in the resource bundle(s), not in the html and neither in the Java classes. Create appropriate packages for your Java classes. Start by creating a new Gradle-managed web project. Create the servlet dealing with the url /heart-rate-zones. Its doGet() method should forward to a Thymeleaf html page. In this Thymeleaf page, create a form asking the user for her maximum heart rate (and giving usage instructions). It should support both Dutch and English. The form should direct back to the servlet serving url /heart-rate-zones, but this time to the doPost() method. In the doPost() method, the servlet should invoke a model class responsible for calculating the correct heart rate zones. These zones should be displayed in another html Thymeleaf view, again supporting the languages Dutch and English. Note: yes this could have been done more efficiently using Javascript, but we are working with Java for now. 39.2 Thymeleaf Goal: Create a “SpeciesBrowser” web application that publishes information on some species from your favorite animal or plant group. Background This assignment will encourage you to use as many Thymeleaf expressions as possible, as well as resource bundles. As preparation, you should choose an animal or plant group that you think is interesting. From this group of organisms, choose at least 5 representatives and gather some relevant information, as well as one picture for each species. The information should include at least: - Scientific name - English name - Dutch name Here is an example of one of my favorite birds, the steppe eagle (copied from Wikipedia): Steppe eagle (Aquila nipalensis) Dutch name: Steppearend (By T. R. Shankar Raman - Own work, CC BY-SA 3.0, Link) Description The steppe eagle (Aquila nipalensis) is a bird of prey. Like all eagles, it belongs to the family Accipitridae. It was once considered to be closely related to the non-migratory tawny eagle (Aquila rapax) and the two forms have previously been treated as conspecific. They were split based on pronounced differences in morphology and anatomy. Wing span: 1.65–2.15 meters Occurrence It is a migratory bird breeding in eastern Europe, the Middle East and Asia and wintering in Africa and South Asia. Conservation status Threatened (declining populations) Note, you are also allowed to gather “famous biologists”. The exercise Start by creating a new Gradle-managed web project. Add git versioning support and create a remote (Bitbucket or Github). Create a simple “csv” file in a data folder that holds, for each species, all non-internationalized textual data. Here is my Steppe Eagle example: scientific_name;english_name;dutch_name;wing_span_avg;picture_loc Aquila nipalensis;Steppe Eagle;steppearend;1.9;figures/steppe_eagle.jpg Collect all other (textual) data in a resource bundle, supporting both English and Dutch. This concerns primarily text labels and page content, but also species descriptions. Design and implement Java classes that model your information. In this case, class Raptor or Bird would be nice. Also, think about the way your objects are going to be managed. Should they be retrievable by name or something? Create a “CollectionClass” that supports this usage. Create a class that can parse your csv file into a “CollectionClass”, holding a collection of instances representing your species. Create a servlet serving url /home that redirects to a Thymeleaf page called species-listing.html. This page should list all available species in a table, providing for each species a hyperlink to a species-detail page (look at the html cheat sheet how to do this). The link should point to url /species.detail. This is a Thymeleaf example: &lt;a th:href=&quot;@{&#39;/species.detail?species=&#39; + ${species.name}}&quot; th:text=&quot;${species.name}&quot;&gt;&lt;/a&gt; This page should be internationalized for Dutch and English of course. Create a servlet serving url /species.detail that directs to a Thymeleaf page showing the detailed information of a selected species (linked via the table created before), as well as a nice picture of course. This page is also internationalized. Tag the final version of the repo as 0.1.0. and commit this to your remote. [Challenge] Use Bootstrap to make the two pages look nice as well, or apply your own styling. You are of course free to extend the information with whatever you think is nice. 39.3 Sessions Goal: Modify a web application to support browsing history. Background The web app that was developed in the previous exercise is very static and impersonal. We’ll add some functionality to fix that. What we’ll do: - add browsing history support - put this history in an include that is shown on both pages The exercise First open the “SpeciesBrowser” web app project of the previous exercise. I don’t know where you put your data file location in your code, but it is time to move this to web.xml. Modify the servlet serving /home so that it will create a session object when first requested by a user. Create an appropriate data structure (read: class) to hold browsing history of only the last 5 page views, and attach this to the user’s session object. Whenever the user views the details page of a species, add this species to the history. Create an included div fragment in a file called template.html that will display the history listing. Show the history listing by including the div as a separate panel in both your Thymeleaf templates (the listing and the details page). Tag the final version of the repo as 0.2.0. and commit this to your remote. 39.4 Authentication Background We continue working on the “SpeciesBrowser” web app. What we’ll do: - add login functionality - provide a web form to edit species data for registered users The exercise Create a User class that will model your web app users. Create a “mock” database containing 3 users. Create a login page that directs to a servlet with url mapping /login. Create the login servlet. Verify the user credentials. If correct, redirect to /home (the species listing). Else, redirect back to login.html, giving the user a warning that the provided credentials were incorrect. In the species detail page, add a button -only when there is an authorized user- that will open a page in which the species information can be edited. Note: editing information that is contained within resource bundles is not possible! Choose other information fields. Create the editing form. Tag the final version of the repo as 0.3.0. and commit this to your remote. [Challenge 1] Process the edited data coming from the above form and add support for writing species data to file. [Challenge 2] Add registration functionality. 39.5 Servlet details and hooks We continue working on the “SpeciesBrowser” web app. Goal: Further refactoring to improve performance and maintainability. Background We’ll work at optimizing the app. So far, you probably have loaded the entire data file at each request. This is of course highly inefficient. Let’s move this to a @WebListener method. The exercise Modify your “CollectionClass” so that it will serve your species collection in a static manner. This means the method should be class level. Implement the ServletContextListener interface and add the @WebListener annotation. In the contextInitialized() method, have the “CollectionClass” load the species data collection. Refactor the rest of the app to only use this static method. Tag the final version of the repo as 0.4.0. and commit this to your remote. 39.6 Database interaction We continue working on the “SpeciesBrowser” web app. Goal: Add a replaceable MySQL data layer. Background We’ll work at extending the app. The species information located in the csv file will be migrated to a MySQL data layer and abstracted away behind an interface. As a prerequisite, it is assumed you have a MySQL database server and -account. The exercise Add support for MySQL/JDBC in your project. Design the database table(s) and create them. Design an interface declaring the public contract for your species information datasource, whatever the nature of that datasource. Have your original “CollectionClass” implement this interface. Make a MySQL implementer of the same interface. Implement it using the Singleton Pattern. ([Challenge] make it thread-safe) Create a factory class that serves the correct implementer based on a setting in the web.xml file. Refactor your code base to only “talk to” the interface served by the factory class. [Challenge] Also migrate the user data (and species detail information) to this database. Tag the final version of the repo as 0.5.0. and commit this to your remote. 39.7 Ajax We continue working on the “SpeciesBrowser” web app. Goal: Add an Ajax data service. Background In this exercise, you will create a “microservice” that will serve species details to be used as a remote API in other apps. The exercise Add support for Googles’ Gson library to your Gradle file. Create a servlet that maps to /species_info. The servlet should only support GET requests. As request parameters, accept species=&lt;name_or_substring&gt; and info=&lt;short|long&gt;, where short will only return the species names and “short” data fields that are present in the database of those species where (one of) the name(s) match the given string. [Challenge] The long option will return the species description. You should figure out how to read this from the resource bundle. Design an appropriate response if the data layer is unresponsive, there were unsupported parameters provided or there is no species that matches. Test it out using curl and your web browser. Tag the final version of the repo as 0.6.0. and commit this to your remote. 39.8 Filters We continue working on the “SpeciesBrowser” web app. Goal: Add extra security using filters. Background In this exercise, you will finish the app by creating a Filter that intercepts requests for the species editing form. The exercise Create a @WebFilter implementing the Filter interface so that requests for the species editing form are intercepted and only pass for logged-in users. When the request does not come from a logged-in user, redirect back to /login. Remove the redundant code from the servlet. Tag the final version of the repo as 1.0.0. with name “Release Candidate” and commit this to your remote. "],["html5-tags.html", "Chapter 40 HTML5 tags", " Chapter 40 HTML5 tags Below is an alphabetic listing of the most important (most-used) html5 tags that may be relevant on the test of the module webbased information systems 1. The information presented in this page is mostly copied from the site w3schools. Links: &lt;a&gt; The &lt;a&gt; tag defines a hyperlink, which is used to link from one page to another. Most important attribute is href which specifies the URL the link goes to. Example &lt;a href=&quot;https://www.w3schools.com&quot;&gt;Visit W3Schools.com!&lt;/a&gt; Visit W3Schools.com! Page body: &lt;body&gt; The &lt;body&gt; tag defines the document’s body. The &lt;body&gt; element contains all the contents of an HTML document, such as text, hyperlinks, images, tables, lists, etc. &lt;html&gt; &lt;head&gt; &lt;title&gt;Title of the document&lt;/title&gt; &lt;/head&gt; &lt;body&gt; The content of the document...... &lt;/body&gt; &lt;/html&gt; Line breaks: &lt;br&gt; The &lt;br&gt; tag inserts a single line break. The &lt;br&gt; tag is an empty tag which means that it has no end tag. In HTML, the &lt;br&gt; tag has no end tag. In XHTML, the tag must be properly closed, like this: &lt;br /&gt;. This text contains&lt;br&gt;a line break. This text containsa line break. A clickable button: &lt;button&gt; Inside a &lt;button&gt; element you can put content, like text or images. This is the difference between this element and buttons created with the &lt;input&gt; element. &lt;button type=&quot;button&quot;&gt;Click Me!&lt;/button&gt; Click Me! The most important attributes are - value, which specifies the initial value (text). - type, the type that can be either button, reset or submit Predefined text types The &lt;code&gt; tag is a phrase tag. It defines a piece of computer code.Other simalar types of tags are included in the fragment below. &lt;em&gt;Emphasized text&lt;/em&gt;&lt;br&gt; &lt;strong&gt;Strong text&lt;/strong&gt;&lt;br&gt; &lt;code&gt;A piece of computer code&lt;/code&gt;&lt;br&gt; &lt;samp&gt;Sample output from a computer program&lt;/samp&gt;&lt;br&gt; &lt;kbd&gt;Keyboard input&lt;/kbd&gt;&lt;br&gt; &lt;var&gt;Variable&lt;/var&gt; Emphasized text Strong text A piece of computer code Sample output from a computer program Keyboard input Variable Here are all “phrase” tags: &lt;em&gt; Renders as emphasized text &lt;strong&gt; Defines important text &lt;code&gt; Defines a piece of computer code &lt;samp&gt; Defines sample output from a computer program &lt;kbd&gt; Defines keyboard input &lt;var&gt; Defines a variable Page section: &lt;div&gt; The &lt;div&gt; tag defines a division or a section in an HTML document. The &lt;div&gt; element is often used as a container for other HTML elements to style them with CSS or to perform certain tasks with JavaScript. &lt;div style=&quot;background-color:lightblue&quot;&gt; &lt;h4&gt;This is a heading&lt;/h4&gt; &lt;p&gt;This is a paragraph.&lt;/p&gt; &lt;/div&gt; This is a heading This is a paragraph. A description list: &lt;dl&gt;, &lt;dd&gt; &amp; &lt;dt&gt; A description list, with terms and descriptions. The &lt;dl&gt; tag defines a description list. The &lt;dl&gt; tag is used in conjunction with &lt;dt&gt; (defines terms/names) and &lt;dd&gt; (describes each term/name). &lt;dl&gt; &lt;dt&gt;Coffee&lt;/dt&gt; &lt;dd&gt;Black hot drink&lt;/dd&gt; &lt;dt&gt;Milk&lt;/dt&gt; &lt;dd&gt;White cold drink&lt;/dd&gt; &lt;/dl&gt; Coffee Black hot drink Milk White cold drink Forms and its elements The &lt;form&gt; tag is used to create an HTML form for user input. The &lt;form&gt; element can contain one or more of the following form elements: &lt;input&gt; &lt;textarea&gt; &lt;button&gt; &lt;select&gt; &lt;option&gt; &lt;label&gt; (there are more but these are not relevant for this course). The most important attributes are its action (the URL to submit to), its method (GET or POST) and its enctype when submitting for file uploads. Here is a typical form demonstrating these elements. Note the different attributes for the input element. &lt;form action = &quot;#&quot;, method = &quot;post&quot;&gt; &lt;label for=&quot;username-field&quot;&gt;Username&lt;/label&gt;:&lt;br&gt; &lt;input id=&quot;username-field&quot; type=&quot;text&quot; name=&quot;username&quot; minlength=&quot;5&quot; maxlength=&quot;20&quot;&gt;&lt;br&gt; &lt;label for=&quot;password-field&quot;&gt;Username&lt;/label&gt;:&lt;br&gt; &lt;input id=&quot;password-field&quot; type=&quot;password&quot; name=&quot;password&quot; minlength=&quot;5&quot; maxlength=&quot;20&quot;&gt;&lt;br&gt; &lt;label for=&quot;email-field&quot;&gt;Email&lt;/label&gt;:&lt;br&gt; &lt;input id=&quot;email-field&quot; type=&quot;email&quot; name=&quot;email&quot;&gt;&lt;br&gt; &lt;br&gt; Favourite animals (more than one can be selected)&lt;br&gt; &lt;select name=&quot;favorite-animal&quot; size=&quot;3&quot; multiple&gt; &lt;option name=&quot;cheetah&quot;&gt;Cheetah&lt;/option&gt; &lt;option name=&quot;lion&quot;&gt;Lion&lt;/option&gt; &lt;option name=&quot;platypus&quot;&gt;Platypus&lt;/option&gt; &lt;option name=&quot;goat&quot;&gt;Goat&lt;/option&gt; &lt;option name=&quot;coyote&quot;&gt;Coyote&lt;/option&gt; &lt;option name=&quot;skunk&quot; selected&gt;Skunk&lt;/option&gt; &lt;/select&gt; &lt;br&gt;&lt;br&gt; &lt;textarea name=&quot;message&quot; rows=&quot;10&quot; cols=&quot;30&quot;&gt;My favourite animal is the &amp;lt;fill in&amp;gt; because (FINISH). &lt;/textarea&gt; &lt;br&gt; Gender: &lt;br&gt; &lt;input id=&quot;gendermale&quot; type=&quot;radio&quot; name=&quot;gender&quot; value=&quot;male&quot;&gt; &lt;label for=&quot;gendermale&quot;&gt;Male&lt;/label&gt; &lt;input id=&quot;genderfemale&quot; type=&quot;radio&quot; name=&quot;gender&quot; value=&quot;female&quot;&gt; &lt;label for=&quot;genderfemale&quot;&gt;Female&lt;/label&gt; &lt;input id=&quot;genderother&quot; type=&quot;radio&quot; name=&quot;gender&quot; value=&quot;other&quot;&gt; &lt;label for=&quot;genderother&quot;&gt;Other&lt;/label&gt; &lt;br&gt; &lt;input type=&quot;submit&quot; value=&quot;That&#39;s it!&quot;&gt; &lt;/form&gt; &lt;hr&gt; Username: Username: Email: Favourite animals (more than one can be selected) Cheetah Lion Platypus Goat Coyote Skunk My favourite animal is the &lt;fill in&gt; because (FINISH). Gender: Male Female Other Headers: &lt;h1&gt; - &lt;h6&gt; The default appearance of headers may vary between browsers. &lt;h1&gt;This is heading 1&lt;/h1&gt; &lt;h2&gt;This is heading 2&lt;/h2&gt; &lt;h3&gt;This is heading 3&lt;/h3&gt; &lt;h4&gt;This is heading 4&lt;/h4&gt; &lt;h5&gt;This is heading 5&lt;/h5&gt; &lt;h6&gt;This is heading 6&lt;/h6&gt; The non-rendered part of the DOM: &lt;head&gt; The head element is a container for all the head elements. The head element can include a title for the document, scripts, styles, meta information, and more. The following elements can go inside the head element: title (this element is required in an HTML document) style base link meta script noscript Separator for sections: &lt;hr&gt; &lt;h4&gt;This is before&lt;/h4&gt; &lt;hr&gt; &lt;h4&gt;This is after&lt;/h4&gt; This is before This is after The top level container: &lt;html&gt; The html tag tells the browser that this is an HTML document. The html tag represents the root of an HTML document. The html tag is the container for all other HTML elements (except for the !DOCTYPE tag). Images: &lt;img&gt; The &lt;img&gt; tag defines an image in an HTML page. The &lt;img&gt; tag has two required attributes: src and alt. Images are not technically inserted into an HTML page, images are linked to HTML pages. The &lt;img&gt; tag creates a holding space for the referenced image. Tip: To link an image to another document, simply nest the &lt;img&gt; tag inside &lt;a&gt; tags. Describe metadata: &lt;meta&gt; Metadata is data (information) about data. The &lt;meta&gt; tag provides metadata about the HTML document. Metadata will not be displayed on the page, but will be machine parsable. Meta elements are typically used to specify page description, keywords, author of the document, last modified, and other metadata. The metadata can be used by browsers (how to display content or reload page), search engines (keywords), or other web services. HTML5 introduced a method to let web designers take control over the viewport (the user’s visible area of a web page), through the &lt;meta&gt; tag. &lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;meta name=&quot;description&quot; content=&quot;Free Web tutorials&quot;&gt; &lt;meta name=&quot;keywords&quot; content=&quot;HTML,CSS,XML,JavaScript&quot;&gt; &lt;meta name=&quot;author&quot; content=&quot;John Doe&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1.0&quot;&gt; &lt;/head&gt; Ordered and unordered lists: &lt;ol&gt;, &lt;ul&gt;, &lt;li&gt; Ordered lists have numbering, unordered lists are not (usually bulleted lists). The main attributes of an ordered list are: - reversed - start the start number - type the number type. Possible values are 1 (the default), A, a, I, i. &lt;ol start=&quot;10&quot;, type=&quot;i&quot;&gt; &lt;li&gt;Coffee&lt;/li&gt; &lt;li&gt;Tea&lt;/li&gt; &lt;li&gt;Milk&lt;/li&gt; &lt;/ol&gt; Coffee Tea Milk The unordered list can only configure its symbol, but this is not generally supported in html5. &lt;ul type=&quot;square&quot;&gt; &lt;li&gt;Coffee&lt;/li&gt; &lt;li&gt;Tea&lt;/li&gt; &lt;li&gt;Milk&lt;/li&gt; &lt;/ul&gt; Coffee Tea Milk Paragraphs: &lt;p&gt; The &lt;p&gt; tag defines a paragraph. Browsers automatically add some space (margin) before and after each &lt;p&gt; element. The margins can be modified with CSS (with the margin properties). &lt;p style=&quot;border-style: dotted; text-align: center&quot;&gt;This is some text in a paragraph.&lt;/p&gt; This is some text in a paragraph. Scripts with &lt;script&gt; Usually you place scripts outside the html, but there are good uses for placing the code within script tags. &lt;div id=&quot;demo&quot;&gt;Hello World&lt;/div&gt; &lt;script&gt; document.getElementById(&quot;demo&quot;).innerHTML = &quot;Hello JavaScript!&quot;; &lt;/script&gt; Tables: &lt;table&gt; The &lt;table&gt; tag defines an HTML table. An HTML table consists of the &lt;table&gt; element and one or more &lt;tr&gt;, &lt;th&gt;, and &lt;td&gt; elements. The &lt;tr&gt; element defines a table row, the &lt;th&gt; element defines a table header, and the &lt;td&gt; element defines a table cell. A more complex HTML table may also include &lt;caption&gt;, &lt;col&gt;, &lt;colgroup&gt;, &lt;thead&gt;, &lt;tfoot&gt;, and &lt;tbody&gt; elements. Here is a table with the tags it can contain: &lt;table&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;Nucleotide&lt;/th&gt; &lt;th&gt;Name&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;tr&gt; &lt;td&gt;A&lt;/td&gt; &lt;td&gt;Adenine&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;C&lt;/td&gt; &lt;td&gt;Cytosine&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;G&lt;/td&gt; &lt;td&gt;Guanine&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;T&lt;/td&gt; &lt;td&gt;Thymine&lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt; &lt;/table&gt; Nucleotide Name A Adenine C Cytosine G Guanine T Thymine "],["junit-5-basics.html", "Chapter 41 JUnit 5 basics 41.1 Introduction 41.2 Reasons for unit testing 41.3 Running JUnit 5 tests using Gradle and IntelliJ 41.4 Document! 41.5 JUnit assert...() methods 41.6 Testing for Exceptions 41.7 Grouping assertions using assertAll()", " Chapter 41 JUnit 5 basics 41.1 Introduction In this post, we’ll address a topic that is subject to heated debate in development land: testing. Why would you spend a significant portion of your development time writing code to test other code? This will be addressed in more detail later, but think about this question first: How much of your time is lost on debugging and solving problems that could have been foreseen and prevented if you would have taken the time to think about “boundary” use cases of your methods? Several major Java unit testing frameworks exist, but we will explore JUnit since it is the most widely used. Also, the concepts you learn with JUnit are easily transferred to other frameworks. The unit in unit testing is the method - a named piece of reusable code. If designed well it does one thing only, and it does it well. When creating tests, we cover the software units (methods) of our code base with one or more test methods - unit tests or test cases. Here is an example to clarify the concept. Suppose you have class Polygon that has as field a list of Coordinate instances. Here is the Coordinate class: package nl.bioinf; public class Coordinate { private int x; private int y; //constructors, getters and setters omitted public double distanceTo(Coordinate other) { return Math.sqrt(Math.pow(this.x - other.x, 2) + Math.pow(this.y - other.y, 2)); } } And here is the Polygon class: package nl.bioinf; import java.util.List; public class Polygon { private List&lt;Coordinate&gt; coordinates; //constructors, getters and setters omitted public void addCoordinate(Coordinate coordinate) { if (coordinates == null) { coordinates = new LinkedList&lt;&gt;(); } this.coordinates.add(coordinate); } public double getLength() { double distance = 0; //calculate distance return distance; } } Now look at the Coordinate and Polygon classes and ask yourself: “Is this code robust?”. Can I think of usage scenario’s where one of these classes will fail? Or is there even a real bug in there? Take a minute and then read on. One thing that will immediately alert an experienced programmer is the instance variable in the Polygon class: it is being initialized in a “lazy” manner. There is a big fat NullPointerException lurking there. When the getLength() method is called on an object where no Coordinate has been added yet, coordinates will be null. This is the essence of JUnit testing: it makes you think about boundary cases like this, and will help you create robust code in a systematic way. A typical test covering this boundary case could be: package nl.bioinf; import org.junit.jupiter.api.Test; import static org.junit.jupiter.api.Assertions.assertEquals; public class PolygonTest { @Test public void getLength() { Polygon polygon = new Polygon(); double expectedLength = 0; assertEquals(expectedLength, polygon.getLength()); } } This test asserts that the length of an empty Polygon is zero - a good choice of expected behavior. Any other result, including a NullPointerException, will make the test fail. The next step is of course to modify method getLength() in such a way that it will pass this test. Here is a simple solution: public double getLength() { if (coordinates == null) return 0; else { double distance = 0; //calculate distance return distance; } } The how-to of creating and running tests in IntelliJ will be shown shortly. 41.2 Reasons for unit testing Test Driven Development (TDD) is today’s standard in software development. If you introduce new features, a solid test suite protects you against regression in existing code The approach we’ll take in this course is hand-in-hand development of test and production code. This is one school. The other believes that all test code should be written before any production code. These are the three main reasons for spending time and resources to create and run tests. For any function and given a set of inputs, we can determine if the function is returning the proper values and will gracefully handle failures during the course of execution should invalid input be provided. You’ll be writing code that is easy to test: you are more likely to have a higher number of smaller, more focused functions that provide a single operation rather than large functions performing a number of different operations Since you’re testing your code as you introduce new functionality, you can prevent changes and additions from breaking existing functionality (See tutsplus) 41.3 Running JUnit 5 tests using Gradle and IntelliJ First make sure you have the correct dependencies in your Gradle build file. Note that I already put two additional dependencies in there (AssertJ and JUnit Params) that will be needed for the next post. group &#39;nl.bioinf.nomi.appdesigndemos&#39; version &#39;1.0-SNAPSHOT&#39; apply plugin: &#39;java&#39; apply plugin: &#39;idea&#39; sourceCompatibility = JavaVersion.VERSION_1_10 repositories { mavenCentral() } dependencies { testCompile( testImplementation &#39;org.junit.jupiter:junit-jupiter-api:5.2.2&#39; testRuntimeOnly &#39;org.junit.jupiter:junit-jupiter-engine:5.5.2&#39; //for parameterized tests testImplementation &#39;org.junit.jupiter:junit-jupiter-params:5.5.2&#39; //for assertJ type assertions testImplementation &#39;org.assertj:assertj-core:3.13.2&#39; } //in some cases you need to put this in to get it running (I am not sure why...) test { useJUnitPlatform() } Next, create a class and method stub that should be unit tested. Suppose you are creating a class, TextUtils with method getLongestWord(String text) This is what it looks like without any functionality implemented: package nl.bioinf.junit5tests; public class TextUtils { /** * Finds the longest word in a given string. * If there is a tie, the last found longest * is returned. * * @param text the text to scan * @return longestWord */ public static String getLongestWord(String text) { throw new UnsupportedOperationException(&quot;Not implemented yet&quot;); } } Note that the programmer already thought about a single boundary case - the tie. This can be seen in the Javadoc. To create a test for this method, put the cursor on the class name, activate the context menu (alt + enter) and select “Create Test” Create JUnit test class 1 The destination package is nl.bioinf.junit.junit5demos - the same as the TextUtils class. This is an extremely important aspect since it puts the test class in the same package scope. Select the method you want to create a test for ant press “OK”. This will create a test class with the same name as your original class, but with “Test” appended. Although the test class is in the same package it will not be in the same folder. Instead, it will be located in the src/test folder while the original class is located under src/main. Since implementation and test code are in the same package scope, all non-private methods from the class to test are visible: public protected package-public (default) Only private scoped method will be invisible and therefore in principle untestable. Create JUnit test class 2 The test class will look like this. package nl.bioinf.junit.junit5demos; import org.junit.jupiter.api.Test; import static org.junit.jupiter.api.Assertions.*; class TextUtilsTest { @Test void getLongestWord() { } } Note the @Test annotation above the method signature. It makes this method recognizable as test method - it tells the JUnit runtime this is a JUnit test method. We’ll visit more JUnit -related annotations later on. This default method stub should never be kept as is; it will always pass! There is great danger in that (think about it). A much better default test stub is the one below as it will always fail because the fail() method will throw an error. @Test void getLongestWord() { fail(&quot;test not implemented yet&quot;); } In the editor margin, you see little green arrows (triangles): These represent the simplest way to run one or more tests. You find them next to the class name (run the entire test class) or besides a single test case. Hover one to see the hint. Run JUnit5 test 1 Click the arrow next to the test case and the Gradle daemon will run it. Of course it will fail - you specified that yourself. The test run panel will show both console output and a test run summary (in this case a single test). Run JUnit5 test 2 Now create some test code. The simplest is a so-called sunny-day scenario: a normal input where you expect unambiguous result. Here is an example: @Test public void getLongestWord() { final String input = &quot;Hello JUnit testing world&quot;; final String expected = &quot;testing&quot;; final String observed = TextUtils.getLongestWord(input); assertEquals(expected, observed); } Assertions are the fundaments on which unit testing is built. They are used to specify how you expect the code under test will behave given a set of conditions. one of the most basic ones is the assertEquals() assertion method that is also used in the snippet above. You use it like this: assertEquals(&lt;expected value&gt;, &lt;observed value&gt;); When the expected value does not equal the observed value (according to the equals() method of course), an error will be thrown. In this case, AssertionFailedError. The test will fail. Of course the test will still fail because the tested method throws an UnsupportedOperationException. The next snippet gives a naive implementation. public static String getLongestWord(String text) { String[] words = text.split(&quot; &quot;); String longest = &quot;&quot;; for (String word : words) { if (word.length() &gt;= longest.length()) { longest = word; } } return longest; } If you’re into it, you can also do it the Java8 / Functional Programming way: public static String getLongestWord(String text) { String[] words = text.split(&quot; &quot;); Optional&lt;String&gt; findFirst = Stream.of(words).sorted( (one, two) -&gt; Integer.compare(two.length(), one.length()) ).findFirst(); return findFirst.get(); } Given the above implementation(s), many programmers would think they are done. But you’re not! Can you think of use cases where the above code would break, or behave incorrectly? Again: This is a very important reason to test - it makes you think about other than sunny day scenarios. Take a minute to think about some useful tests that will demonstrate the reliability of the code and take extra care of boundary cases! Should you maybe even change the signature of the method getLongestWord()? Given these inputs \"The quick brown fox jumps over the lazy dog\": \"\" \" \" \"foo bar 1234\" null \"A sentence, with some: punctuation!\" What should your method do, and what should the test case expect? New specs: - throw an IllegalArgumentException for cases 2, 3 and 5 - strip punctuation characters: ‘:’, ‘;’, ‘?’ etc - keep numbers (why? Because I like them). Here is a (still flawed) next iteration public static String getLongestWord(String text) { if (isIllegalInput(text)) { throw new IllegalArgumentException(&quot;text cannot be null or empty&quot;); } text = stripPunctuationCharacters(text); String[] words = text.split(&quot; &quot;); String longest = &quot;&quot;; for (String word : words) { if (word.length() &gt;= longest.length()) { longest = word; } } return longest; } private static boolean isIllegalInput(String text) { return null == text || text.isEmpty() || text.equals(&quot; &quot;); } public static String stripPunctuationCharacters(String text) { return text.replaceAll(&quot;[?,.:;]&quot;, &quot;&quot;); } Notice how very small pieces of code have been extracted to separate methods. It makes the functionality so much more readable! Compare the readability of this if (isIllegalInput(text)) { throw new IllegalArgumentException(&quot;text cannot be null or empty&quot;); } with this if (null == text || text.isEmpty() || text.equals(&quot; &quot;)) { throw new IllegalArgumentException(&quot;text cannot be null or empty&quot;); } Besides readability, these small methods can be tested separately, making for a much more robust test suite. 41.4 Document! Don’t forget to write down your design decisions in the Javadoc section - especially regarding public methods. /** * This method searches for the longest word in * a given string. * It will split the String on all spaces and * removes all punctuation characters (matching * the pattern &quot;[:;,.?!]&quot;). If multiple words * have the same length, it will return the * first of these. * @param text the text to analyze * @return longest the longest word * @throws IllegalArgumentException when * a null value, an empty string or a single space is passed */ The nice thing about Javadoc is that you can access it in a readable manner from within your IDE (Fn+F1 on Mac or Ctrl + Q on Linux/Windows): Get Javadoc info 41.5 JUnit assert...() methods You have seen the fail() and assertEquals() methods that simply fail a test or assert equality between two objects, respectively. Although in principle you could write almost any test with the assertEquals method, there are more. The primary reason is that they make your test suite more readable and more concise. Below are the assert methods you can use in your tests. Their names are mostly self-explanatory but some need a bit of an explanation. The assertThrows() method, testing for exceptions, will be dealt with in more detail, as well as the assertAll() method that groups other assertions. assertEquals() assertTrue() &amp; assertFalse() assertNull() &amp; assertNotNull() assertThrows() assertArrayEquals() assertSame() &amp; assertNotSame() assertAll() fail() Note that equality is not equal to sameness! There are overloaded variants for many of them. Please refer to the docs for more detail: https://junit.org/junit5/docs/current/user-guide 41.6 Testing for Exceptions The method assertThrows(Class&lt;? extends Throwable&gt; expectedType, Executable executable) in JUnit5 is used to assert that the supplied executable will throw an exception of the expected type. It relies on lambdas, which of course were not discussed yet. However, looking at the example below you can probably figure out how to do it for your method to be tested. @Test void shouldThrowException() { Throwable exception = assertThrows( IllegalArgumentException.class, /*expects an IllegalArgumentException.class instance*/ () -&gt; TextUtils.getLongestWord(null)); /*will call getLongestWord as tested method*/ /*this uses a regular assertTrue test to check for the exception message*/ assertEquals(exception.getMessage(), &quot;text cannot be null&quot;); } If you don’t like (or understand) lambdas you can also use the strategy below with basic Java to achieve the same test functionality. @Test public void shouldThrowExceptionOldSchool() { try { TextUtils.getLongestWord(null); fail(&quot;Expected an IllegalArgumentException&quot;); } catch (IllegalArgumentException e) { assertEquals(&quot;text cannot be null&quot;, e.getMessage()); } } 41.7 Grouping assertions using assertAll() When multiple assertions are concern a single object, it may be a good idea to treat them as a single assertion. That is where assertAll() comes in. This method takes a varargs “list” of Executables. Here is a self-contained example (borrowed and adapted from the official docs). @DisplayName(&quot;Testing the name elements of Person&quot;) @Test void groupedAssertions() { class Person { String firstName; String LastName; public Person(String firstName, String lastName) { this.firstName = firstName; LastName = lastName; } public String getFirstName() { return firstName; } public String getLastName() { return LastName; } } Person person = new Person(&quot;Jane&quot;, &quot;Goodall&quot;); // In a grouped assertion all assertions are executed, and all // failures will be reported together. assertAll(&quot;person&quot;, () -&gt; assertEquals(&quot;Jane&quot;, person.getFirstName()), () -&gt; assertEquals(&quot;Doe&quot;, person.getLastName()) ); } This results in Grouped assertions output You can even nest them within code blocks: @Test void dependentAssertions() { Person person = new Person(&quot;Jane&quot;, &quot;Goodall&quot;); // Within a code block, if an assertion fails the // subsequent code in the same block will be skipped. assertAll(&quot;properties&quot;, () -&gt; { String firstName = person.getFirstName(); assertNotNull(firstName); // Executed only if the previous assertion is valid. assertAll(&quot;first name&quot;, () -&gt; assertTrue(firstName.startsWith(&quot;J&quot;)), () -&gt; assertTrue(firstName.endsWith(&quot;e&quot;)) ); }, () -&gt; { // Grouped assertion, so processed independently // of results of first name assertions. String lastName = person.getLastName(); assertNotNull(lastName); // Executed only if the previous assertion is valid. assertAll(&quot;last name&quot;, () -&gt; assertTrue(lastName.startsWith(&quot;G&quot;)), () -&gt; assertTrue(lastName.endsWith(&quot;l&quot;)) ); } ); } "],["junit-5-advanced-features.html", "Chapter 42 JUnit 5 advanced features 42.1 Introduction 42.2 JUnit 5 annotations", " Chapter 42 JUnit 5 advanced features 42.1 Introduction This post deals with (slightly) more advanced JUnit features usage of annotations other than @Test the assertJ library for writing assertions 42.2 JUnit 5 annotations You probably have seen annotations in your Java code by now, for example @Override or @SuppressWarnings(\"unused\"). Annotations are a form of syntactic metadata that can be added to Java source code (classes, methods, variables). They attach “properties” to classes, methods or variables. JUnit has a whole suite of annotations that you can use to publish a test case to the test runtime, or to modify when it is run, or its scope, for instance. Here are a few of the most common ones. Please refer to the official docs for a complete listing. @Test This is the most important one. It marks a method as a JUnit test method, so that it can be discovered by the test runtime. Nothing else is required. @Test public void testImportant() { String first = &quot;Michiel&quot;; String second = &quot;Michiel&quot;; //What do you think - will this pass? assertSame(first, second); } @Disabled The @Disabled annotation is used to (temporary) disable a test. It is not used very often, because forgetting to remove it again is a lurking danger. A better alternative is to use the @Tag annotation which is discussed in the next post. @DisplayName Use the @DisplayName annotation to have the method represented by a more human-readable message. So instead of “testLongestWordWithSingleSpace()” you could have @DisplayName(\"Single space input to longestWord()\"). unfortunately, this feature is not satisfactorily supported in IntelliJ when using Gradle as Test Runner: It does not show the display name in the Run panel. The Gradle test report does show the display names correctly however. You can sort of “fix” this by choosing to have IntelliJ IDEA run your tests instead of Gradle. This can be done via Preferences → Build, Execution, Deployment → Build Tools → Gradle → choose IntelliJ IDEA from the pulldown at “Run tests using”. Unfortunately, this disables the @Tag selection mechanism which is discussed in the next post… I recommend always using the @Displayname annotation. Support for it will undoubtedly improve. @BeforeEach and @AfterEach @BeforeEach and @AfterEach run respectively before and after each test case. You use them to re-initialize objects that may have been changed during a previous test. For instance, a Polygon object under test: private Polygon polygon; @BeforeEach public void resetPolygon() { polygon = new Polygon(); polygon.addCoordinate(new Coordinate(1, 2)); polygon.addCoordinate(new Coordinate(3, 6)); } @BeforeAll and @AfterAll @BeforeAll and @AfterAll annotations are similar to @AfterEach and @BeforeEach with the difference that they are called once per test class execution and not on a per-test basis. These are used to initialize class level resources (i.e. load a properties file). Methods annotated with @BeforeAll or @AfterAll the should be static. @Tag The @Tag annotation is a much more sophisticated way of switching (groups of) tests on and off. You use them in combination with a configuration of your test runtime (in this case Gradle). Here are two tagged methods. @Tag(&quot;sometimes&quot;) @DisplayName(&quot;Tag demo method 1: &#39;sometimes&#39;&quot;) @Test public void tagDemo1() { System.out.println(&quot;Tag demo 1 running&quot;); } @Tag(&quot;rarely&quot;) @DisplayName(&quot;Tag demo method 2: &#39;rarely&#39;&quot;) @Test public void tagDemo2() { System.out.println(&quot;Tag demo 2 running.&quot;); } Assuming all other test methods are untagged; this declaration in your build.gradle file test { useJUnitPlatform { excludeTags &#39;rarely&#39; } } will result in tagDemo1() being executed as well as all other tests - also the ones without any tag. So this only excludes tagDemo2() and any other class or test having this tag. On the other hand, this configuration test { useJUnitPlatform { includeTags &#39;sometimes&#39; } } will result in only tagDemo1() being executed. You can @Tag single methods as well as classes. @ParameterizedTest You can repeat the same test with different inputs using the @ParameterizedTest annotation. It is highly versatile, so you should really read the docs when your professional setting takes you there. In order to use this annotation, you should add this line to your dependencies (in this case, build.gradle): testImplementation &#39;org.junit.jupiter:junit-jupiter-params:5.5.2&#39; When you have a test that should be executed with a few different input values, you can do something like this: /** * parameterized test with single value */ @DisplayName(&quot;Palindrome finding&quot;) @ParameterizedTest(name = &quot;\\&quot;{0}\\&quot; should be a palindrome&quot;) @ValueSource(strings = {&quot;racecar&quot;, &quot;radar&quot;, &quot;able was I ere I saw elba&quot;}) void palindromes(String candidate) { assertTrue(isPalindrome(candidate), () -&gt; candidate + &quot; should be a palindrome!&quot;); } This will carry out the asertTrue() statement sequentially with the inputs “racecar”, “radar”, “able was I ere I saw elba” that will be injected into the variable candidate. These values are provided by the @ValueSource annotation. If one of the inputs causes the test to fail, all subsequent candidates will still be run. This is a big difference with the case where you have multiple assert statements within a single test method. If one fails, all following assert tests will be skipped. Use this setup if all your test inputs are expected to give the same result (in this case, being a legal palindrome). Note that the annotation (@ParameterizedTest(name = \"\\\"{0}\\\" should be a palindrome\")) supports a dynamically generated error message using a format string where the input will be inserted in tha case of failure. If you have multiple values to be inserted, you should consider using the @CsvSource annotation: /** * parameterized test with two values */ @DisplayName(&quot;Roman numeral&quot;) @ParameterizedTest(name = &quot;\\&quot;{0}\\&quot; should be {1}&quot;) @CsvSource({&quot;I, 1&quot;, &quot;II, 2&quot;, &quot;V, 5&quot;}) void withNiceName(String word, int number) { //DO TESTING WORK } "],["uml.html", "Chapter 43 UML", " Chapter 43 UML This chapter only gives a really simple intro so you are able to read the schematics that are used in the courses, in books and on the internet. In the picture below you can see a UML schema of a simple datamodel. Since it uses the OO UML conventions, any OO programmer can “read” the picture and immediately understand what story it is telling. Example UML UML is used to create graphical representations of your design –any design-. Since there are strict rules/conventions, other designers can “read” your model easily. In the chapter only OO design UML is dealt with, and the bare essentials at that. Class A rectangle containing three compartments stacked vertically. The top compartment holds the class name. The middle compartment: class attributes/properties with name and type. The bottom compartment: class operations/methods with name, parameters (not always) and return type. A class without (left) and with types (right) The attributes’ type, method parameter names and types and return types may also be given, as shown in the figure. Sometimes, members (properties and/or methods) are preceded by a symbol indication their visibility: + denotes public attributes or operations - denotes private attributes or operations # denotes protected attributes or operations ~ denotes package attributes or operations Here is another class example: Employee. Regular setters and getters have been omitted to keep the picture clean. An Employee class The UML plugin for IntelliJ -used for some of the graphics in this chapter- uses lock symbols to show the scope of the members: Employee class in intelliJ) Interfaces A class and an interface differ: A class can have an actual instance, whereas an interface must have at least one class to implement it. An interface is drawn just like a class, but the top compartment of the rectangle also has either the text &lt;&lt;interface&gt;&gt; or the name of the class is printed in italics. Interface EmployeeDataSource UML Again, the IntelliJ UML plugin takes a slightly different approach. EmployeeDataSource in IntelliJ Inheritance Inheritance is indicated by a solid line with a closed, (usually) unfilled arrowhead pointing at the super class. It can be drawn with separate lines or using a tree notation, as in this example. Employee inheritance Realization Realization is a bit like inheritance. Subclasses indicate inheritance. Sometimes implementing classes of interfaces are also called subclasses, but the relation is is slightly different. Although they pas the IS-A test of the instanceof operator, they are actually realizations of a contract. Therefore they show up slightly different in an UML schema. Realization is indicated with a dashed line and closed, filled arrowheads pointing at the interface. Realization, or implementation Association It is a relationship between objects. One object is connected to the other. Usually called as “has-a” relationship. Both objects have independent life-cycle. Each object owns their actions and will not affect other object. Example: Car and Driver. Simple association Basic Aggregation A specialized form of Association. Usually called as “has-a” relationship. Each object has an independent life-cycle. A whole-part relationship between a component object and an aggregate object. There is sense of ownership between objects. In basic aggregation, the child class instance can outlive its parent class. Drawn with a solid line from the parent class to the part class, with an unfilled diamond shape on the parent class’s association end. Basic aggregation This is a typical example of basic aggregation. A car has 3 to 4 wheels, and wheels can absolutely outlive their cars (and be exchanged for that matter). Composition aggregation This is also a specialized form of Aggregation. Usually called as “has-a” relationship. The Child Object has a dependent life-cycle. This is what separates it from aggregation. A whole-part relationship between a component object and an aggregate object (one class is an integral part of another class). Sense of ownership between objects In composition aggregation, the child class’s instance lifecycle is dependent on the parent class’s instance lifecycle. Also, the part class can only be related to one instance of the parent class. Drawn with a solid line from the parent class to the part class, with a filled diamond shape on the parent class’s association end. Composition aggregation In this example, a company can have zero to many deprtments. However, a department cannot outlive its company. Reflexive aggregation One class is associated with itself. Reflexive aggregation Here it means that an instance of Employee can be the manager of other (0 to many) Employee instances. Drawn with a solid line. All together In this example, all described types of UML entities and relationships are present, as well as some more. All entities and relationships "],["refactoring.html", "Chapter 44 Refactoring 44.1 Introduction 44.2 Get to know what is there 44.3 Refactor 44.4 Take over", " Chapter 44 Refactoring 44.1 Introduction This will be quite a long post. One I hope you will finish! If you want to follow along in the code base, you should clone the repo. It is available at bitbucket. Check out commit eaf007f to have a look at the original project. It was created by a student of mine, a third year bioinformatics student who will remain anonymous. As final assignment of the course Introduction to Java programming, he wrote a tool that can be used to read, summarize and filter files of the gff3 format (seehttps://www.ensembl.org/info/website/upload/gff3.html). This flat-file format is used to describe (annotate) elements (features), such as genes and introns, on DNA molecules, also supporting hierarchical or tree-like relationships. Here is a small example, copied (and slimmed down) from a much larger file describing some piece of Potato DNA: PGSC0003DMB000000010 BGI gene 1242814 1245448 . . . ID=PGSC0003DMG400000001; PGSC0003DMB000000010 Cufflinks mRNA 1242814 1245444 . + . ID=PGSC0003DMT400000001;Parent=PGSC0003DMG400000001;Source_id=RNASEQ44.3678.0;Mapping_depth=48.922289;Class=1; PGSC0003DMB000000010 Cufflinks mRNA 1242814 1245444 . + . ID=PGSC0003DMT400000002;Parent=PGSC0003DMG400000001;Source_id=RNASEQ44.3678.1;Mapping_depth=349.773769;Class=1; PGSC0003DMB000000010 Cufflinks mRNA 1243971 1245448 . + . ID=PGSC0003DMT400000003;Parent=PGSC0003DMG400000001;Source_id=RNASEQ44.3678.2;Mapping_depth=52.447281;Class=1; PGSC0003DMB000000010 Cufflinks exon 1242814 1243429 . + . ID=PGSC0003DME400000001;Parent=PGSC0003DMT400000001,PGSC0003DMT400000002; PGSC0003DMB000000010 Cufflinks exon 1243532 1243736 . + . ID=PGSC0003DME400000002;Parent=PGSC0003DMT400000001,PGSC0003DMT400000002; PGSC0003DMB000000010 Cufflinks intron 1243430 1243531 . + . ID=PGSC0003DMI400000001;Parent=PGSC0003DMT400000001,PGSC0003DMT400000002; PGSC0003DMB000000010 Cufflinks intron 1244851 1244983 . + . ID=PGSC0003DMI400000005;Parent=PGSC0003DMT400000002; PGSC0003DMB000000010 BestORF CDS 1243614 1243736 . + 0 ID=PGSC0003DMC400000001;Parent=PGSC0003DMT400000001; PGSC0003DMB000000010 BestORF CDS 1244206 1244487 . + 0 ID=PGSC0003DMC400000001;Parent=PGSC0003DMT400000001; PGSC0003DMB000000155 BGI gene 1093109 1102125 . . . ID=PGSC0003DMG400000278; It is a tab-separated file with this -abbreviated- specification: Fields must be tab-separated. Also, all but the final field in each feature line must contain a value; “empty” columns should be denoted with a ‘.’ seqid - name/ID of the chromosome or segment source - name of the program that generated this feature type - type of feature. start - Start position of the feature, starting at 1. end - End position of the feature, starting at 1. score - A floating point value. strand - defined as + (forward) or - (reverse). phase - One of ‘0’, ‘1’ or ‘2’. ‘0’ indicates that the first base of the feature is the first base of a codon, ‘1’ that the second base is the first base of a codon, and so on. attributes - A semicolon-separated list of tag=value pairs, providing additional information about each feature. Some of these tags are predefined, e.g. ID, Name, Alias, Parent. I chose this particular project because (a) it is simple enough to be understood (b) complex enough to be a serious challenge (c) it had so many inline comments that the unintelligible code could be understood and (d) the functionality was (as far as I tested) not perfect, but OK. The student had implemented all the required use cases. But the code itself was written like a big old script, with many (naming) convention violations, OO violations, Encapsulation and Abstraction not applied. You’ll see many examples as we plod along. I do not plan to finish the whole project here; there should be some challenge for you left. Note on JUnit tests When taking over a code base like this, without any (J)Unit tests, it is a very good idea to develop JUnit tests in concert with your refactoring efforts. Take a look at the (too) few JUnit tests that I added to this project as well. 44.2 Get to know what is there First, of course, you need to run the tool in different modes and study the existing code base to what exactly is going on. Running it in this mode -i data/gff3_sample.gff3 -s will give a summary: file gff3_sample.gff3 total number of features 22 molecules with features: human15.1 number of features 22 CDS 10 gene 1 three_prime_UT 4 mRNA 4 five_prime_UTR 3 That’s not really lined out but it’ll do for now. Another use case, looking for features of a specific type -i data/gff3_sample.gff3 -ft mRNA: human15.1 . mRNA 214360 215771 . + . Comments=fixed+one+splice+junction;Parent=HsG8283;Evidence=7000000069743825;Transcript_type=Novel_Transcript;Name=Novel+Transcript%2C+variant+%28partial%29;ID=HsT20206 human15.1 . mRNA 214590 215772 . + . Comments=fixed+one+splice+site%0A;Parent=HsG8283;Evidence=7000000069600840;Transcript_type=Novel_Transcript;Name=Novel+Transcript%2C+variant+%28partial%29;ID=HsT20207 human15.1 . mRNA 214301 215769 . + . Parent=HsG8283;Evidence=7000000069974357;Transcript_type=Candidates+for+Deletion;Name=Novel+Transcript+%28partial%29;ID=HsT16028 human15.1 . mRNA 215218 215772 . + . Parent=HsG8283;Evidence=7000000069512231;Transcript_type=Novel_Transcript;Name=Novel+Transcript%2C+variant;ID=HsT16029 Some more use cases were carried out. There do not seem to major bugs. This is the simple class and package layout of the project: gff_query/control GffLine /io CLIParser FileReader /model GffFile GffQuery (main) This puzzles me a bit. I would expect something like GffLine to be in the model and CLIParser somewhere not in the io package. We’ll get to that. A first inspection of the classes is a bit of a scare. Here is class FileReader. package nl.bioinf.gff_query.io; //imports omitted public class FileReader { public ArrayList&lt;String&gt; readFile(String raw_path) { ArrayList&lt;String&gt; fileArrayList = new ArrayList&lt;&gt;(); Path path = Paths.get(raw_path); try (BufferedReader reader = Files.newBufferedReader( path, Charset.defaultCharset())) { String lineFromFile; while ((lineFromFile = reader.readLine()) != null) { fileArrayList.add(lineFromFile); } } catch (IOException exception) { System.out.println(&quot;Error while reading file, \\&quot;IOExceptio\\&quot;, Did you give the correct location / does the &quot; + &quot;file exist?&quot;); } return fileArrayList; } } OK… This class does nothing more than processing the input file into a list of lines. Hello! Streaming processing? These files can get in the Gigabytes size. Moreover, it catches an exception only to generate a System.out.println message. Some work to be done here for sure. Note the name raw_path. This is somebody coming from Python, it seems. Next class, main: GffQuery. Take a minute to study its source before reading on. Note at least 5 points of improvement elegible for refactoring. package nl.bioinf.gff_query; //imports omitted public class GffQuery { public static void main(String[] args) throws IOException { // grab stuff from command line, try to parse. CLIParser my_cli_parser = new CLIParser(); // try to parse try { // before anything else, try for printing the help boolean help_present = my_cli_parser.cliHelpParse(args); if (help_present) {my_cli_parser.printHelp();} else{ // parse the command line arguments my_cli_parser.cliParse(args); // if this worked, go on and grab all the arguments. // but first check if the inputs are correct. boolean correct_inputs = my_cli_parser.checkInputs(); if (!correct_inputs) { System.out.println(&quot;Something went wrong when checking inputs, some may be incorrect, please &quot; + &quot;refer to the help page or check if your input file is correct.&quot;); } else { String[] parsed_arguments = my_cli_parser.returnArguments(); // handle stuff based on the case. int mycase; if (parsed_arguments[1].equals(&quot;true&quot;)) { // case 1, print summary. mycase = 1; } else { // case 2, actually apply filters and stuff. mycase = 2; } // before running the switch, read in file and make a GffFile object String path = parsed_arguments[0]; FileReader filereader = new FileReader(); // read in the raw file and catch the resulting ArrayList ArrayList fileArrayList = filereader.readFile(path); if (fileArrayList.isEmpty()) { mycase = 3; } // parse it to a GffFile object. GffFile myGffFile = new GffFile(fileArrayList, path); switch (mycase) { case 1: // do summary, not implemented as of yet. myGffFile.printSummary(); break; case 2: // apply all filters. // create filters array String[] filters = new String[5]; // filters has all filters like so; // fetch_type, fetch_region, filter, fetch_children, find_wildcard // parsed_arguments had this; // infile, summary, fetch_type, fetch_region, fetch_children, find_wildcard, filter filters[0] = parsed_arguments[2]; filters[1] = parsed_arguments[3]; filters[2] = parsed_arguments[6]; filters[3] = parsed_arguments[4]; filters[4] = parsed_arguments[5]; // put in filters and print results myGffFile.applyFilters(filters); if (myGffFile.toString().isEmpty()) { System.out.println(&quot;Oops, no lines found! Try to apply different filters. or double &quot; + &quot;check them. It might also be possible that the file did not contain any&quot; + &quot; valid gff3 formatted lines.&quot;); } System.out.print(myGffFile.toString()); break; case 3: System.out.println(&quot;empty or corrupt file.&quot;); break; } } } } catch( ParseException exp ) { // oops, something went wrong System.err.println( &quot;command line input parsing failed. please refer to the manual using the \\&quot;--help\\&quot; &quot; + &quot;argument&quot; ); } } } OK…again… So here are a few aspects that need to be addressed: Every line of code is in one big main This is a Many Responsibilities class Naming convention violations all over Too complex flow control Not OO at all and more We’ll get to this class later. The GffLine, GffFile and CLIParser classes are similar in nature. I won’t show them all here. In this part, I would like to focus on class CLIParser. To get it right, I will need to refactor in other places as well, but this will be my starting point. Why start here? This is a class that should have an obvious Single Responsibility: taking care of command-line arguments. Have a look at the code yourself first and think where you would start. package nl.bioinf.gff_query.io; import org.apache.commons.cli.*; import java.io.File; public class CLIParser { private Options options; private Options help_options; private CommandLine cmd; private CommandLine help_cmd; private DefaultParser parser; private HelpFormatter formatter; public CLIParser() { // Create parser object this.parser = new DefaultParser(); // create Options object this.options = new Options(); this.help_options = new Options(); // add cli options Option helpOption = Option.builder(&quot;h&quot;) .longOpt(&quot;help&quot;) .required(false) .hasArg(false) .desc(&quot;Gives program help.&quot;) .build(); this.help_options.addOption(helpOption); this.options.addOption(helpOption); Option infileOption = Option.builder(&quot;i&quot;) .longOpt(&quot;infile&quot;) .required(true) .hasArg(true) .desc(&quot;input gff3 file, e.g. \\&quot;gff3_sample.gff3\\&quot;&quot;) .build(); this.options.addOption(infileOption); Option summaryOption = Option.builder(&quot;s&quot;) .longOpt(&quot;summary&quot;) .required(false) .hasArg(false) .desc(&quot;makes a summary of the gff3 file.&quot;) .build(); this.options.addOption(summaryOption); Option fetchtypeOption = Option.builder(&quot;ft&quot;) .longOpt(&quot;fetch_type&quot;) .required(false) .hasArg(true) .desc(&quot;fetches type, e.g. \\&quot;CDS\\&quot;&quot;) .build(); this.options.addOption(fetchtypeOption); Option fetchregionOption = Option.builder(&quot;fr&quot;) .longOpt(&quot;fetch_region&quot;) .required(false) .hasArg(true) .desc(&quot;fetches region in between start..end, e.g. \\&quot;250000..260000\\&quot;&quot;) .build(); this.options.addOption(fetchregionOption); Option fetchchildrenOption = Option.builder(&quot;fc&quot;) .longOpt(&quot;fetch_children&quot;) .required(false) .hasArg(true) .desc(&quot;input which Parent group attributes to sort on, e.g. \\&quot;PGSC0003DMT400039136\\&quot;.&quot;) .build(); this.options.addOption(fetchchildrenOption); Option findwildcardOption = Option.builder(&quot;fw&quot;) .longOpt(&quot;find_wildcard&quot;) .required(false) .hasArg(true) .desc(&quot;input which wildcard, e.g. \\&quot;[dD]efesin\\&quot; to match on. (gff3 name attribute)&quot;) .build(); this.options.addOption(findwildcardOption); Option filterOption = Option.builder(&quot;f&quot;) .longOpt(&quot;filter&quot;) .required(false) .hasArg(true) .desc(&quot;miscellaneous filters, defined like&quot; + &quot; so: \\&quot;source|score|orientation|maximum_length|minimum_length\\&quot;&quot;) .build(); this.options.addOption(filterOption); // create help this.formatter = new HelpFormatter(); } public void cliParse(String[] args) throws ParseException { this.cmd = this.parser.parse(this.options, args); } public boolean checkInputs() { // check which inputs exist and check them (if neccesary) // check infile if (this.cmd.hasOption(&quot;infile&quot;)) { File f = new File(this.cmd.getOptionValue(&quot;infile&quot;)); if(!(f.exists() &amp;&amp; !f.isDirectory())) { // raise error that file does not exist. return false; } } // check filter if (this.cmd.hasOption(&quot;filter&quot;)) { // check if filter has correct formatting. If it does not, return false // &lt;SOURCE, SCORE, ORIENTATION MAXIMUM AND/OR MINIMUM LENGTH&gt; if (!this.cmd.getOptionValue(&quot;filter&quot;).matches( &quot;(.+\\\\|(\\\\d+|\\\\*|\\\\.)\\\\|(\\\\.|\\\\+|\\\\-|\\\\*)\\\\|(\\\\d+|\\\\*|\\\\.)\\\\|(\\\\d+|\\\\*|\\\\.))&quot;)) { return false; } } // check fetch region if (this.cmd.hasOption(&quot;fetch_region&quot;)) { // check if fetch region has correct formatting. if (!this.cmd.getOptionValue(&quot;fetch_region&quot;).matches(&quot;\\\\d+\\\\.\\\\.\\\\d+&quot;)){ return false; } } if (this.cmd.hasOption(&quot;fetch_type&quot;)) { // check if not a bool. if (this.cmd.getOptionValue(&quot;fetch_type&quot;).matches(&quot;(true|false)&quot;)) { return false; } } if (this.cmd.hasOption(&quot;fetch_children&quot;)) { // check if not a bool. if (this.cmd.getOptionValue(&quot;fetch_children&quot;).matches(&quot;(true|false)&quot;)) { return false; } } if (this.cmd.hasOption(&quot;find_wildcard&quot;)) { // check if not a bool. if (this.cmd.getOptionValue(&quot;find_wildcard&quot;).matches(&quot;(true|false)&quot;)) { return false; } } return true; } public String[] returnArguments() { String[] parsed_args = new String[7]; // build parsed_args array. // it is filled with options/null respectively like so; // infile, summary, fetch_type, fetch_region, fetch_children, find_wildcard, filter // Options without arguments, will be false if not present, and true when present. // Options with arguments, will also be false if not present, and their getOptionValue when present. // keep all values strings to be consistent. if (this.cmd.hasOption(&quot;infile&quot;)) {parsed_args[0] = this.cmd.getOptionValue(&quot;infile&quot;);} else {parsed_args[0] = &quot;false&quot;;} if (this.cmd.hasOption(&quot;summary&quot;)) {parsed_args[1] = &quot;true&quot;;} else {parsed_args[1] = &quot;false&quot;;} if (this.cmd.hasOption(&quot;fetch_type&quot;)) {parsed_args[2] = this.cmd.getOptionValue(&quot;fetch_type&quot;);} else {parsed_args[2] = &quot;false&quot;;} if (this.cmd.hasOption(&quot;fetch_region&quot;)) {parsed_args[3] = this.cmd.getOptionValue(&quot;fetch_region&quot;);} else {parsed_args[3] = &quot;false&quot;;} if (this.cmd.hasOption(&quot;fetch_children&quot;)) {parsed_args[4] = this.cmd.getOptionValue(&quot;fetch_children&quot;);} else {parsed_args[4] = &quot;false&quot;;} if (this.cmd.hasOption(&quot;find_wildcard&quot;)) {parsed_args[5] = this.cmd.getOptionValue(&quot;find_wildcard&quot;);} else {parsed_args[5] = &quot;false&quot;;} if (this.cmd.hasOption(&quot;filter&quot;)) {parsed_args[6] = this.cmd.getOptionValue(&quot;filter&quot;);} else {parsed_args[6] = &quot;false&quot;;} return parsed_args; } public boolean cliHelpParse(String[] args) throws ParseException { this.help_cmd = new DefaultParser().parse(this.help_options, args, true); if(this.help_cmd.hasOption(&quot;help&quot;) || this.help_cmd.getArgs().length == 0) { return true; } return false; } public void printHelp() { // print the help or the version there. return true because help is printed String footer = &quot;//omitted for brievity//&quot;; this.formatter.printHelp(&quot;GffQuery&quot;, &quot;Version: 1.1-SNAPSHOT&quot;, this.options, footer, true); } } Since I really -really- hate it when people don’t adhere to naming conventions, I’ll start there. 44.3 Refactor Rename variables and methods to adhere to Java standards. So, help_options becomes helpOptions, and help_cmd becomes helpCommandLine. You may note the absence of help_cmd in the final version. This is because there is no reason to maintain it as an instance variable. Remember by the way that methods should be verbs and variables should be nouns. Extract string literal to constants As an example, you see the word “infile” typed several times: Option infileOption = Option.builder(\"i\").longOpt(\"infile\"), if (this.cmd.hasOption(\"infile\")) (2 times). So this is the next step: get these out of the real code. public class CLIParser { //much code omitted in this snippet! public static final String OPTION_INFILE = &quot;infile&quot;; public static final String OPTION_SUMMARY = &quot;summary&quot;; //... public CLIParser() { Option infileOption = Option.builder(&quot;i&quot;) .longOpt(OPTION_INFILE) .required(true) .hasArg(true) .desc(&quot;input gff3 file, e.g. \\&quot;gff3_sample.gff3\\&quot;&quot;) .build(); //... } public boolean checkInputs() { // check which inputs exist and check them (if neccesary) // check infile if (this.cmd.hasOption(OPTION_INFILE)) { File f = new File(this.cmd.getOptionValue(&quot;infile&quot;)); if(!(f.exists() &amp;&amp; !f.isDirectory())) { // raise error that file does not exist. return false; } } //... } } Should the constants be public? Maybe, maybe not. Think about it. Extract functionality from constructor code. Constructors should be short and readable, and only construct (maybe through calling other methods). What I sometimes even see is code like this: public class MyApp{ public static void main(String[] args) { MyApp(args); } //more code } That means there is application logic in the constructor that is not even called explicitly! So here is the new constructor of the CLIParser class: public CLIParser() { this.parser = new DefaultParser(); buildOptions(); } It calls the buildOptions() method to, well, build te options. This method creates both this.options = new Options(); and this.helpOptions = new Options();. That seems a bit funny but this is a workaround for the problem with infileOption being required. This will throw an exception if it is absent. That conflicts with the case where only help is requested. Rename methods and variables to their real purpose. The method cliHelpParse() does not parse help. No, its intent is to signal that help is requested: public boolean cliHelpParse(String[] args) throws ParseException { this.help_cmd = new DefaultParser().parse(this.help_options, args, true); if(this.help_cmd.hasOption(&quot;help&quot;) || this.help_cmd.getArgs().length == 0) { return true; } return false; } So I refactored it into the following version, with a more suitable name, the commandLine variable now being local, and the ParseException not thrown anymore (this choice can be argued extensively). public boolean isHelpRequested(String[] args) { try { CommandLine commandLine = this.parser.parse(this.helpOptions, args); return (commandLine.hasOption(OPTION_HELP)); } catch (ParseException e) { e.printStackTrace(); } return true; } A variant to this solution could be: public boolean isHelpRequested(String[] args) { try { CommandLine commandLine = this.parser.parse(this.options, args); return (commandLine.hasOption(OPTION_HELP)); } catch (ParseException e) { return true; } } Here, the helpOption instance variable has been made obsolete, and in the catch block is is simply assumed that if anything goes wrong, help should be displayed. Which is the better? Next, method public void cliParse(String[] args) was renamed to public void parseCommandLineArguments(String[] args). The Single Responsibility Principle The next aspect is the method public boolean checkInputs() {}. Is class CLIParse the place to do this? What if some other means of options specification is implemeted, e.g. a GUI form? These options will need to be checked all the same. I think checkInputs should not be in that class. But where else? Main? No, I think checking options, and keeping track of options, should be the responsibility of a separate class. So that is where they’ll go. I created class GffAnalysisOptions and put option checking in it: public class GffAnalysisOptions { private String inFile; private boolean summary; private String searchType; private String searchRegion; private String searchChildren; private String searchWildcard; private String searchFilter; //getters and setters public boolean checkCorrectnessOfInputs() { //checking code } } Use basic OOP principles So, finally, there is this method (abbreviated): public String[] returnArguments() { String[] parsed_args = new String[7]; // build parsed_args array. // it is filled with options/null respectively like so; // infile, summary, fetch_type, fetch_region, fetch_children, find_wildcard, filter // Options without arguments, will be false if not present, and true when present. // Options with arguments, will also be false if not present, and their getOptionValue when present. // keep all values strings to be consistent. if (this.commandLine.hasOption(OPTION_INFILE)) {parsed_args[0] = this.commandLine.getOptionValue(&quot;infile&quot;);} else {parsed_args[0] = &quot;false&quot;;} if (this.commandLine.hasOption(OPTION_SUMMARY)) {parsed_args[1] = &quot;true&quot;;} else {parsed_args[1] = &quot;false&quot;;} if (this.commandLine.hasOption(OPTION_FETCH_TYPE)) {parsed_args[2] = this.commandLine.getOptionValue(&quot;fetch_type&quot;);} else {parsed_args[2] = &quot;false&quot;;} if (this.commandLine.hasOption(OPTION_FETCH_REGION)) {parsed_args[3] = this.commandLine.getOptionValue(&quot;fetch_region&quot;);} else {parsed_args[3] = &quot;false&quot;;} if (this.commandLine.hasOption(OPTION_FETCH_REGION)) {parsed_args[4] = this.commandLine.getOptionValue(&quot;fetch_children&quot;);} else {parsed_args[4] = &quot;false&quot;;} if (this.commandLine.hasOption(OPTION_FIND_WILDCARD)) {parsed_args[5] = this.commandLine.getOptionValue(&quot;find_wildcard&quot;);} else {parsed_args[5] = &quot;false&quot;;} if (this.commandLine.hasOption(OPTION_FILTER)) {parsed_args[6] = this.commandLine.getOptionValue(&quot;filter&quot;);} else {parsed_args[6] = &quot;false&quot;;} return parsed_args; } Auch! This hurts. A String[] with “false” values stored in it. Moreover, the code is so obfuscated that it needs many lines of comments. Why didn’t this student think of an Options class of some kind, like GffAnalysisOptions (shown above)? So here I wrote a replacement method for it: public GffAnalysisOptions getAnalysisOptions() { GffAnalysisOptions gffAnalysisOptions = new GffAnalysisOptions(); if (this.commandLine.hasOption(OPTION_INFILE)) { gffAnalysisOptions.setInFile(this.commandLine.getOptionValue(OPTION_INFILE)); } if (this.commandLine.hasOption(OPTION_SUMMARY)) { gffAnalysisOptions.setSummary(true); } if (this.commandLine.hasOption(OPTION_FETCH_TYPE)) { gffAnalysisOptions.setSearchType(this.commandLine.getOptionValue(OPTION_FETCH_TYPE)); } if (this.commandLine.hasOption(OPTION_FETCH_REGION)) { gffAnalysisOptions.setSearchRegion(this.commandLine.getOptionValue(OPTION_FETCH_REGION)); } if (this.commandLine.hasOption(OPTION_FETCH_CHILDREN)) { gffAnalysisOptions.setSearchChildren(this.commandLine.getOptionValue(OPTION_FETCH_CHILDREN)); } if (this.commandLine.hasOption(OPTION_FIND_WILDCARD)) { gffAnalysisOptions.setSearchWildcard(this.commandLine.getOptionValue(OPTION_FIND_WILDCARD)); } if (this.commandLine.hasOption(OPTION_FILTER)) { gffAnalysisOptions.setSearchFilterAsString(this.commandLine.getOptionValue(OPTION_FILTER)); } return gffAnalysisOptions; } Of course, these options need to be processed further - primarily the filter option - before they can be put to use. To replace the (fortunately localized) usage of the String[] with an GffAnalysisOptions instance, I switched to class GffQuery and eased it in: public static void main(String[] args) throws IOException { //much more code String[] parsedArguments = cliParser.returnArguments(); GffAnalysisOptions analysisOptions = cliParser.getAnalysisOptions(); //TODO replace use of parsedArguments with analysisOptions //more code // handle stuff based on the case. int mycase; if (parsedArguments[1].equals(&quot;true&quot;)) { // case 1, print summary. mycase = 1; } else { // case 2, actually apply filters and stuff. mycase = 2; } //much more code, also like this: // infile, summary, fetch_type, fetch_region, fetch_children, find_wildcard, filter filters[0] = parsedArguments[2]; filters[1] = parsedArguments[3]; filters[2] = parsedArguments[6]; filters[3] = parsedArguments[4]; filters[4] = parsedArguments[5]; } It is extremely tempting to refactor the other ugly code as well, such as the mycase = 1 ot the String[] filters, but restraint is very important in this kind of operation. So, only refactor out the use of parsedArguments now, and keep on writing and running your JUnit tests to verify no functionality gets broken: if (analysisOptions.isSummaryRequested()) { // if (parsedArguments[1].equals(&quot;true&quot;)) { // case 1, print summary. mycase = 1; } else { // case 2, actually apply filters and stuff. mycase = 2; } // before running the switch, read in file and make a GffFile object String path = analysisOptions.getInFile();//parsedArguments[0]; //more code String[] filters = new String[5]; // filters has all filters like so; // fetch_type, fetch_region, filter, fetch_children, find_wildcard // parsedArguments had this; // infile, summary, fetch_type, fetch_region, fetch_children, find_wildcard, filter filters[0] = analysisOptions.getSearchType(); filters[1] = analysisOptions.getSearchRegion(); filters[2] = analysisOptions.getSearchFilter(); filters[3] = analysisOptions.getSearchChildren(); filters[4] = analysisOptions.getSearchWildcard(); // filters[0] = parsedArguments[2]; // filters[1] = parsedArguments[3]; // filters[2] = parsedArguments[6]; // filters[3] = parsedArguments[4]; // filters[4] = parsedArguments[5]; Now the returnArguments() method can be removed. Do NOT comment it out because it clutters your code that is finally becoming readable. If you want it back (or have a look at it), simply go to a previous commit. Remove unneccesary comments Good code reads like a book! If you need it for yourself, your code is probably not very good. API methods should be very well documented of course, but inline comments or private methods comments should ideally not be necessary. Keep them to a minimum! They get outdated and are becoming damaging by themselves. A comment like /*builds the options*/ is entirely unnecessary! 44.3.1 The result This is the CLIParser class after complete refactoring: package nl.bioinf.gff_query.io; import org.apache.commons.cli.*; public class CLIParser { public static final String OPTION_HELP = &quot;help&quot;; public static final String OPTION_INFILE = &quot;infile&quot;; public static final String OPTION_SUMMARY = &quot;summary&quot;; public static final String OPTION_FETCH_TYPE = &quot;fetch_type&quot;; public static final String OPTION_FETCH_REGION = &quot;fetch_region&quot;; public static final String OPTION_FETCH_CHILDREN = &quot;fetch_children&quot;; public static final String OPTION_FIND_WILDCARD = &quot;find_wildcard&quot;; public static final String OPTION_FILTER = &quot;filter&quot;; /*private -&gt; testing*/ Options options; /*private -&gt; testing*/ CommandLine commandLine; private DefaultParser parser; private HelpFormatter formatter; private Options helpOptions; public CLIParser() { this.parser = new DefaultParser(); buildOptions(); } private void buildOptions() { this.options = new Options(); this.helpOptions = new Options(); Option helpOption = Option.builder(&quot;h&quot;) .longOpt(OPTION_HELP) .required(false) .hasArg(false) .desc(&quot;Gives usage instructions&quot;) .build(); options.addOption(helpOption); helpOptions.addOption(helpOption); Option infileOption = Option.builder(&quot;i&quot;) .longOpt(OPTION_INFILE) .required(true) .hasArg(true) .desc(&quot;The input gff3 file, as absolute or relative path&quot;) .build(); options.addOption(infileOption); Option summaryOption = Option.builder(&quot;s&quot;) .longOpt(OPTION_SUMMARY) .required(false) .hasArg(false) .desc(&quot;lists a summary of the gff3 file&quot;) .build(); options.addOption(summaryOption); Option fetchtypeOption = Option.builder(&quot;ft&quot;) .longOpt(OPTION_FETCH_TYPE) .required(false) .hasArg(true) .desc(&quot;Lists all features of the requested type, e.g. \\&quot;CDS\\&quot;&quot;) .build(); options.addOption(fetchtypeOption); Option fetchregionOption = Option.builder(&quot;fr&quot;) .longOpt(OPTION_FETCH_REGION) .required(false) .hasArg(true) .desc(&quot;Lists all the features that reside completely within the given region; specified as start..end, e.g. \\&quot;250000..260000\\&quot;&quot;) .build(); options.addOption(fetchregionOption); Option fetchchildrenOption = Option.builder(&quot;fc&quot;) .longOpt(OPTION_FETCH_CHILDREN) .required(false) .hasArg(true) .desc(&quot;Lists all child features of the given feature ID, e.g. \\&quot;PGSC0003DMT400039136\\&quot;&quot;) .build(); options.addOption(fetchchildrenOption); Option findwildcardOption = Option.builder(&quot;fw&quot;) .longOpt(OPTION_FIND_WILDCARD) .required(false) .hasArg(true) .desc(&quot;Lists all features for which the \\&quot;name\\&quot; attribute matches the given wildcard, specified as regex pattern, &quot; + &quot;e.g. \\&quot;[dD]efesin\\&quot;&quot;) .build(); options.addOption(findwildcardOption); Option filterOption = Option.builder(&quot;f&quot;) .longOpt(OPTION_FILTER) .required(false) .hasArg(true) .desc(&quot;Lists all features that pass all of the given filters specified in the format string defined as&quot; + &quot;: \\&quot;source|score|orientation|maximum_length|minimum_length\\&quot; where the filters should be relevant to the &quot; + &quot;given attribute. Suppression of an individual filter is indicated using an asterisk (*).&quot; + &quot;ORIENTATION should be defined using a \\&quot;+\\&quot;, \\&quot;-\\&quot; or \\&quot;.\\&quot; character&quot;) .build(); options.addOption(filterOption); } public void printHelp() { this.formatter = new HelpFormatter(); String footer = &quot;\\nPaths are platform independent.&quot;; this.formatter.printHelp(&quot;GffQuery&quot;, &quot;Version: 1.1-SNAPSHOT&quot;, this.options, footer, true); } public boolean isHelpRequested(String[] args) { try { CommandLine commandLine = this.parser.parse(this.options, args); return (commandLine.hasOption(OPTION_HELP)); } catch (ParseException e) { return true; } } public void parseCommandLineArguments(String[] args) throws ParseException { this.commandLine = this.parser.parse(this.options, args); } public GffAnalysisOptions getAnalysisOptions() { GffAnalysisOptions gffAnalysisOptions = new GffAnalysisOptions(); if (this.commandLine.hasOption(OPTION_INFILE)) { gffAnalysisOptions.setInFile(this.commandLine.getOptionValue(OPTION_INFILE)); } if (this.commandLine.hasOption(OPTION_SUMMARY)) { gffAnalysisOptions.setSummary(true); } if (this.commandLine.hasOption(OPTION_FETCH_TYPE)) { gffAnalysisOptions.setSearchType(this.commandLine.getOptionValue(OPTION_FETCH_TYPE)); } if (this.commandLine.hasOption(OPTION_FETCH_REGION)) { gffAnalysisOptions.setSearchRegion(this.commandLine.getOptionValue(OPTION_FETCH_REGION)); } if (this.commandLine.hasOption(OPTION_FETCH_CHILDREN)) { gffAnalysisOptions.setSearchChildren(this.commandLine.getOptionValue(OPTION_FETCH_CHILDREN)); } if (this.commandLine.hasOption(OPTION_FIND_WILDCARD)) { gffAnalysisOptions.setSearchWildcard(this.commandLine.getOptionValue(OPTION_FIND_WILDCARD)); } if (this.commandLine.hasOption(OPTION_FILTER)) { gffAnalysisOptions.setSearchFilterAsString(this.commandLine.getOptionValue(OPTION_FILTER)); } return gffAnalysisOptions; } } 44.4 Take over I challenge you to now take class GffQuery and make it look good! Check out tag 0.2 of branch master (commit 19a08f4). "],["rest-and-mvc-with-spring.html", "Chapter 45 REST and MVC with Spring 45.1 Create a new project 45.2 Create a REST response", " Chapter 45 REST and MVC with Spring These tutorials assume you have Jetbrands IntelliJ Idea ultimate. They also assume you have a working knowledge of http, Java - in particular Servlets, and annotations, Gradle, Thymeleaf and html. It is recommended to use Postman for testing your endpoints (visit Website). 45.1 Create a new project Let’s start with a quick rundown of how you create and run a Spring MVC Web application. Open IntelliJ Choose New Project… Spring Initializr → Next Give Group &amp; Artifact → Next Choose Gradle / Java / Jar → Next Choose Dependencies: Web → Spring Web Template Engines → ThymeleafSQL → JDBC API / Spring Data JPA / JDBC / MySQL Driver [This depends on what you are going to do with the app of course. These can be added later in build.gradle as well] Choose location → Next &amp; Finish The build.gradle file will have these dependencies: dependencies { implementation &#39;org.springframework.boot:spring-boot-starter-thymeleaf&#39; implementation &#39;org.springframework.boot:spring-boot-starter-web&#39; testImplementation &#39;org.springframework.boot:spring-boot-starter-test&#39; } If you look at the “External Libraries” section in the project panel you will see a huge amount of dependencies are pulled in with only these three top level dependencies. Go to root folder /main/java/&lt;your/package&gt;/ and open &lt;YourProject&gt;Application.java. Run the application by clicking on the green triangle in the editor margin. @SpringBootApplication public class SpringDemoProjectApplication { public static void main(String[] args) { SpringApplication.run(SpringDemoProjectApplication.class, args); } } Go to your browser (or Postman!) and open localhost/8080. This will generate “Whitelabel Error Page” in the browser. In Postman you get this - a Json literal: { &quot;timestamp&quot;: &quot;2021-01-12T09:54:58.110+00:00&quot;, &quot;status&quot;: 404, &quot;error&quot;: &quot;Not Found&quot;, &quot;message&quot;: &quot;&quot;, &quot;path&quot;: &quot;/&quot; } OK, the app works, but there nothing (no data or web page) being served by the application at this url. Therefore you get an 404/Not Found. Let’s fix that 45.2 Create a REST response Right click on base package → New → Package → name = webcontrol Right click on this package → New → Java Class → name = HelloRest In the editor, modify the class so it looks like this @RestController @RequestMapping(value = &quot;/hello&quot;) public class HelloRest { @GetMapping(value = &quot;/rest1&quot;) public String getHello() { return &quot;Hello Spring Boot!&quot;; } } The corresponding import statements will appear as well. There are several core Spring annotations here that warrant some explanation. The annotation @RestController tells the Spring container that this class will service REST (REpresentational State Transfer) endpoints. See https://en.wikipedia.org/wiki/Representational_state_transfer for details. @RequestMapping publishes to the container that this class will serve all urls that start with /hello relative to the context path (or base url) of this application. @GetMapping serves the same purpose, but only for GET requests. And in this case it applies only to the method it annotates. Therefore, the url &lt;app_root&gt;/hello/rest1 will map to the method getHello(). Since the entire class is annotated as being a REST controller, all return values of its controller methods (i.e. web-serving methods) will be converted into JSON literals automagically (using the Jackson library). Now reload the app by pressing this button in the lower panel: Go to Postman and hit the endpoint http://localhost:8080/hello/rest1. You should get this: Hello Spring Boot! 45.2.1 Serve Json literals Create a new package (model) with a new class, Bird, and generate a constructor, toString() and getters for all fields. package nl.bioinf.model; public class Bird{ private String name; private String status; public Bird (String name, String status) { this.name = name; this.status = status; } //boilerplate code omitted Create a new method within class HelloRest. @GetMapping(value = &quot;/rest2&quot;) public Bird getBird() { return new Bird(&quot;Long-legged buzzard&quot;, &quot;extremely rare&quot;); } Hit the endpoint http://localhost:8080/hello/rest2. As you can see, a JSON literal is returned representing a Java Bird instance. That is because your annotated the class with @RestController. All objects returned from the controller methods will be converted into a Json representation. In fact, it works for the whole object graph, so if you return a list of Java objects you will get a Javascript array containing these objects as json! 45.2.2 Path Variables Create a new method within HelloRest @GetMapping(value=&quot;/echo/{msg}&quot;) public String doEcho(@PathVariable String msg) { return &quot;You said&quot; + msg + &quot;...I say goodbye.&quot;; } Note that the three occurrences of “msg” should be typed exactly the same! Hit the endpoint http://localhost:8080/hello/echo/I%20Rule%20Rest. You will get this: You said I Rule Rest...I say goodbye. There is a new annotation here: @PathVariable. It is used on a method parameter. Together with the value=\"/echo/{msg}\" attribute of @GetMapping, it tells the container that there is a request variable embedded in the url and it should be extracted into String msg. 45.2.3 Request Parameters Create a new method within HelloRest @GetMapping(value=&quot;/echo_name&quot;) public String doEchoName(@RequestParam(value = &quot;name&quot;) String name) { return &quot;You said&quot; + name + &quot;...I say goodbye.&quot;; } And go to url http://localhost:8080/hello/echo_name?name= The annotation @RequestParam(value = \"name\") tells the system that the GET request should contain a request parameter called name and it should be inserted into the value of String name. You can specify whether it is a required parameter, and whether it should have a default value.: @GetMapping(value = &quot;/echo_name&quot;) public String doEchoName(@RequestParam( value = &quot;name&quot;, required = false, defaultValue = &quot;JohnDoe&quot;) String name) { return &quot;You said &quot; + name + &quot;...I say goodbye.&quot;; } 45.2.4 An html view instead of Json So far you have seen three basic ways of serving data using a REST endpoint. Now we’ll switch to serving an html view using Thymeleaf. Create a new class within package webcontrol called HelloMvc, with this content @Controller @RequestMapping(value=&quot;greeting&quot;) public class HelloMvc { @GetMapping(value=&quot;hello&quot;) public String getGreeting(Model model) { model.addAttribute(&quot;greeting&quot;, &quot;Hello to MVC&quot;); return &quot;greeting&quot;; } } Under folder /src/main/resources/templates, right-click and select New → Thymeleaf. This will generate a standard html page. Replace &lt;h1 th:tekst=&quot;#{page.title}&quot;&gt;Offline title&lt;/h1&gt; with &lt;h1 th:text=&quot;${greeting}&quot;&gt;_greeting_&lt;/h1&gt; Reload the app and hit the endpoint http://localhost:8080/greeting/hello. Postman will show this: &lt;!DOCTYPE html PUBLIC &quot;-//W3C//DTD XHTML 1.0 Strict//EN&quot; &quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd&quot;&gt; &lt;html xmlns=&quot;http://www.w3.org/1999/xhtml&quot;&gt; &lt;head&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=UTF-8&quot; /&gt; &lt;title&gt;Phrase of the day&lt;/title&gt; &lt;/head&gt; &lt;body&gt; &lt;h1&gt;Hello to MVC&lt;/h1&gt; &lt;/body&gt; &lt;/html&gt; Whereas the browser will show hello MVC This concludes a first acquaintance with several aspects of the Spring (Boot) framework. You have seen the creation and consuming of both REST and MVC-type endpoints. All discussed annotations are listed and explained here Demo code can be found in this git repo https://github.com/MichielNoback/spring-demo. Use tag tutorial1 to get the current version of the repo. "],["dependency-injection-in-spring.html", "Chapter 46 Dependency Injection in Spring", " Chapter 46 Dependency Injection in Spring In software engineering, dependency injection (DI) is a technique in which an object receives other objects that it depends on. Together with its elaborate collection of annotations, dependency injection is the heart of the Spring framework. We will be using the debugger to explore the concept of DI. The same project of the previous tutorial will be used to go through this tutorial. The previously used Bird class will also be used, with minor modifications (an ID field was added). As example, a simple Bird “database” will be used as data layer to make available to the application. This is the Bird class: package nl.bioinf.model; import java.util.Objects; public class Bird { private Long id; private String name; private String status; public Bird(Long id, String name, String status) { this.id = Objects.requireNonNull(id); this.name = Objects.requireNonNull(name); this.status = status; } public Long getId() { return id; } public String getName() { return name; } public String getStatus() { return status; } @Override public String toString() { return &quot;Bird{&quot; + &quot;name=&#39;&quot; + name + &#39;\\&#39;&#39; + &quot;, status=&#39;&quot; + status + &#39;\\&#39;&#39; + &#39;}&#39;; } @Override public boolean equals(Object o) { if (this == o) return true; if (o == null || getClass() != o.getClass()) return false; Bird bird = (Bird) o; return getId() != null ? getId().equals(bird.getId()) : bird.getId() == null; } @Override public int hashCode() { return getId() != null ? getId().hashCode() : 0; } } Create a package named dao. In it, create an interface named BirdsRepository: package nl.bioinf.dao; import nl.bioinf.model.Bird; public interface BirdsRepository { void add(Bird bird); Bird findByName(String name); Bird findById(Long id); } Create a sub-package of dao named dummy. In this package, create a class named BirdsRepositoryDummyImpl that implements the interface. It uses the Java Streams api that may be new to you. Try to figure out what is going on: package nl.bioinf.dao.dummy; //imports omitted public class BirdsRepositoryDummyImpl implements BirdsRepository { private Map&lt;Long, Bird&gt; birds = new HashMap&lt;&gt;(); @Override public void add(Bird bird) { Objects.requireNonNull(bird); this.birds.put(bird.getId(), bird); } @Override public Bird findByName(String name) { final List&lt;Bird&gt; found = this.birds .values() .stream() .filter(b -&gt; b.getName().equals(name)) .collect(Collectors.toList()); assert(found.size() &lt;= 1); if (found.isEmpty()) { return null; } else { return found.get(0); } } @Override public Bird findById(Long id) { if (this.birds.containsKey(id)) { return birds.get(id); } else { return null; } } } Note that returning null from a method is generally considered bad practice. You should use the Optional class for such cases. However, for simplicity’s sake I keep things as they are. Also note there are more sophisticated ways of “mocking” your data layer. Let’s first create some tests to see whether it works. package nl.bioinf.dao.dummy; //imports omitted class BirdsRepositoryDummyImplTest { private BirdsRepository birdsRepository; private Bird bird; @BeforeEach void setupDatabase() { this.birdsRepository = new BirdsRepositoryDummyImpl(); this.bird = new Bird(1234L, &quot;Steppe eagle&quot;, &quot;extremely rare&quot;); } @Test void findByName_OK() { birdsRepository.add(this.bird); Bird found = birdsRepository.findByName(&quot;Steppe eagle&quot;); assertEquals(this.bird, found); } @Test void findByName_Null() { birdsRepository.add(this.bird); Bird found = birdsRepository.findByName(&quot;Tawny Eagle&quot;); assertNull(found); } @Test void findById() { birdsRepository.add(this.bird); Bird found = birdsRepository.findById(this.bird.getId()); assertEquals(this.bird, found); } } It passes. Note that, when we want to test the application, we will want to run these tests no matter what the service layer implementation looks like. This is called an integration test, and it also uses Spring DI. We’ll return to good testing practices in the Spring framework later. Now let’s consume the service. Here is a REST controller that we want to use to serve birds from the data layer: package nl.bioinf.webcontrol; //imports omitted @RestController @RequestMapping(value=&quot;/birds&quot;) public class BirdsController { @GetMapping(value = &quot;/{id}&quot;) public Bird getBirdById(@PathVariable(value=&quot;id&quot;) Long id) { //I need to get hold of a BirdsRepository implementation here throw new UnsupportedOperationException(&quot;not implemented yet&quot;); } } As you can see, in order to serve birds, a reference to a BirdsRepository implementation needs to be present. The BirdsController class has a dependency on a BirdsRepository implementation. There are several ways to satisfy this dependency. Whichever technique you choose, never make a class dependent on an implementation; always use abstractions. The dependency could be passed into the constructor or into a setter. But which object will be responsible for passing that dependency? Alternatively, you may have learned patterns like these: BirdsRepository repo = BirdsRepositoryDummyImpl.getInstance() //OR, more loosely coupled and thus better BirdsRepository repo = BirdsRepositoryFactory.getInstance(); Which makes the BirdsController class dependent on a factory class (or worse, a specific implementation). A general guideline in OO design is that you want to have as few dependencies as possible: loose coupling is the term for that (see wikipedia). Supporting loose coupling is exactly what the Spring framework is build for: Wiring the objects that make up the backbone of your application with the objects they depend upon. Let’s have a look at the Spring way of doing this. First, we’ll add a @Component annotation to the BirdsRepositoryDummyImpl class. @Component public class BirdsRepositoryDummyImpl implements BirdsRepository { public BirdsRepositoryDummyImpl() { //add a single bird to be able to serve this.birds.put(1111L, new Bird(1111L, &quot;Long-eared owl&quot;, &quot;fairly common&quot;)); } //rest of code omitted What this @Component annotation does is telling the Spring container that this class should be instantiated as a component of the application. Once you’ve done that, you should never take that responsibility back: never use new BirdsRepositoryDummyImpl() in your code. Spring is now responsible for that. Now, whenever your request an object of type BirdsRepository you will get the single instance of this class that Spring instantiates. For testing purposes, I already add a single bird within the constructor. I know, this is not the official way to do this. But I want to stay focussed on the topic here, which is dependency injection. Next, we’ll tell the Spring container we’ll be needing a component of type BirdsRepository, using the @Autowired annotation. @RestController @RequestMapping(value=&quot;/birds&quot;) public class BirdsController { @Autowired private BirdsRepository birdsRepository; @GetMapping(value = &quot;/{id}&quot;) public Bird getBirdById(@PathVariable(value=&quot;id&quot;) Long id) { return birdsRepository.findById(id); } } Go to the endpoint http://localhost:8080/birds/1111 and you should receive this: { &quot;id&quot;: 1111, &quot;name&quot;: &quot;Long-eared owl&quot;, &quot;status&quot;: &quot;fairly common&quot; } I used the interface type, not the implementation, to get hold of a BirdsRepositoryDummyImpl instance. Spring will look up all implementations and if there is only one, it will instantiate that class. If there are more implementations (or none), it will throw an error. More on how to solve that later. This is the simplest form of Autowiring; IntelliJ suggests it is not the best way. Alternatively, I could have used Autowiring of the constructor, like below. In some cases, autowiring a field gives null whereas autowiring the constructor works. See this blog post for a discussion on pros and cons of different types of DI. @RestController @RequestMapping(value=&quot;/birds&quot;) public class BirdsController { private final BirdsRepository birdsRepository; @Autowired public BirdsController(BirdsRepository birdsRepository) { this.birdsRepository = birdsRepository; } @GetMapping(value = &quot;/{id}&quot;) public Bird getBirdById(@PathVariable(value=&quot;id&quot;) Long id) { return birdsRepository.findById(id); } } Finally, I could also have used setter-based injection: @RestController @RequestMapping(value=&quot;/birds&quot;) public class BirdsController { private BirdsRepository birdsRepository; @Autowired private void setBirdsRepository(BirdsRepository repo) { this.birdsRepository = repo; } @GetMapping(value = &quot;/{id}&quot;) public Bird getBirdById(@PathVariable(value=&quot;id&quot;) Long id) { return birdsRepository.findById(id); } } Perhaps surprisingly, the setter can be made private. This concludes the three ways of doing dependency injection using the spring framework. Use this technique to build the backbone of your application. Once you’ve annotated a class as a @Component or other related ones such as @Service, @DataSource, never ever construct them yourself. Note that this is primarily used for classes of which the application needs only a single instance; you are not likely going to annotate your data objects in this way. "],["core-spring-annotations.html", "Chapter 47 Core (Spring) annotations 47.1 Generic annotations", " Chapter 47 Core (Spring) annotations This page lists the most common annotations of the Spring (MVC) framework. The Component scan process is central to all annotations. Annotated classes, methods and fields will only be found and processed if they are included in the component scanning process. Spring Boot automatically includes all source folders in this scan. Many annotations are actually subtypes of each other. In particular, @Component is the supertype for many other class-level annotations such as @Controller, @Service. For instance, if you look up class Controller by pressing Cmd (Ctr) + B when the cursor is on the name where it is used, you can see it is itself annotated with @Component: /** * Indicates that an annotated class is a &quot;Controller&quot; (e.g. a web controller). * * &lt;p&gt;This annotation serves as a specialization of {@link Component @Component}, * allowing for implementation classes to be autodetected through classpath scanning. * It is typically used in combination with annotated handler methods based on the * {@link org.springframework.web.bind.annotation.RequestMapping} annotation. * * @author Arjen Poutsma * @author Juergen Hoeller * @since 2.5 * @see Component * @see org.springframework.web.bind.annotation.RequestMapping * @see org.springframework.context.annotation.ClassPathBeanDefinitionScanner */ @Target({ElementType.TYPE}) @Retention(RetentionPolicy.RUNTIME) @Documented @Component public @interface Controller { /** * The value may indicate a suggestion for a logical component name, * to be turned into a Spring bean in case of an autodetected component. * @return the suggested component name, if any (or empty String otherwise) */ @AliasFor(annotation = Component.class) String value() default &quot;&quot;; } Note that by looking these up you can also see which properties can be set, and what the default is when they are not required. Also note that the Javadoc section is highly informative! 47.1 Generic annotations @Configuration – tells the Spring container that this class published components, i.e. Beans @Bean – annotated on methods, telling the container that the method serves a component. The bean will have the name of the method by default. Use @Bean(initMethod = \"someMethod\") to hook into init. Use @PostConstruct to hook into init (this alternative adds extra dependencies in your Bean). @Scope – annotated on Beans. There are six types of bean scopes in Spring: singleton - with this scope, the container creates a single instance of a bean. All requests for such a bean will return the same object, which is cached. This is the default scope if no other scope is specified. prototype - with this scope, the container will create a new instance every time it is requested. request, session, application, websocket - these scopes are available only in a web-aware application context and are less often used in practice. @Component – annotated on classes. Tells the Spring container the class models a component of the system and should be instantiated by it. @Repository – subclasses @Component and adds a semantic layer: publishes a data repository. @Service – subclasses @Component and adds a semantic layer: publishes a service conponent. @Primary – used to indicate this bean is a primary choice when multiple candidates exist (multiple implementers of the same interface). Related to @Qualifier, but used in the service instead of the consumer. @Qualifier – Used to indicate which of several implementers (Bean interfaces) should be taken. Can be used on constructor fields, setters (below @Autowired) and fields (same) . Related to @Primary, but this done in the consumer instead of the service. @SpringBootApplication – entry / start point of the application. Can be used to configure several aspects of the app config. @PostConstruct &amp; @PreDestroy – annotation on Components, to be used as lifecycle hooks. @Profile – used to instantiate and serve Beans in a profile-dependent manner. @PropertySource and @TestPropertySource – used to configure additional sources of properties. E.g., this Will look under /src/main/resources for the given properties file. 47.1.1 Web oriented annotations @Controller – tells the framework this class deals with http requests. @RestController – See @Controller, but for REST endpoints and will return json by default. @GetMapping – A method that listens to an http Get request url. @PostMapping – idem, for Post requests. @RequestMapping – maps a URL to a class or method. In the example below, the url /projects maps to the entire class as base url for the methods contained therein. So, @GetMapping(\"/1\") maps to /projects/1. @RestController @RequestMapping(value=&quot;projects&quot;) public class ProjectController { @GetMapping(&quot;/1&quot;) public Project findOne() { return new Project(&quot;test&quot;, LocalDate.now()) } } @PathVariable – Used within the method signature of @xxxMapping methods to indicate the value of this variable should be obtained from the url. Used in combination with the value = \"\" attribute of the mapping, as in this example: @GetMapping(value = {/&quot;id&quot;}) public Project findOne(@PathVariable() Long id) { return projectsService.fid=ndById(id); } @RequestBody – Annotation used when in the body of a Post request a Json literal is sent that can be mapped onto a Java class. @PostMapping public void create(@RequestBody Project project) { projectService.save(project); } "]]
